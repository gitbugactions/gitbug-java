instance_id,problem_statement,image_tag,bug_patch
adoble-adr-j-7fe616c55a5b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.doble.adr.CommandNewTest#testOtherFilesInADRDirectory()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <0> but was: <1>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.adoble-adr-j-7fe616c55a5b:msbench-0.0.1,"diff --git a/src/main/java/org/doble/commands/CommandADR.java b/src/main/java/org/doble/commands/CommandADR.java
index 216e3db..6e545e8 100644
--- a/src/main/java/org/doble/commands/CommandADR.java
+++ b/src/main/java/org/doble/commands/CommandADR.java
@@ -19,7 +19,7 @@ import picocli.CommandLine.HelpCommand;
 
 @Command(name = ""adr"",
 		 description = ""Creation and management of architectural decision records (ADRs)"",
-		 version = ""2.1"",
+		 version = ""3.2.1"",
 		 exitCodeListHeading = ""Exit Codes:%n"",
 		 exitCodeList        = { "" 0:Successful program execution."",
 				 				 ""64:Invalid input: an unknown option or invalid parameter was specified."",
diff --git a/src/main/java/org/doble/commands/CommandNew.java b/src/main/java/org/doble/commands/CommandNew.java
index ea37e42..cd2f34a 100644
--- a/src/main/java/org/doble/commands/CommandNew.java
+++ b/src/main/java/org/doble/commands/CommandNew.java
@@ -236,7 +236,7 @@ public class CommandNew implements Callable<Integer> {
 
 	/**
 	 * Find the highest index of the ADRs in the adr directory by iterating
-	 * through all the files
+	 * through all the files that start with an  adr index number (i.e. dddd where d is a digit)
 	 *
 	 * @return int The highest index found. If no files are found returns 0.
 	 */
@@ -248,19 +248,58 @@ public class CommandNew implements Callable<Integer> {
 		Path adrPath = rootPath.resolve(docPath);
 
 		try {
-			highestIndex = Files.list(adrPath).mapToInt(CommandNew::toInt).max();
+			highestIndex = Files.list(adrPath).filter(CommandNew::wellFormedADR).mapToInt(CommandNew::toInt).max();
+			
 		} catch (IOException e) {
 			throw new ADRException(""FATAL: Unable to determine the indexes of the ADRs."", e);
-		}
+		} 
 
 		return (highestIndex.isPresent() ? highestIndex.getAsInt() : 0);
 	}
 
+	// Convert a ADR file name to its id number
+	// Assumes that the ADR file name is well formed.
 	private static int toInt(Path p) {
 		String name = p.getFileName().toString();
 
-		// Extract the first 4 characters
-		String id = name.substring(0, 4);
-		return new Integer(id);
+		// Extract the first 4 characters and creat an integer from them
+		String id = name.substring(0, ADR.MAX_ID_LENGTH);
+		return Integer.parseInt(id);
+		
 	}
+
+	/*
+	 * A well formed ADR has the form:
+	 *     dddd-*
+	 * where 'd' is a digit
+	 * and * refers to any number of charaters.
+	 */
+	private static boolean wellFormedADR(Path p) {
+		
+		String name = p.getFileName().toString();
+
+		// Instead of using a regex do some simple, and fast, checks
+
+		// Check that the file is longer than the id length and the '-'
+		if (name.length() < ADR.MAX_ID_LENGTH + 1) {
+			return false;
+		}
+
+		// Check that the 5th character is a '-'
+		if (name.indexOf('-') != ADR.MAX_ID_LENGTH) return false;
+
+		// Check that the first 4 characters are digits
+		boolean is_adr_with_index = name.chars().mapToObj(i -> (char)i).limit(ADR.MAX_ID_LENGTH).allMatch(c -> Character.isDigit(c));
+		if (!is_adr_with_index) {
+			return false;
+		}
+
+		
+
+		// All checks passed
+		return true;
+
+	}
+
+	
 }
diff --git a/src/main/java/org/doble/commands/CommandVersion.java b/src/main/java/org/doble/commands/CommandVersion.java
index a15bd3e..164d270 100644
--- a/src/main/java/org/doble/commands/CommandVersion.java
+++ b/src/main/java/org/doble/commands/CommandVersion.java
@@ -28,7 +28,7 @@ public class CommandVersion implements Callable<Integer> {
 	 * Version numbers adhere to to Semantic Versioning:  https://semver.org/spec/v2.0.0.html  *
 	 *                                                                                         *
 	 *******************************************************************************************/
-	private String version = ""3.2.0"";  // Minor release, backwards compatible 
+	private String version = ""3.2.1"";  // Minor release, backwards compatible 
 		
 	
 	@ParentCommand
"
assertj-assertj-vavr-f4d7f276e87c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.assertj.vavr.api.SeqAssert_containsExactly_inAnyOrder_Test#should_pass_if_List_contains_exactly_elements_in_any_order_using_element_comparator
Type: java.lang.AssertionError
Message: 
Expecting actual:
  List(SOMETHING, ELSE, AND, OTHER)
to contain exactly in any order:
  [""other"", ""and"", ""else"", ""something""]
elements not found:
  [""other"", ""and"", ""else"", ""something""]
and elements not expected:
  [""SOMETHING"", ""ELSE"", ""AND"", ""OTHER""]


Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.assertj-assertj-vavr-f4d7f276e87c:msbench-0.0.1,"diff --git a/src/main/java/org/assertj/vavr/api/AbstractSeqAssert.java b/src/main/java/org/assertj/vavr/api/AbstractSeqAssert.java
index 7353dab..bc8d763 100644
--- a/src/main/java/org/assertj/vavr/api/AbstractSeqAssert.java
+++ b/src/main/java/org/assertj/vavr/api/AbstractSeqAssert.java
@@ -19,6 +19,7 @@ import org.assertj.core.api.IndexedObjectEnumerableAssert;
 import org.assertj.core.data.Index;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.StandardComparisonStrategy;
 import org.assertj.core.util.CheckReturnValue;
 
@@ -67,6 +68,7 @@ abstract class AbstractSeqAssert<SELF extends AbstractSeqAssert<SELF, ACTUAL, EL
      */
     @CheckReturnValue
     public SELF usingElementComparator(Comparator<? super ELEMENT> customComparator) {
+        this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(customComparator));
         seqElementComparisonStrategy = new ComparatorBasedComparisonStrategy(customComparator);
         return myself;
     }
"
aws-aws-secretsmanager-jdbc-d25e52d637cf,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.amazonaws.secretsmanager.sql.AWSSecretsManagerPostgreSQLDriverTest#test_constructUrlNullDatabase
Type: org.junit.ComparisonFailure
Message: expected:<...//test-endpoint:1234[]> but was:<...//test-endpoint:1234[/]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.aws-aws-secretsmanager-jdbc-d25e52d637cf:msbench-0.0.1,"diff --git a/src/main/java/com/amazonaws/secretsmanager/sql/AWSSecretsManagerPostgreSQLDriver.java b/src/main/java/com/amazonaws/secretsmanager/sql/AWSSecretsManagerPostgreSQLDriver.java
index bfd2d6d..8af0071 100644
--- a/src/main/java/com/amazonaws/secretsmanager/sql/AWSSecretsManagerPostgreSQLDriver.java
+++ b/src/main/java/com/amazonaws/secretsmanager/sql/AWSSecretsManagerPostgreSQLDriver.java
@@ -116,8 +116,11 @@ public final class AWSSecretsManagerPostgreSQLDriver extends AWSSecretsManagerDr
         if (!StringUtils.isNullOrEmpty(port)) {
             url += "":"" + port;
         }
+
+        url += ""/"";
+
         if (!StringUtils.isNullOrEmpty(dbname)) {
-            url += ""/"" + dbname;
+            url += dbname;
         }
         return url;
     }
"
aws-event-ruler-68481127e050,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: software.amazon.event.ruler.JsonRuleCompilerTest#testWildcardConsecutiveWildcards
Type: java.lang.AssertionError
Message: Expected JSONParseException

Test: software.amazon.event.ruler.RuleCompilerTest#testWildcardConsecutiveWildcards
Type: java.lang.AssertionError
Message: Expected JSONParseException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.aws-event-ruler-68481127e050:msbench-0.0.1,"diff --git a/src/main/software/amazon/event/ruler/JsonRuleCompiler.java b/src/main/software/amazon/event/ruler/JsonRuleCompiler.java
index c6157f0..d76e22a 100644
--- a/src/main/software/amazon/event/ruler/JsonRuleCompiler.java
+++ b/src/main/software/amazon/event/ruler/JsonRuleCompiler.java
@@ -4,6 +4,8 @@ import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonToken;
+import software.amazon.event.ruler.input.ParseException;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Reader;
@@ -15,6 +17,8 @@ import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
 
+import static software.amazon.event.ruler.input.DefaultParser.getParser;
+
 /**
  * Represents a updated compiler comparing to RuleCompiler class, it parses a rule described by a JSON string into
  * a list of Map which is composed of field Patterns, each Map represents one dedicated match branch in the rule.
@@ -494,7 +498,13 @@ public class JsonRuleCompiler {
                 barf(parser, ""wildcard match pattern must be a string"");
             }
             final String parserText = parser.getText();
-            final Patterns pattern = Patterns.wildcardMatch('""' + parserText + '""');
+            String value = '""' + parserText + '""';
+            try {
+                getParser().parse(MatchType.WILDCARD, value);
+            } catch (ParseException e) {
+                barf(parser, e.getLocalizedMessage());
+            }
+            final Patterns pattern = Patterns.wildcardMatch(value);
             if (parser.nextToken() != JsonToken.END_OBJECT) {
                 barf(parser, ""Only one key allowed in match expression"");
             }
diff --git a/src/main/software/amazon/event/ruler/RuleCompiler.java b/src/main/software/amazon/event/ruler/RuleCompiler.java
index 872303d..01cce52 100644
--- a/src/main/software/amazon/event/ruler/RuleCompiler.java
+++ b/src/main/software/amazon/event/ruler/RuleCompiler.java
@@ -16,6 +16,9 @@ import com.fasterxml.jackson.core.JsonFactory;
 import com.fasterxml.jackson.core.JsonParseException;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonToken;
+import software.amazon.event.ruler.input.ParseException;
+
+import static software.amazon.event.ruler.input.DefaultParser.getParser;
 
 /**
  * Compiles Rules, expressed in JSON, for use in Ruler.
@@ -393,7 +396,13 @@ public final class RuleCompiler {
                 barf(parser, ""wildcard match pattern must be a string"");
             }
             final String parserText = parser.getText();
-            final Patterns pattern = Patterns.wildcardMatch('""' + parserText + '""');
+            String value = '""' + parserText + '""';
+            try {
+                getParser().parse(MatchType.WILDCARD, value);
+            } catch (ParseException e) {
+                barf(parser, e.getLocalizedMessage());
+            }
+            final Patterns pattern = Patterns.wildcardMatch(value);
             if (parser.nextToken() != JsonToken.END_OBJECT) {
                 barf(parser, ""Only one key allowed in match expression"");
             }
"
awslabs-aws-java-nio-spi-for-s3-ea1044d51bb4,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: software.amazon.nio.spi.s3.S3FileSystemTest#getRootDirectories
Type: java.lang.AssertionError
Message: java.lang.AssertionError

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.awslabs-aws-java-nio-spi-for-s3-ea1044d51bb4:msbench-0.0.1,"diff --git a/src/main/java/software/amazon/nio/spi/s3/S3FileSystem.java b/src/main/java/software/amazon/nio/spi/s3/S3FileSystem.java
index 5ba4585..b9e1f38 100644
--- a/src/main/java/software/amazon/nio/spi/s3/S3FileSystem.java
+++ b/src/main/java/software/amazon/nio/spi/s3/S3FileSystem.java
@@ -12,7 +12,16 @@ import java.io.File;
 import java.io.IOException;
 import java.net.URI;
 import java.nio.channels.Channel;
-import java.nio.file.*;
+import java.nio.file.ClosedFileSystemException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.FileStore;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.InvalidPathException;
+import java.nio.file.Path;
+import java.nio.file.PathMatcher;
+import java.nio.file.WatchService;
 import java.nio.file.attribute.UserPrincipalLookupService;
 import java.nio.file.spi.FileSystemProvider;
 import java.util.Collections;
@@ -182,7 +191,7 @@ public class S3FileSystem extends FileSystem {
      */
     @Override
     public Iterable<Path> getRootDirectories() {
-        return S3Path.getPath(this, ""/"");
+        return Collections.singleton(S3Path.getPath(this, ""/""));
     }
 
     /**
"
awslabs-aws-java-nio-spi-for-s3-8ae86f85f328,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: software.amazon.nio.spi.s3.S3PathTest#toUri()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Illegal character in path at index 17: s3://mybucket/dir with space/and	special&chars

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.awslabs-aws-java-nio-spi-for-s3-8ae86f85f328:msbench-0.0.1,"diff --git a/src/main/java/software/amazon/nio/spi/s3/S3Path.java b/src/main/java/software/amazon/nio/spi/s3/S3Path.java
index 1da52a2..914689a 100644
--- a/src/main/java/software/amazon/nio/spi/s3/S3Path.java
+++ b/src/main/java/software/amazon/nio/spi/s3/S3Path.java
@@ -9,7 +9,9 @@ import software.amazon.awssdk.services.s3.model.S3Object;
 
 import java.io.File;
 import java.io.IOError;
+import java.io.UnsupportedEncodingException;
 import java.net.URI;
+import java.net.URLEncoder;
 import java.nio.file.FileSystem;
 import java.nio.file.InvalidPathException;
 import java.nio.file.LinkOption;
@@ -599,7 +601,24 @@ public class S3Path implements Path {
      *
      * <p> This method constructs an absolute and normalized {@link URI} with a {@link
      * URI#getScheme() scheme} equal to the URI scheme that identifies the
-     * provider (s3).
+     * provider (s3). Please note that the returned URI is a well formed URI,
+     * which means all special characters (e.g. blanks, %, ?, etc.) are encoded.
+     * This may result in a different string from the real path (object key),
+     * which instead allows those characters. 
+     * 
+     * For instance, the S3 URI ""s3://mybucket/with space and %"" is a valid S3
+     * object key, which must be encoded when creating a Path and that will be
+     * encoded when creating a URI. E.g.:
+     * 
+     * <pre>
+     * {@code 
+     * S3Path p = (S3Path)Paths.get(""s3://mybucket/with+blank+and+%25""); // -> s3://mybucket/with blank and %
+     * String s = p.toString; // -> /mybucket/with blank and %
+     * URI u = p.toUri(); --> // -> s3://mybucket/with+blank+and+%25
+     * ...
+     * String s = p.getFileSystem().get(""with space"").toString(); // -> /with space 
+     * }
+     * </pre>
      *
      * @return the URI representing this path
      * @throws IOError           if an I/O error occurs obtaining the absolute path, or where a
@@ -610,12 +629,35 @@ public class S3Path implements Path {
      *                           is installed, the {@link #toAbsolutePath toAbsolutePath} method
      *                           throws a security exception.
      */
+    
     @Override
     public URI toUri() {
-        return URI.create(
-                fileSystem.provider().getScheme() + ""://""
-                        + bucketName()
-                        + this.toAbsolutePath().toRealPath(NOFOLLOW_LINKS));
+        Path path = toAbsolutePath().toRealPath(NOFOLLOW_LINKS);
+        Iterator<Path> elements = path.iterator();
+
+        StringBuilder uri = new StringBuilder(fileSystem.provider().getScheme() + ""://"");
+        uri.append(bucketName());
+        elements.forEachRemaining(
+            (e) -> {
+                String name = e.getFileName().toString();
+                try {
+                    if (name.endsWith(PATH_SEPARATOR)) {
+                        name = name.substring(0, name.length()-1);
+                    }
+                    uri.append(PATH_SEPARATOR).append(URLEncoder.encode(name, ""UTF-8""));
+                } catch (UnsupportedEncodingException x) {
+                    //
+                    // NOTE: I do not know how to reproduce this case...
+                    //
+                    throw new IllegalArgumentException(""path '"" + uri + ""' can not be converted to URI: "" + x.getMessage(), x);
+                }
+            }
+        );
+        if (isDirectory()) {
+            uri.append(PATH_SEPARATOR);
+        }
+
+        return URI.create(uri.toString());
     }
 
     /**
"
ballerina-platform-lsp4intellij-8b03eddead47,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.wso2.lsp4intellij.utils.FileUtilsTest#testVFSToURINotNull
Type: java.lang.AssertionError
Message: java.lang.AssertionError

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.ballerina-platform-lsp4intellij-8b03eddead47:msbench-0.0.1,"diff --git a/src/main/java/org/wso2/lsp4intellij/utils/FileUtils.java b/src/main/java/org/wso2/lsp4intellij/utils/FileUtils.java
index 01c1edd..9231c7d 100644
--- a/src/main/java/org/wso2/lsp4intellij/utils/FileUtils.java
+++ b/src/main/java/org/wso2/lsp4intellij/utils/FileUtils.java
@@ -198,12 +198,7 @@ public class FileUtils {
      * @return the URI
      */
     public static String VFSToURI(VirtualFile file) {
-        try {
-            return sanitizeURI(new URL(file.getUrl().replace("" "", SPACE_ENCODED)).toURI().toString());
-        } catch (MalformedURLException | URISyntaxException e) {
-            LOG.warn(e);
-            return null;
-        }
+        return file == null? null : pathToUri(file.getPath());
     }
 
     /**
@@ -286,7 +281,7 @@ public class FileUtils {
      * @return The uri
      */
     public static String pathToUri(@Nullable String path) {
-        return path != null ? sanitizeURI(new File(path.replace("" "", SPACE_ENCODED)).toURI().toString()) : null;
+        return path != null ? sanitizeURI(new File(path).toURI().toString()) : null;
     }
 
     public static String projectToUri(Project project) {
"
beanshell-beanshell-7a60a06bb567,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: bsh.BshScriptTestCase#scripted_object.bsh
Type: junit.framework.AssertionFailedError
Message: expected:<[I am overwriteToString]> but was:<['this' reference to Bsh object: NameSpace: overwriteToString (bsh.NameSpace@eded048)]> Line: 68 : assertEquals ( ""I am overwriteToString"" , """" + overwriteToString ( ) )  : while evaluating file: scripted_object.bsh

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.beanshell-beanshell-7a60a06bb567:msbench-0.0.1,"diff --git a/src/main/java/bsh/Reflect.java b/src/main/java/bsh/Reflect.java
index 214b91f..996abaa 100644
--- a/src/main/java/bsh/Reflect.java
+++ b/src/main/java/bsh/Reflect.java
@@ -1064,13 +1064,20 @@ public final class Reflect {
     }
 
     /*
-     * Get method from namespace
+     * Get declared method from namespace
      */
     public static BshMethod getMethod(NameSpace ns, String name, Class<?>[] sig) {
+        return getMethod(ns, name, sig, true);
+    }
+
+    /*
+     * Get method from namespace
+     */
+    public static BshMethod getMethod(NameSpace ns, String name, Class<?>[] sig, boolean declaredOnly) {
         if (null == ns)
             return null;
         try {
-            return ns.getMethod(name, sig, true);
+            return ns.getMethod(name, sig, declaredOnly);
         } catch (Exception e) {
             return null;
         }
diff --git a/src/main/java/bsh/This.java b/src/main/java/bsh/This.java
index 353cf6c..f519c81 100644
--- a/src/main/java/bsh/This.java
+++ b/src/main/java/bsh/This.java
@@ -219,11 +219,8 @@ public final class This implements java.io.Serializable, Runnable
                 otherwise callers from outside in Java will not see a the
                 proxy object as equal to itself.
             */
-            BshMethod equalsMethod = null;
-            try {
-                equalsMethod = namespace.getMethod(
-                    ""equals"", new Class<?>[] { Object.class } );
-            } catch ( UtilEvalError e ) {/*leave null*/ }
+            BshMethod equalsMethod = Reflect.getMethod(
+                namespace, ""equals"", new Class<?>[] { Object.class } );
             if ( methodName.equals(""equals"" ) && equalsMethod == null ) {
                 Object obj = args[0];
                 return proxy == obj;
@@ -233,14 +230,10 @@ public final class This implements java.io.Serializable, Runnable
                 If toString() is not explicitly defined override the default
                 to show the proxy interfaces.
             */
-            BshMethod toStringMethod = null;
-            try {
-                toStringMethod =
-                    namespace.getMethod( ""toString"", new Class<?>[] { } );
-            } catch ( UtilEvalError e ) {/*leave null*/ }
+            BshMethod toStringMethod = Reflect.getMethod(
+                namespace, ""toString"", new Class<?>[] { } );
 
-            if ( methodName.equals(""toString"" ) && toStringMethod == null)
-            {
+            if ( methodName.equals(""toString"" ) && toStringMethod == null) {
                 Class<?>[] ints = proxy.getClass().getInterfaces();
                 // XThis.this refers to the enclosing class instance
                 StringBuilder sb = new StringBuilder(
@@ -268,6 +261,10 @@ public final class This implements java.io.Serializable, Runnable
     }
 
     public String toString() {
+        BshMethod toString = Reflect.getMethod(namespace, ""toString"", new Class<?>[0]);
+        if (null != toString) try {
+            return (String)toString.invoke(new Object[0], declaringInterpreter);
+        } catch (EvalError e) { /* ignore we tried */ }
         return ""'this' reference to Bsh object: "" + namespace;
     }
 
@@ -381,10 +378,8 @@ public final class This implements java.io.Serializable, Runnable
 
         // Find the bsh method
         Class<?>[] types = Types.getTypes( args );
-        BshMethod bshMethod = null;
-        try {
-            bshMethod = namespace.getMethod( methodName, types, declaredOnly );
-        } catch ( UtilEvalError e ) { /*leave null*/ }
+        BshMethod bshMethod = Reflect.getMethod(
+            namespace, methodName, types, declaredOnly );
 
         if ( bshMethod != null )
             return bshMethod.invoke( args, interpreter, callstack, callerInfo );
@@ -401,7 +396,7 @@ public final class This implements java.io.Serializable, Runnable
         */
         // a default getClass() that returns the namespace instance class
         if ( methodName.equals(""getClass"") && args.length==0 )
-            return This.class;
+            return getClass();
 
         // a default toString() that shows the interfaces we implement
         if ( methodName.equals(""toString"") && args.length==0 )
@@ -418,22 +413,20 @@ public final class This implements java.io.Serializable, Runnable
         }
 
         // a default clone() method
-        if ( methodName.equals(""clone"") && args.length==0 ) {
+        if ( methodName.equals(""clone"") && args.length==0 )
             return cloneMethodImpl(callerInfo, callstack);
-        }
 
         // Look for a default invoke() handler method in the namespace
         boolean[] outHasMethod = new boolean[1];
         Object result = namespace.invokeDefaultInvokeMethod(methodName, args,
                 interpreter, callstack, callerInfo, outHasMethod);
-        if ( outHasMethod[0] )
-            return result;
+        if ( outHasMethod[0] ) return result;
 
         // Finally look for any command in this namespace that might qualify
         try {
             return namespace.invokeCommand(
                     methodName, args, interpreter, callstack, callerInfo, true);
-          } catch (EvalError e) {
+        } catch (EvalError e) {
              throw new EvalError(""Method "" +
                     StringUtil.methodString( methodName, types ) +
                     "" not found in bsh scripted object: ""+ namespace.getName(),
@@ -681,7 +674,8 @@ public final class This implements java.io.Serializable, Runnable
                 args = This.CONTEXT_ARGS.get().remove(instance.toString());
 
             // Find the constructor (now in the instance namespace)
-            BshMethod constructor = instanceNameSpace.getMethod(Types.getBaseName(className), Types.getTypes(args), true/*declaredOnly*/);
+            BshMethod constructor = instanceNameSpace.getMethod(
+                Types.getBaseName(className), Types.getTypes(args), true/*declaredOnly*/);
 
             // if args, we must have constructor
             if (args.length > 0 && constructor == null)
"
beanshell-beanshell-f345606a29bd,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: bsh.BshScriptTestCase#strings.bsh
Type: junit.framework.AssertionFailedError
Message: ""lkj""+""i"" == ""lk""+""ji"" is true Expected <TRUE> but was <FALSE> Line: 169 : assertTrue ( '""lkj""+""i"" == ""lk""+""ji"" is true' , ""lkj"" + ""i"" == ""lk"" + ""ji"" )  : while evaluating file: strings.bsh

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.beanshell-beanshell-f345606a29bd:msbench-0.0.1,"diff --git a/src/main/java/bsh/Operators.java b/src/main/java/bsh/Operators.java
index 53e943b..837d03e 100644
--- a/src/main/java/bsh/Operators.java
+++ b/src/main/java/bsh/Operators.java
@@ -67,8 +67,9 @@ class Operators implements ParserConstants {
         if ( kind == PLUS ) {
             // String concatenation operation
             if ( lhs instanceof String || rhs instanceof String )
-                return String.valueOf((Object) lhs)
-                     + String.valueOf((Object) rhs);
+                return BSHLiteral.internStrings
+                    ? (String.valueOf((Object) lhs) + String.valueOf((Object) rhs)).intern()
+                    : String.valueOf((Object) lhs) + String.valueOf((Object) rhs);
             // array concatenation operation
             if ( lhs.getClass().isArray() && rhs instanceof List )
                 rhs = ((List<?>) rhs).toArray();
"
bhlangonijr-chesslib-cf68677eac6d,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.github.bhlangonijr.chesslib.PgnIteratorTest#testPGNOrder
Type: java.lang.AssertionError
Message: expected:<WHITE_WON> but was:<ONGOING>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.bhlangonijr-chesslib-cf68677eac6d:msbench-0.0.1,"diff --git a/src/main/java/com/github/bhlangonijr/chesslib/pgn/GameLoader.java b/src/main/java/com/github/bhlangonijr/chesslib/pgn/GameLoader.java
index d0df22d..502e055 100644
--- a/src/main/java/com/github/bhlangonijr/chesslib/pgn/GameLoader.java
+++ b/src/main/java/com/github/bhlangonijr/chesslib/pgn/GameLoader.java
@@ -51,6 +51,10 @@ public class GameLoader {
      */
     public static Game loadNextGame(Iterator<String> iterator) {
 
+        if (!iterator.hasNext()) {
+            return null;
+        }
+
         PgnTempContainer container = new PgnTempContainer();
 
         while (iterator.hasNext()) {
@@ -65,10 +69,8 @@ public class GameLoader {
                 } else if (!line.equals("""") && container.moveText != null) {
                     addMoveText(line, container);
                     if (isEndGame(line)) {
-                        if (container.game != null) {
-                            setMoveText(container.game, container.moveText);
-                        }
-                        return container.game;
+                        setMoveText(container.game, container.moveText);
+                        return container.initGame ? container.game : null;
                     }
                 }
             } catch (Exception e) { //TODO stricter exceptions
@@ -77,7 +79,7 @@ public class GameLoader {
                 throw new PgnException(""Error parsing PGN["" + r + "", "" + name + ""]: "", e);
             }
         }
-        return container.game;
+        return container.initGame ? container.game : null;
     }
 
     private static void addProperty(String line, PgnTempContainer container) throws Exception {
@@ -85,11 +87,12 @@ public class GameLoader {
         if (property == null) {
             return;
         }
+        container.initGame = true;
         String tag = property.name.toLowerCase().trim();
         //begin
         switch (tag) {
             case ""event"":
-                if (container.moveTextParsing && container.game != null && container.game.getHalfMoves().size() == 0) {
+                if (container.moveTextParsing && container.game.getHalfMoves().size() == 0) {
                     setMoveText(container.game, container.moveText);
                 }
                 container.event.setName(property.value);
@@ -118,11 +121,9 @@ public class GameLoader {
                 if (container.round.getNumber() < 1) {
                     container.round.setNumber(1); //TODO this is just to have the same behaviour as before...
                 }
-                if (container.game == null) {
-                    container.game = GameFactory.newGame(UUID.randomUUID().toString(), container.round);
-                    container.game.setDate(container.event.getStartDate());
-                    container.round.getGame().add(container.game);
-                }
+
+                container.game.setDate(container.event.getStartDate()); //TODO this should be done only once
+
 
                 Player player = GameFactory.newPlayer(PlayerType.HUMAN, property.value);
                 player.setId(property.value);
@@ -137,11 +138,9 @@ public class GameLoader {
                 if (container.round.getNumber() < 1) {
                     container.round.setNumber(1); //TODO this just to have the same behaviour as before...
                 }
-                if (container.game == null) {
-                    container.game = GameFactory.newGame(UUID.randomUUID().toString(), container.round);
-                    container.game.setDate(container.event.getStartDate());
-                    container.round.getGame().add(container.game);
-                }
+
+                container.game.setDate(container.event.getStartDate()); //TODO this should be done only once
+
                 Player player = GameFactory.newPlayer(PlayerType.HUMAN, property.value);
                 player.setId(property.value);
                 player.setDescription(property.value);
@@ -151,23 +150,16 @@ public class GameLoader {
                 break;
             }
             case ""result"":
-                if (container.game != null) {
-                    GameResult result = GameResult.fromNotation(property.value);
-                    container.game.setResult(result);
-                }
+                container.game.setResult(GameResult.fromNotation(property.value));
                 break;
             case ""plycount"":
-                if (container.game != null) {
-                    container.game.setPlyCount(property.value);
-                }
+                container.game.setPlyCount(property.value);
                 break;
             case ""termination"":
-                if (container.game != null) {
-                    try {
-                        container.game.setTermination(Termination.fromValue(property.value.toUpperCase()));
-                    } catch (Exception e1) {
-                        container.game.setTermination(Termination.UNTERMINATED);
-                    }
+                try {
+                    container.game.setTermination(Termination.fromValue(property.value.toUpperCase()));
+                } catch (Exception e1) {
+                    container.game.setTermination(Termination.UNTERMINATED);
                 }
                 break;
             case ""timecontrol"":
@@ -180,29 +172,19 @@ public class GameLoader {
                 }
                 break;
             case ""annotator"":
-                if (container.game != null) {
-                    container.game.setAnnotator(property.value);
-                }
+                container.game.setAnnotator(property.value);
                 break;
             case ""fen"":
-                if (container.game != null) {
-                    container.game.setFen(property.value);
-                }
+                container.game.setFen(property.value);
                 break;
             case ""eco"":
-                if (container.game != null) {
-                    container.game.setEco(property.value);
-                }
+                container.game.setEco(property.value);
                 break;
             case ""opening"":
-                if (container.game != null) {
-                    container.game.setOpening(property.value);
-                }
+                container.game.setOpening(property.value);
                 break;
             case ""variation"":
-                if (container.game != null) {
-                    container.game.setVariation(property.value);
-                }
+                container.game.setVariation(property.value);
                 break;
             case ""whiteelo"":
                 if (container.whitePlayer != null) {
@@ -223,17 +205,16 @@ public class GameLoader {
                 }
                 break;
             default:
-                if (container.game != null) {
-                    if (container.game.getProperty() == null) {
-                        container.game.setProperty(new HashMap<String, String>());
-                    }
-                    container.game.getProperty().put(property.name, property.value);
+                if (container.game.getProperty() == null) {
+                    container.game.setProperty(new HashMap<>());
                 }
+                container.game.getProperty().put(property.name, property.value);
                 break;
         }
     }
 
     private static void addMoveText(String line, PgnTempContainer container) {
+        container.initGame = true;
         container.moveText.append(line);
         container.moveText.append('\n');
         container.moveTextParsing = true;
@@ -245,15 +226,21 @@ public class GameLoader {
 
     private static class PgnTempContainer {
 
-        Event event = new Event();
-        Round round = new Round(event);
+        Event event;
+        Round round;
         Game game;
         Player whitePlayer;
         Player blackPlayer;
         StringBuilder moveText;
         boolean moveTextParsing;
+        boolean initGame;
 
-        PgnTempContainer() {}
+        PgnTempContainer() {
+            this.event = new Event();
+            this.round = new Round(event);
+            this.game = new Game(UUID.randomUUID().toString(), round);
+            this.round.getGame().add(this.game);
+        }
     }
 
     private static void setMoveText(Game game, StringBuilder moveText) throws Exception {
"
c-rack-cbor-java-cabd70d02e86,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: co.nstant.in.cbor.model.SpecialTypeTest#shouldDetectUnallocated28
Type: java.lang.AssertionError
Message: Expected exception: co.nstant.in.cbor.CborException

Test: co.nstant.in.cbor.model.SpecialTypeTest#shouldDetectUnallocated29
Type: java.lang.AssertionError
Message: Expected exception: co.nstant.in.cbor.CborException

Test: co.nstant.in.cbor.model.SpecialTypeTest#shouldDetectUnallocated30
Type: java.lang.AssertionError
Message: Expected exception: co.nstant.in.cbor.CborException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.c-rack-cbor-java-cabd70d02e86:msbench-0.0.1,"diff --git a/src/main/java/co/nstant/in/cbor/decoder/SpecialDecoder.java b/src/main/java/co/nstant/in/cbor/decoder/SpecialDecoder.java
index bab71e7..7ca4bf1 100644
--- a/src/main/java/co/nstant/in/cbor/decoder/SpecialDecoder.java
+++ b/src/main/java/co/nstant/in/cbor/decoder/SpecialDecoder.java
@@ -51,7 +51,6 @@ public class SpecialDecoder extends AbstractDecoder<Special> {
             return doublePrecisionFloatDecoder.decode(initialByte);
         case SIMPLE_VALUE_NEXT_BYTE:
             return new SimpleValue(nextSymbol());
-        case UNALLOCATED:
         default:
             throw new CborException(""Not implemented"");
         }
diff --git a/src/main/java/co/nstant/in/cbor/encoder/SpecialEncoder.java b/src/main/java/co/nstant/in/cbor/encoder/SpecialEncoder.java
index 8fa3f0c..1bed2b5 100644
--- a/src/main/java/co/nstant/in/cbor/encoder/SpecialEncoder.java
+++ b/src/main/java/co/nstant/in/cbor/encoder/SpecialEncoder.java
@@ -25,7 +25,7 @@ public class SpecialEncoder extends AbstractEncoder<Special> {
     }
 
     @Override
-    public void encode(Special dataItem) throws CborException {
+    public void encode(Special dataItem)  throws CborException{
         switch (dataItem.getSpecialType()) {
         case BREAK:
             write((7 << 5) | 31);
@@ -47,8 +47,6 @@ public class SpecialEncoder extends AbstractEncoder<Special> {
                 break;
             }
             break;
-        case UNALLOCATED:
-            throw new CborException(""Unallocated special type"");
         case IEEE_754_HALF_PRECISION_FLOAT:
             halfPrecisionFloatEncoder.encode((HalfPrecisionFloat) dataItem);
             break;
@@ -62,6 +60,8 @@ public class SpecialEncoder extends AbstractEncoder<Special> {
             SimpleValue simpleValueNextByte = (SimpleValue) dataItem;
             write((byte) ((7 << 5) | 24), (byte) simpleValueNextByte.getValue());
             break;
+        default:
+            throw new AssertionError(""Unknown special value type"");
         }
     }
 
diff --git a/src/main/java/co/nstant/in/cbor/model/SpecialType.java b/src/main/java/co/nstant/in/cbor/model/SpecialType.java
index 2a96fb3..5f4c8c1 100644
--- a/src/main/java/co/nstant/in/cbor/model/SpecialType.java
+++ b/src/main/java/co/nstant/in/cbor/model/SpecialType.java
@@ -1,11 +1,13 @@
 package co.nstant.in.cbor.model;
 
+import co.nstant.in.cbor.CborException;
+
 public enum SpecialType {
 
     SIMPLE_VALUE, SIMPLE_VALUE_NEXT_BYTE, IEEE_754_HALF_PRECISION_FLOAT, IEEE_754_SINGLE_PRECISION_FLOAT,
-    IEEE_754_DOUBLE_PRECISION_FLOAT, UNALLOCATED, BREAK;
+    IEEE_754_DOUBLE_PRECISION_FLOAT, BREAK;
 
-    public static SpecialType ofByte(int b) {
+    public static SpecialType ofByte(int b) throws CborException {
         switch (b & 31) {
         case 24:
             return SIMPLE_VALUE_NEXT_BYTE;
@@ -18,7 +20,7 @@ public enum SpecialType {
         case 28:
         case 29:
         case 30:
-            return UNALLOCATED;
+            throw new CborException(""Not implemented special type "" + b);
         case 31:
             return BREAK;
         default:
"
cdimascio-dotenv-java-bbfbcfa63e3a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: tests.BasicTests#dotenvIgnoreMalformed
Type: org.junit.ComparisonFailure
Message: expected:<[iH4>hb_d0#_GN8d]6]> but was:<[""iH4>hb_d0]>

Test: tests.BasicTests#dotenvFilename
Type: org.junit.ComparisonFailure
Message: expected:<[iH4>hb_d0#_GN8d]6]> but was:<[""iH4>hb_d0]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.cdimascio-dotenv-java-bbfbcfa63e3a:msbench-0.0.1,"diff --git a/src/main/java/io/github/cdimascio/dotenv/internal/DotenvParser.java b/src/main/java/io/github/cdimascio/dotenv/internal/DotenvParser.java
index 30616e3..97b8d00 100644
--- a/src/main/java/io/github/cdimascio/dotenv/internal/DotenvParser.java
+++ b/src/main/java/io/github/cdimascio/dotenv/internal/DotenvParser.java
@@ -19,7 +19,17 @@ import static java.util.Collections.emptyList;
 public class DotenvParser {
 
     private static final Pattern WHITE_SPACE_REGEX = Pattern.compile(""^\\s*$""); // ^\s*${'$'}
-    private static final Pattern DOTENV_ENTRY_REGEX = Pattern.compile(""^\\s*([\\w.\\-]+)\\s*(=)\\s*([^#]*)?\\s*(#.*)?$""); // ^\s*([\w.\-]+)\s*(=)\s*([^#]*)?\s*(#.*)?$
+
+    // The follow regex matches key values.
+    // It supports quoted values surrounded by single or double quotes
+    // -  Single quotes: ['][^']*[']
+    //    The above regex snippet matches a value wrapped in single quotes.
+    //    The regex snippet does not match internal single quotes. This is present to allow the trailing comment to include single quotes
+    // -  Double quotes: same logic as single quotes
+    // It ignore trailing comments
+    // - Trailing comment: \s*(#.*)?$
+    //   The above snippet ignore spaces, the captures the # and the trailing comment
+    private static final Pattern DOTENV_ENTRY_REGEX = Pattern.compile(""^\\s*([\\w.\\-]+)\\s*(=)\\s*(['][^']*[']|[\""][^\""]*[\""]|[^#]*)?\\s*(#.*)?$""); //""^\\s*([\\w.\\-]+)\\s*(=)\\s*([^#]*)?\\s*(#.*)?$""); // ^\s*([\w.\-]+)\s*(=)\s*([^#]*)?\s*(#.*)?$
 
     private final DotenvReader reader;
     private final boolean throwIfMissing;
"
cloudsimplus-cloudsimplus-61c8b942d1ec,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.cloudsimplus.integrationtests.VmCreationFailureIntegrationTest#integrationTest
Type: org.opentest4j.AssertionFailedError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.cloudsimplus-cloudsimplus-61c8b942d1ec:msbench-0.0.1,"diff --git a/src/main/java/org/cloudsimplus/hosts/HostAbstract.java b/src/main/java/org/cloudsimplus/hosts/HostAbstract.java
index 19dfe5d..70d7fea 100644
--- a/src/main/java/org/cloudsimplus/hosts/HostAbstract.java
+++ b/src/main/java/org/cloudsimplus/hosts/HostAbstract.java
@@ -162,7 +162,7 @@ public abstract class HostAbstract extends ExecDelayableAbstract implements Host
     }
 
     public HostAbstract(final List<Pe> peList, final boolean activate) {
-        this(defaultBwCapacity, defaultStorageCapacity, new HarddriveStorage(defaultRamCapacity), peList, activate);
+        this(defaultRamCapacity, defaultBwCapacity, new HarddriveStorage(defaultStorageCapacity), peList, activate);
     }
 
     protected HostAbstract(
"
crawler-commons-crawler-commons-2c2cb3bf7a95,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: crawlercommons.robots.SimpleRobotRulesParserTest#testUnicodeUnescapedPaths
Type: org.opentest4j.AssertionFailedError
Message: expected: <false> but was: <true>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.crawler-commons-crawler-commons-2c2cb3bf7a95:msbench-0.0.1,"diff --git a/src/main/java/crawlercommons/robots/SimpleRobotRulesParser.java b/src/main/java/crawlercommons/robots/SimpleRobotRulesParser.java
index c22461c..f7d33d7 100644
--- a/src/main/java/crawlercommons/robots/SimpleRobotRulesParser.java
+++ b/src/main/java/crawlercommons/robots/SimpleRobotRulesParser.java
@@ -492,7 +492,17 @@ public class SimpleRobotRulesParser extends BaseRobotsParser {
 
         int bytesLen = content.length;
         int offset = 0;
-        Charset encoding = StandardCharsets.US_ASCII;
+
+        /*
+         * RFC 9309 requires that is ""UTF-8 encoded"" (<a href=
+         * ""https://www.rfc-editor.org/rfc/rfc9309.html#name-access-method""> RFC
+         * 9309, section 2.3 Access Method</a>), but
+         * ""Implementors MAY bridge encoding mismatches if they detect that the robots.txt file is not UTF-8 encoded.""
+         * (<a href=
+         * ""https://www.rfc-editor.org/rfc/rfc9309.html#name-the-allow-and-disallow-line""
+         * > RFC 9309, section 2.2.2. The ""Allow"" and ""Disallow"" Lines</a>)
+         */
+        Charset encoding = StandardCharsets.UTF_8;
 
         // Check for a UTF-8 BOM at the beginning (EF BB BF)
         if ((bytesLen >= 3) && (content[0] == (byte) 0xEF) && (content[1] == (byte) 0xBB) && (content[2] == (byte) 0xBF)) {
"
crowdin-crowdin-api-client-java-f0f22b2b56d7,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.crowdin.client.screenshots.ScreenshotsApiTest#updateScreenshotTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Mon Sep 23 09:35:31 GMT 2019> but was: <Mon Sep 23 09:00:31 GMT 2019>

Test: com.crowdin.client.bundles.BundlesApiTest#downloadBundleTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Fri Sep 20 10:31:21 GMT 2019> but was: <Fri Sep 20 10:00:21 GMT 2019>

Test: com.crowdin.client.sourcefiles.SourceFilesApiTest#getDirectoryTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Thu Sep 19 14:14:00 GMT 2019> but was: <Thu Sep 19 14:00:00 GMT 2019>

Test: com.crowdin.client.reports.ReportsApiTest#generateReportTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Mon Sep 23 11:26:54 GMT 2019> but was: <Mon Sep 23 11:00:54 GMT 2019>

Test: com.crowdin.client.tasks.TasksApiTest#getTaskTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Mon Sep 23 09:04:29 GMT 2019> but was: <Mon Sep 23 09:00:29 GMT 2019>

Test: com.crowdin.client.glossaries.GlossariesApiTest#getConceptTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Mon Sep 23 07:19:47 GMT 2019> but was: <Mon Sep 23 07:00:47 GMT 2019>

Test: com.crowdin.client.glossaries.GlossariesApiTest#listTermsTest()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Mon Sep 23 07:19:47 GMT 2019> but was: <Mon Sep 23 07:00:47 GMT 2019>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.crowdin-crowdin-api-client-java-f0f22b2b56d7:msbench-0.0.1,"diff --git a/src/main/java/com/crowdin/client/core/http/impl/json/JacksonJsonTransformer.java b/src/main/java/com/crowdin/client/core/http/impl/json/JacksonJsonTransformer.java
index 1c925dd..648afaa 100644
--- a/src/main/java/com/crowdin/client/core/http/impl/json/JacksonJsonTransformer.java
+++ b/src/main/java/com/crowdin/client/core/http/impl/json/JacksonJsonTransformer.java
@@ -44,7 +44,7 @@ public class JacksonJsonTransformer implements JsonTransformer {
             .addDeserializer(LanguageTranslations.class, new LanguageTranslationsDeserializer(cleanObjectMapper));
         this.objectMapper = cleanObjectMapper.copy()
                 .setSerializationInclusion(JsonInclude.Include.NON_NULL)
-                .setDateFormat(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss+hh:mm""))
+                .setDateFormat(new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX""))
                 .registerModule(module)
                 .setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE)
                 .setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
"
damianszczepanik-cucumber-reporting-f11e9867941b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: net.masterthought.cucumber.generators.FeatureReportPageTest#prepareReport_AddsCustomProperties
Type: java.lang.AssertionError
Message: 
Expected size: 15 but was: 14 in:
[""build_time"",
    ""run_with_jenkins"",
    ""counter"",
    ""css_files"",
    ""stepNameFormatter"",
    ""expand_all_steps"",
    ""directory_suffix"",
    ""util"",
    ""feature"",
    ""js_files"",
    ""hide_empty_hooks"",
    ""build_number"",
    ""build_project_name"",
    ""trends_available""]

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.damianszczepanik-cucumber-reporting-f11e9867941b:msbench-0.0.1,"diff --git a/src/main/java/net/masterthought/cucumber/generators/FeatureReportPage.java b/src/main/java/net/masterthought/cucumber/generators/FeatureReportPage.java
index d445a47..208afe9 100644
--- a/src/main/java/net/masterthought/cucumber/generators/FeatureReportPage.java
+++ b/src/main/java/net/masterthought/cucumber/generators/FeatureReportPage.java
@@ -3,6 +3,7 @@ package net.masterthought.cucumber.generators;
 import net.masterthought.cucumber.Configuration;
 import net.masterthought.cucumber.ReportResult;
 import net.masterthought.cucumber.json.Feature;
+import net.masterthought.cucumber.presentation.PresentationMode;
 
 public class FeatureReportPage extends AbstractPage {
 
@@ -21,6 +22,7 @@ public class FeatureReportPage extends AbstractPage {
     @Override
     public void prepareReport() {
         context.put(""feature"", feature);
+        context.put(""parallel_testing"", configuration.containsPresentationMode(PresentationMode.PARALLEL_TESTING));
     }
 
 }
"
davidmoten-openapi-to-plantuml-773340861981,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/additional-properties-complex.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/additional-properties-simple.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/all-of-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/all-of-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/anon-nested-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/anon-property-not-required.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/anon-property-required.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/any-of-anon-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/any-of-anon-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/any-of-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/any-of-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/array-anon-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/array-anon-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/array-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/array-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/empty.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/enum.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/external-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/one-of-class-level-empty.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/one-of-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/one-of-property-level-required.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/one-of-property-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/parameter-anon-empty-object.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/parameter-anon.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/parameter-ref-complex.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/parameter-ref-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/parameter-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/path-returns-non-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/path-returns-ref-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/path-returns-ref-ref2.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/path-returns-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/petstore-expanded.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/petstore.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/ref-class-level.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/request-body-ref-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/request-body-ref.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/request-body.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/simple-has-refs.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Test: com.github.davidmoten.oas3.puml.ConverterBatchTest#test[src/test/resources/inputs/simple-types-and-arrays.yml]
Type: org.junit.ComparisonFailure
Message: expected:<...Color<<Path>> Wheat
[]}
set namespaceSepar...> but was:<...Color<<Path>> Wheat
[BorderColor<<Path>> Tomato]}
set namespaceSepar...>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.davidmoten-openapi-to-plantuml-773340861981:msbench-0.0.1,"diff --git a/src/main/java/com/github/davidmoten/oas3/puml/Converter.java b/src/main/java/com/github/davidmoten/oas3/puml/Converter.java
index fcc6d19..8b36859 100644
--- a/src/main/java/com/github/davidmoten/oas3/puml/Converter.java
+++ b/src/main/java/com/github/davidmoten/oas3/puml/Converter.java
@@ -125,8 +125,7 @@ public final class Converter {
                 + ""\nhide empty fields"" //
                 + ""\nskinparam class {""
                 + ""\nBackgroundColor<<Path>> Wheat""
-                + ""\nBorderColor<<Path>> Tomato""
-                + ""}""
+                + ""\n}""
                 // make sure that periods in class names aren't interpreted as namespace
                 // separators (which results in recursive boxing)
                 + ""\nset namespaceSeparator none"" //
"
davidmoten-word-wrap-e59eedf0bac7,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.davidmoten.text.utils.WordWrapTest#testStatelessness
Type: org.junit.ComparisonFailure
Message: expected:<hello[ super- ]cool> but was:<hello[ super-]cool>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.davidmoten-word-wrap-e59eedf0bac7:msbench-0.0.1,"diff --git a/src/main/java/org/davidmoten/text/utils/WordWrap.java b/src/main/java/org/davidmoten/text/utils/WordWrap.java
index ceca282..b96ffee 100644
--- a/src/main/java/org/davidmoten/text/utils/WordWrap.java
+++ b/src/main/java/org/davidmoten/text/utils/WordWrap.java
@@ -229,6 +229,7 @@ public final class WordWrap {
          * @return this
          */
         public Builder includeExtraWordChars(String includeWordChars) {
+            copyOnWriteDefaultWordCharset();
             Set<Character> set = toSet(includeWordChars);
             this.extraWordChars.addAll(set);
             return this;
@@ -242,12 +243,22 @@ public final class WordWrap {
          * @return this
          */
         public Builder excludeExtraWordChars(String excludeWordChars) {
+            copyOnWriteDefaultWordCharset();
             Set<Character> set = toSet(excludeWordChars);
             this.extraWordChars.removeAll(set);
             return this;
         }
 
         /**
+         * Create a copy of extraWordChars in case it refers to SPECIAL_WORD_CHARS_SET_DEFAULT.
+         */
+        private void copyOnWriteDefaultWordCharset() {
+            if (this.extraWordChars == SPECIAL_WORD_CHARS_SET_DEFAULT) {
+                this.extraWordChars = new HashSet<>(SPECIAL_WORD_CHARS_SET_DEFAULT);
+            }
+        }
+
+        /**
          * Sets if to break words using a hyphen character. If set to false then no
          * breaking character will be used.
          * 
"
dmak-jaxb-xew-plugin-f48935133d6a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.sun.tools.xjc.addon.xew.XmlElementWrapperPluginTest#testInnerScopedElement
Type: org.assertj.core.error.AssertJMultipleFailuresError
Message: 
Multiple Failures (2 failures)
-- failure 1 --
[For Catalogue.java in src/test/generated_resources/inner_scoped_element] 
Path:
  target/test/generated_xsd_classes/inner_scoped_element/Catalogue.java
and path:
  src/test/generated_resources/inner_scoped_element/Catalogue.java
do not have same content:

Changed content at line 76:
expecting:
  [""    protected List<Catalogue.StockageStockage> stockage = new ArrayList<Catalogue.StockageStockage>();""]
but was:
  [""    protected List<Catalogue.Stockage> stockage = new ArrayList<Catalogue.Stockage>();""]

Changed content at line 78:
expecting:
  [""    public List<Catalogue.StockageStockage> getStockage() {""]
but was:
  [""    public List<Catalogue.Stockage> getStockage() {""]

Changed content at line 82:
expecting:
  [""    public void setStockage(List<Catalogue.StockageStockage> stockage) {""]
but was:
  [""    public void setStockage(List<Catalogue.Stockage> stockage) {""]

Changed content at line 121:
expecting:
  [""    public static class StockageStockage {""]
but was:
  [""    public static class Stockage {""]
at XmlElementWrapperPluginTest.runTest(XmlElementWrapperPluginTest.java:366)
-- failure 2 --
[For ObjectFactory.java in src/test/generated_resources/inner_scoped_element] 
Path:
  target/test/generated_xsd_classes/inner_scoped_element/ObjectFactory.java
and path:
  src/test/generated_resources/inner_scoped_element/ObjectFactory.java
do not have same content:

Changed content at line 46:
expecting:
  [""     * Create an instance of {@link Catalogue.StockageStockage }""]
but was:
  [""     * Create an instance of {@link Catalogue.Stockage }""]

Changed content at line 49:
expecting:
  [""    public Catalogue.StockageStockage createCatalogueStockageStockage() {"",
   ""        return new Catalogue.StockageStockage();""]
but was:
  [""    public Catalogue.Stockage createCatalogueStockage() {"",
   ""        return new Catalogue.Stockage();""]

Changed content at line 53:
expecting:
  [""    @XmlElementDecl(namespace = """", name = ""effect"", scope = Catalogue.StockageStockage.class)"",
   ""    public JAXBElement<String> createCatalogueStockageStockageEffect(String value) {"",
   ""        return new JAXBElement<String>(new QName("""", ""effect""), String.class, Catalogue.StockageStockage.class, value);""]
but was:
  [""    @XmlElementDecl(namespace = """", name = ""effect"", scope = Catalogue.Stockage.class)"",
   ""    public JAXBElement<String> createCatalogueStockageEffect(String value) {"",
   ""        return new JAXBElement<String>(new QName("""", ""effect""), String.class, Catalogue.Stockage.class, value);""]

Changed content at line 58:
expecting:
  [""    @XmlElementDecl(namespace = """", name = ""term"", scope = Catalogue.StockageStockage.class)"",
   ""    public JAXBElement<String> createCatalogueStockageStockageTerm(String value) {"",
   ""        return new JAXBElement<String>(new QName("""", ""term""), String.class, Catalogue.StockageStockage.class, value);""]
but was:
  [""    @XmlElementDecl(namespace = """", name = ""term"", scope = Catalogue.Stockage.class)"",
   ""    public JAXBElement<String> createCatalogueStockageTerm(String value) {"",
   ""        return new JAXBElement<String>(new QName("""", ""term""), String.class, Catalogue.Stockage.class, value);""]
at XmlElementWrapperPluginTest.runTest(XmlElementWrapperPluginTest.java:366)

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.dmak-jaxb-xew-plugin-f48935133d6a:msbench-0.0.1,"diff --git a/src/main/java/com/sun/tools/xjc/addon/xew/XmlElementWrapperPlugin.java b/src/main/java/com/sun/tools/xjc/addon/xew/XmlElementWrapperPlugin.java
index f8e9fcc..8131336 100644
--- a/src/main/java/com/sun/tools/xjc/addon/xew/XmlElementWrapperPlugin.java
+++ b/src/main/java/com/sun/tools/xjc/addon/xew/XmlElementWrapperPlugin.java
@@ -904,12 +904,18 @@ public class XmlElementWrapperPlugin extends AbstractConfigurablePlugin {
 			}
 		}
 
-		if (classes.containsKey(clazz.name())) {
-			writeSummary(""\tRenaming class "" + clazz.fullName() + "" to class "" + parent.name() + clazz.name());
-			setPrivateField(clazz, ""name"", parent.name() + clazz.name());
+		// Rename the class in case there is class name collision.
+		// FIXME: Should that be doublechecked after renaming?
+		if (classes.containsKey(clazz.name()) || classes.containsKey(clazz.name().toUpperCase())) {
+			String newName = parent.name() + clazz.name();
+			writeSummary(""\tRenaming class "" + clazz.fullName() + "" to class "" + newName);
+			setPrivateField(clazz, ""name"", newName);
 		}
 
-		classes.put(clazz.name(), clazz);
+		// Special treatment for the case when ""classes"" map holds class names in upper case
+		// (true for case-sensitive filesystems, see usages of JCodeModel.isCaseSensitiveFileSystem):
+		boolean allClassNamesInUpperCase = classes.keySet().stream().allMatch(key -> key.equals(key.toUpperCase()));
+		classes.put(allClassNamesInUpperCase ? clazz.name().toUpperCase() : clazz.name(), clazz);
 
 		// Finally modify the class so that it refers back the container:
 		setPrivateField(clazz, ""outer"", grandParent);
"
fusesource-jansi-58260c6ce08c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.fusesource.jansi.AnsiRendererTest#testRenderInvalidEndBeforeStart
Type: org.opentest4j.AssertionFailedError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.fusesource-jansi-58260c6ce08c:msbench-0.0.1,"diff --git a/src/main/java/org/fusesource/jansi/AnsiRenderer.java b/src/main/java/org/fusesource/jansi/AnsiRenderer.java
index 20b1c17..5041c4e 100644
--- a/src/main/java/org/fusesource/jansi/AnsiRenderer.java
+++ b/src/main/java/org/fusesource/jansi/AnsiRenderer.java
@@ -99,6 +99,11 @@ public class AnsiRenderer {
                 return target;
             }
             j += BEGIN_TOKEN_LEN;
+
+            // Check for invalid string with END_TOKEN before BEGIN_TOKEN
+            if (k < j) {
+                throw new IllegalArgumentException(""Invalid input string found."");
+            }
             String spec = input.substring(j, k);
 
             String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);
"
giraud-reasonml-idea-plugin-f665f0fc21e6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.reason.lang.rescript.ModuleParsingTest#test_interface_with_constraints
Type: junit.framework.ComparisonFailure
Message: junit.framework.ComparisonFailure: expected:<type t = X.t[]> but was:<type t = X.t[ = {}]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.giraud-reasonml-idea-plugin-f665f0fc21e6:msbench-0.0.1,"diff --git a/src/main/java/com/reason/lang/rescript/ResParser.java b/src/main/java/com/reason/lang/rescript/ResParser.java
index e3cea2d..e97768e 100644
--- a/src/main/java/com/reason/lang/rescript/ResParser.java
+++ b/src/main/java/com/reason/lang/rescript/ResParser.java
@@ -1073,7 +1073,8 @@ public class ResParser extends CommonPsiParser {
         private void parseEq() {
             if (strictlyInAny(
                     myTypes.C_TYPE_DECLARATION, myTypes.C_LET_DECLARATION, myTypes.C_MODULE_TYPE, myTypes.C_MODULE_DECLARATION,
-                    myTypes.C_TAG_PROPERTY, myTypes.C_SIG_EXPR, myTypes.H_NAMED_PARAM_DECLARATION, myTypes.C_NAMED_PARAM
+                    myTypes.C_TAG_PROPERTY, myTypes.C_SIG_EXPR, myTypes.H_NAMED_PARAM_DECLARATION, myTypes.C_NAMED_PARAM,
+                    myTypes.C_TYPE_CONSTRAINT, myTypes.C_TYPE_BINDING
             )) {
 
                 if (isFound(myTypes.C_TYPE_DECLARATION)) {
@@ -1115,8 +1116,17 @@ public class ResParser extends CommonPsiParser {
                     popEndUntilFoundIndex()
                             .advance().mark(myTypes.C_DEFAULT_VALUE)
                             .markHolder(myTypes.H_PLACE_HOLDER);
+                } else if (isFound(myTypes.C_TYPE_CONSTRAINT)) {
+                    // ... with type t |> =<| ...
+                    advance().mark(myTypes.C_TYPE_BINDING);
+                } else if (isFound(myTypes.C_TYPE_BINDING) && strictlyIn(myTypes.C_CONSTRAINTS)) {
+                    // .. with type .. = .. |> =<| ..
+                    popEndUntilFoundIndex().popEnd();
+                    if (strictlyIn(myTypes.C_MODULE_DECLARATION)) {
+                        popEndUntilFoundIndex()
+                                .advance().mark(myTypes.C_MODULE_BINDING);
+                    }
                 }
-
             }
         }
 
@@ -1179,8 +1189,8 @@ public class ResParser extends CommonPsiParser {
                             .mark(myTypes.C_PARAM_DECLARATION);
                 }
             } else if (is(myTypes.C_TYPE_DECLARATION)) {
-              // type |>M<|.t += ...
-              remapCurrentToken(myTypes.A_MODULE_NAME).wrapAtom(myTypes.CA_UPPER_SYMBOL);
+                // type |>M<|.t += ...
+                remapCurrentToken(myTypes.A_MODULE_NAME).wrapAtom(myTypes.CA_UPPER_SYMBOL);
             } else if (is(myTypes.C_TYPE_BINDING)) {
                 IElementType nextToken = lookAhead(1);
                 if (nextToken == myTypes.DOT) { // a path
"
giraud-reasonml-idea-plugin-69749af01bcf,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.reason.lang.ocaml.LetParsingTest#test_GH_409
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException: Cannot invoke ""com.reason.lang.core.psi.impl.RPsiBinaryCondition.getText()"" because the return value of ""com.intellij.psi.util.PsiTreeUtil.getChildOfType(com.intellij.psi.PsiElement, java.lang.Class)"" is null

Test: com.reason.lang.ocaml.LetParsingTest#test_GH_409a
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException: Cannot invoke ""com.reason.lang.core.psi.impl.RPsiBinaryCondition.getText()"" because the return value of ""com.intellij.psi.util.PsiTreeUtil.getChildOfType(com.intellij.psi.PsiElement, java.lang.Class)"" is null

Test: com.reason.lang.ocaml.LetParsingTest#test_GH_409_binary_condition
Type: junit.framework.ComparisonFailure
Message: junit.framework.ComparisonFailure: expected:<ignore """"[ = ()]> but was:<ignore """"[]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.giraud-reasonml-idea-plugin-69749af01bcf:msbench-0.0.1,"diff --git a/src/main/java/com/reason/lang/ocaml/OclParser.java b/src/main/java/com/reason/lang/ocaml/OclParser.java
index 3b8cd97..88c58ba 100644
--- a/src/main/java/com/reason/lang/ocaml/OclParser.java
+++ b/src/main/java/com/reason/lang/ocaml/OclParser.java
@@ -1,8 +1,6 @@
 package com.reason.lang.ocaml;
 
 import com.intellij.lang.*;
-import com.intellij.openapi.project.*;
-import com.intellij.psi.*;
 import com.intellij.psi.tree.*;
 import com.reason.lang.*;
 import com.reason.lang.core.type.*;
@@ -15,16 +13,6 @@ public class OclParser extends CommonPsiParser {
         super(isSafe);
     }
 
-    public static ASTNode parseOcamlNode(@NotNull ILazyParseableElementType root, @NotNull ASTNode chameleon) {
-        PsiElement parentElement = chameleon.getTreeParent().getPsi();
-        Project project = parentElement.getProject();
-
-        PsiBuilder builder = PsiBuilderFactory.getInstance().createBuilder(project, chameleon, new OclLexer(), root.getLanguage(), chameleon.getChars());
-        OclParser parser = new OclParser(true);
-
-        return parser.parse(root, builder).getFirstChildNode();
-    }
-
     @Override
     protected ORParser<OclTypes> getORParser(@NotNull PsiBuilder builder) {
         return new OclParserState(builder, myIsSafe);
@@ -344,8 +332,6 @@ public class OclParser extends CommonPsiParser {
                     popEndUntil(myTypes.C_OBJECT);
                     advance().end();
                     popEnd();
-                } else {
-                    //
                 }
             }
         }
@@ -753,6 +739,7 @@ public class OclParser extends CommonPsiParser {
             }
         }
 
+        @SuppressWarnings(""StatementWithEmptyBody"")
         private void parseEq() {
             if (in(myTypes.H_NAMED_PARAM_DECLARATION) && isFoundScope(myTypes.LPAREN)) {
                 // let fn ?(x |> = <| ...
@@ -774,12 +761,23 @@ public class OclParser extends CommonPsiParser {
                 popEndUntil(myTypes.C_SIG_EXPR).popEnd().advance();
             } else if (strictlyInAny(myTypes.C_LET_DECLARATION, myTypes.C_MODULE_DECLARATION)) {
                 // if inside a let binding, do nothing
-                if (isFound(myTypes.C_LET_DECLARATION) && !isCurrent(myTypes.C_LET_BINDING)) {
+                if (isFound(myTypes.C_LET_DECLARATION)) {
                     int letPos = getIndex();
-                    if (in(myTypes.C_LET_BINDING, null, letPos, false)) {
-                        // in a function ::  let (x) y z |> = <| ...
-                        popEndUntil(myTypes.C_FUNCTION_EXPR).advance()
-                                .mark(myTypes.C_FUNCTION_BODY);
+                    if (isCurrent(myTypes.C_LET_BINDING) && is(myTypes.H_PLACE_HOLDER)) {
+                        // inside a let binding, it might be a binary condition
+                        updateLatestComposite(myTypes.C_BINARY_CONDITION);
+                        markHolderBefore(0, myTypes.H_PLACE_HOLDER);
+                    } else if (in(myTypes.C_LET_BINDING, null, letPos, false)) {
+                        int letBinding = getIndex();
+                        if (in(myTypes.C_FUNCTION_EXPR, null, letBinding, false)) {
+                            // in a function ::  let (x) y z |> = <| ...
+                            popEndUntil(myTypes.C_FUNCTION_EXPR).advance()
+                                    .mark(myTypes.C_FUNCTION_BODY);
+                        } else {
+                            // inside a let binding, but not a function expression. it might be a binary condition
+                            markBefore(letBinding - 1, myTypes.C_BINARY_CONDITION).
+                                    popEndUntil(myTypes.C_BINARY_CONDITION);
+                        }
                     } else {
                         // let x |> = <| ...
                         popEndUntilIndex(letPos).advance().
@@ -1265,6 +1263,7 @@ public class OclParser extends CommonPsiParser {
             mark(myTypes.C_EXTERNAL_DECLARATION);
         }
 
+        @SuppressWarnings(""StatementWithEmptyBody"")
         private void parseType() {
             if (is(myTypes.C_MODULE_DECLARATION)) {
                 // module |>type<| M = ...
"
giraud-reasonml-idea-plugin-11d991db162a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.reason.ide.structure.StructureOCLTest#test_GH_429
Type: junit.framework.ComparisonFailure
Message: junit.framework.ComparisonFailure: Incorrect name expected:<[t]> but was:<[Unknown presentation for element sig
    type t
end]>

Test: com.reason.lang.ocaml.ModuleParsingTest#test_rec_signature
Type: junit.framework.AssertionFailedError
Message: junit.framework.AssertionFailedError: Expected: <null> but was: RPsiSignature

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.giraud-reasonml-idea-plugin-11d991db162a:msbench-0.0.1,"diff --git a/src/main/java/com/reason/ide/structure/StructureViewElement.java b/src/main/java/com/reason/ide/structure/StructureViewElement.java
index 9ad2ec7..72d20b1 100644
--- a/src/main/java/com/reason/ide/structure/StructureViewElement.java
+++ b/src/main/java/com/reason/ide/structure/StructureViewElement.java
@@ -85,9 +85,8 @@ public class StructureViewElement implements StructureViewTreeElement, SortableT
                     return m_viewElement.getText();
                 }
 
-                @Nullable
                 @Override
-                public String getLocationString() {
+                public @Nullable String getLocationString() {
                     if (myElement instanceof RPsiLet && ((RPsiLet) myElement).isDeconstruction()) {
                         return """";
                     }
@@ -96,9 +95,8 @@ public class StructureViewElement implements StructureViewTreeElement, SortableT
                             : """";
                 }
 
-                @Nullable
                 @Override
-                public Icon getIcon(boolean unused) {
+                public @Nullable Icon getIcon(boolean unused) {
                     return PsiIconUtil.getProvidersIcon(myElement, 0);
                 }
             };
@@ -177,7 +175,14 @@ public class StructureViewElement implements StructureViewTreeElement, SortableT
 
         RPsiModuleSignature moduleSignature = moduleElement.getModuleSignature();
         if (moduleSignature != null) {
-            treeElements.add(new StructureViewElement(moduleSignature, myLevel + 1));
+            RPsiUpperSymbol nameIdentifier = moduleSignature.getNameIdentifier();
+            if (nameIdentifier != null) {
+                // module type of ...
+                treeElements.add(new StructureViewElement(moduleSignature, myLevel + 1));
+            } else {
+                // sig ... end
+                moduleSignature.acceptChildren(new ElementVisitor(treeElements, myLevel));
+            }
         }
 
         if (moduleSignature == null) {
diff --git a/src/main/java/com/reason/lang/core/psi/impl/RPsiModuleSignature.java b/src/main/java/com/reason/lang/core/psi/impl/RPsiModuleSignature.java
index d7d175a..212d153 100644
--- a/src/main/java/com/reason/lang/core/psi/impl/RPsiModuleSignature.java
+++ b/src/main/java/com/reason/lang/core/psi/impl/RPsiModuleSignature.java
@@ -20,7 +20,6 @@ public class RPsiModuleSignature extends ORCompositePsiElement<ORLangTypes> impl
     @Override
     public String @Nullable [] getPath() {
         return ORUtil.getQualifiedPath(this);
-
     }
 
     public @Nullable RPsiUpperSymbol getNameIdentifier() {
diff --git a/src/main/java/com/reason/lang/ocaml/OclParser.java b/src/main/java/com/reason/lang/ocaml/OclParser.java
index 7e98b2d..8642e0b 100644
--- a/src/main/java/com/reason/lang/ocaml/OclParser.java
+++ b/src/main/java/com/reason/lang/ocaml/OclParser.java
@@ -557,6 +557,9 @@ public class OclParser extends CommonPsiParser {
             if (is(myTypes.C_MODULE_BINDING)) { // This is the body of a module type
                 // module type X = |>sig<| ...
                 updateScopeToken(myTypes.SIG);
+            } else if (is(myTypes.C_MODULE_SIGNATURE)) {
+                // module X : |>sig<| ...
+                markDummyScope(myTypes.C_SCOPED_EXPR, myTypes.SIG);
             } else {
                 markScope(myTypes.C_SIG_EXPR, myTypes.SIG);
             }
"
gitbucket-markedj-2dce74e12083,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: io.github.gitbucket.markedj.MarkedTest#testHardLineBreakWithBackslash
Type: org.junit.ComparisonFailure
Message: expected:<<p>Line 1[<br> ] Line 2</p>> but was:<<p>Line 1[\] Line 2</p>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.gitbucket-markedj-2dce74e12083:msbench-0.0.1,"diff --git a/src/main/java/io/github/gitbucket/markedj/Grammer.java b/src/main/java/io/github/gitbucket/markedj/Grammer.java
index f7f2312..a9945d1 100644
--- a/src/main/java/io/github/gitbucket/markedj/Grammer.java
+++ b/src/main/java/io/github/gitbucket/markedj/Grammer.java
@@ -77,7 +77,7 @@ public class Grammer {
 
     public static String INLINE_ESCAPE = ""^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])"";
     public static String INLINE_TEXT   = ""^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)"";
-    public static String INLINE_BR     = ""^ {2,}\\n(?!\\s*$)"";
+    public static String INLINE_BR     = ""^( {2,}|\\\\)\\n(?!\\s*$)"";
 
     static {
         INLINE_RULES.put(""escape"", new FindFirstRule(INLINE_ESCAPE));
"
gradle-common-custom-user-data-gradle-plugin-982c77984b5e,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.gradle.UtilsTest#[2] github, https://user:secret@%s.com/acme-inc/my-project
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Optional[https://github.com/acme-inc/my-project]> but was: <Optional.empty>

Test: com.gradle.UtilsTest#[9] gitlab, https://user:secret@%s.com/acme-inc/my-project
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <Optional[https://gitlab.com/acme-inc/my-project]> but was: <Optional.empty>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.gradle-common-custom-user-data-gradle-plugin-982c77984b5e:msbench-0.0.1,"diff --git a/src/main/java/com/gradle/Utils.java b/src/main/java/com/gradle/Utils.java
index e96500e..1c068c4 100644
--- a/src/main/java/com/gradle/Utils.java
+++ b/src/main/java/com/gradle/Utils.java
@@ -29,7 +29,7 @@ import java.util.regex.Pattern;
 
 final class Utils {
 
-    private static final Pattern GIT_REPO_URI_PATTERN = Pattern.compile(""^(?:(?:https://|git://)|(?:ssh)?.*?@)(.*?(?:github|gitlab).*?)(?:/|:[0-9]*?/|:)(.*?)(?:\\.git)?$"");
+    private static final Pattern GIT_REPO_URI_PATTERN = Pattern.compile(""^(?:(?:https://|git://)(?:.+:.+@)?|(?:ssh)?.*?@)(.*?(?:github|gitlab).*?)(?:/|:[0-9]*?/|:)(.*?)(?:\\.git)?$"");
 
     static Optional<String> sysPropertyOrEnvVariable(String sysPropertyName, String envVarName, ProviderFactory providers) {
         Optional<String> sysProperty = sysProperty(sysPropertyName, providers);
"
iipc-jwarc-e00ce46c1e36,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.netpreserve.jwarc.cdx.CdxRequestEncoderTest#test
Type: org.junit.ComparisonFailure
Message: Case 8 expected:<...his+is+very+long+thi[s+is+very+long+th]> but was:<...his+is+very+long+thi[]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.iipc-jwarc-e00ce46c1e36:msbench-0.0.1,"diff --git a/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java b/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
index 9ac2df3..20af855 100644
--- a/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
+++ b/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
@@ -28,18 +28,19 @@ public class CdxRequestEncoder {
         StringBuilder out = new StringBuilder();
         out.append(""__wb_method="");
         out.append(httpRequest.method());
+        int maxLength = out.length() + 1 + QUERY_STRING_LIMIT;
         MediaType baseContentType = httpRequest.contentType().base();
         InputStream stream = new BufferedInputStream(httpRequest.body().stream(), BUFFER_SIZE);
         if (baseContentType.equals(MediaType.WWW_FORM_URLENCODED)) {
             encodeFormBody(stream, out);
         } else if (baseContentType.equals(MediaType.JSON)) {
-            encodeJsonBody(stream, out, false);
+            encodeJsonBody(stream, out, maxLength, false);
         } else if (baseContentType.equals(MediaType.PLAIN_TEXT)) {
-            encodeJsonBody(stream, out, true);
+            encodeJsonBody(stream, out, maxLength, true);
         } else {
             encodeBinaryBody(stream, out);
         }
-        return out.substring(0, Math.min(out.length(), QUERY_STRING_LIMIT));
+        return out.substring(0, Math.min(out.length(), maxLength));
     }
 
     static void encodeBinaryBody(InputStream stream, StringBuilder out) throws IOException {
@@ -61,14 +62,14 @@ public class CdxRequestEncoder {
         }
     }
 
-    private static void encodeJsonBody(InputStream stream, StringBuilder output, boolean binaryFallback) throws IOException {
+    private static void encodeJsonBody(InputStream stream, StringBuilder output, int maxLength, boolean binaryFallback) throws IOException {
         stream.mark(BUFFER_SIZE);
         JsonParser parser = new JsonFactory().createParser(stream);
         Map<String,Long> nameCounts = new HashMap<>();
         Deque<String> nameStack = new ArrayDeque<>();
         String name = null;
         try {
-            while (parser.nextToken() != null && output.length() < QUERY_STRING_LIMIT) {
+            while (parser.nextToken() != null && output.length() < maxLength) {
                 switch (parser.currentToken()) {
                     case FIELD_NAME:
                         name = parser.getCurrentName();
"
iipc-jwarc-62dffb16a1a8,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.netpreserve.jwarc.WarcParserTest#testParsingArcWithBogusMime
Type: java.lang.AssertionError
Message: expected:<Optional[494]> but was:<Optional[charset494]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.iipc-jwarc-62dffb16a1a8:msbench-0.0.1,"diff --git a/src/org/netpreserve/jwarc/WarcParser.java b/src/org/netpreserve/jwarc/WarcParser.java
index 7207246..753d66d 100644
--- a/src/org/netpreserve/jwarc/WarcParser.java
+++ b/src/org/netpreserve/jwarc/WarcParser.java
@@ -20,7 +20,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 
-// line 147 ""WarcParser.rl""
+// line 142 ""WarcParser.rl""
 
 
 /**
@@ -243,30 +243,23 @@ case 1:
 	case 10:
 // line 80 ""WarcParser.rl""
 	{
-    // TODO
+    setHeader(""Content-Length"", new String(buf, 0, bufPos, US_ASCII));
     bufPos = 0;
 }
 	break;
 	case 11:
 // line 85 ""WarcParser.rl""
 	{
-    setHeader(""Content-Length"", new String(buf, 0, bufPos, US_ASCII));
-    bufPos = 0;
-}
-	break;
-	case 12:
-// line 90 ""WarcParser.rl""
-	{
     protocol = ""ARC"";
     major = 1;
     minor = 1;
 }
 	break;
-	case 13:
-// line 145 ""WarcParser.rl""
+	case 12:
+// line 140 ""WarcParser.rl""
 	{ { p += 1; _goto_targ = 5; if (true)  continue _goto;} }
 	break;
-// line 270 ""WarcParser.java""
+// line 263 ""WarcParser.java""
 			}
 		}
 	}
@@ -286,7 +279,7 @@ case 5:
 	break; }
 	}
 
-// line 209 ""WarcParser.rl""
+// line 204 ""WarcParser.rl""
 
         position += p - data.position();
         data.position(p);
@@ -340,14 +333,13 @@ case 5:
     }
 
     
-// line 344 ""WarcParser.java""
+// line 337 ""WarcParser.java""
 private static byte[] init__warc_actions_0()
 {
 	return new byte [] {
 	    0,    1,    0,    1,    1,    1,    2,    1,    3,    1,    4,    1,
-	    5,    1,    6,    1,    7,    1,    8,    1,    9,    1,   10,    1,
-	   13,    2,    0,   10,    2,    3,    0,    2,    4,    0,    2,    6,
-	    0,    3,   11,   12,   13
+	    5,    1,    6,    1,    7,    1,    8,    1,    9,    1,   12,    2,
+	    3,    0,    2,    4,    0,    2,    6,    0,    3,   10,   11,   12
 	};
 }
 
@@ -362,9 +354,9 @@ private static short[] init__warc_key_offsets_0()
 	  104,  106,  109,  111,  114,  116,  119,  121,  123,  125,  127,  129,
 	  131,  133,  135,  137,  139,  141,  143,  145,  147,  148,  165,  167,
 	  169,  172,  188,  205,  224,  228,  233,  236,  253,  269,  284,  302,
-	  309,  312,  316,  334,  351,  368,  386,  403,  412,  423,  435,  439,
-	  445,  448,  449,  452,  453,  456,  457,  460,  461,  477,  478,  494,
-	  500,  501,  519,  525,  531,  537,  537
+	  309,  312,  316,  334,  351,  368,  386,  403,  412,  423,  435,  441,
+	  444,  445,  448,  449,  452,  453,  456,  457,  473,  474,  490,  496,
+	  497,  515,  521,  527,  533,  533
 	};
 }
 
@@ -410,15 +402,15 @@ private static char[] init__warc_trans_keys_0()
 	   46,   48,   57,   65,   90,   94,  122,    9,   10,   32,   34,   92,
 	   33,  126,  128,  255,    9,   34,   92,   32,   47,   48,   57,   58,
 	  126,  128,  255,    9,   10,   34,   92,   32,   47,   48,   57,   58,
-	  126,  128,  255,    9,   10,   32,   59,   10,   32,    0,  191,  194,
-	  244,   32,   48,   57,   32,   46,   48,   57,   46,   46,   48,   57,
-	   46,   46,   48,   57,   46,   13,   33,  124,  126,   35,   39,   42,
-	   43,   45,   46,   48,   57,   65,   90,   94,  122,   10,   33,   58,
-	  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,
-	   94,  122,    9,   13,   32,  127,    0,   31,   10,    9,   13,   32,
-	   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,
-	   90,   94,  122,    9,   13,   32,  127,    0,   31,    9,   13,   32,
-	  127,    0,   31,    9,   13,   32,  127,    0,   31,    0
+	  126,  128,  255,   10,   32,    0,  191,  194,  244,   32,   48,   57,
+	   32,   46,   48,   57,   46,   46,   48,   57,   46,   46,   48,   57,
+	   46,   13,   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,
+	   57,   65,   90,   94,  122,   10,   33,   58,  124,  126,   35,   39,
+	   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,   13,
+	   32,  127,    0,   31,   10,    9,   13,   32,   33,  124,  126,   35,
+	   39,   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,
+	   13,   32,  127,    0,   31,    9,   13,   32,  127,    0,   31,    9,
+	   13,   32,  127,    0,   31,    0
 	};
 }
 
@@ -433,9 +425,9 @@ private static byte[] init__warc_single_lengths_0()
 	    0,    1,    0,    1,    0,    1,    0,    0,    0,    0,    0,    0,
 	    0,    0,    0,    0,    0,    0,    0,    0,    1,    5,    2,    0,
 	    1,    6,    5,    7,    4,    3,    3,    5,    4,    3,    6,    3,
-	    3,    0,    6,    5,    5,    6,    5,    5,    3,    4,    4,    2,
-	    1,    1,    1,    1,    1,    1,    1,    1,    4,    1,    4,    4,
-	    1,    6,    4,    4,    4,    0,    0
+	    3,    0,    6,    5,    5,    6,    5,    5,    3,    4,    2,    1,
+	    1,    1,    1,    1,    1,    1,    1,    4,    1,    4,    4,    1,
+	    6,    4,    4,    4,    0,    0
 	};
 }
 
@@ -450,9 +442,9 @@ private static byte[] init__warc_range_lengths_0()
 	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
 	    1,    1,    1,    1,    1,    1,    1,    1,    0,    6,    0,    1,
 	    1,    5,    6,    6,    0,    1,    0,    6,    6,    6,    6,    2,
-	    0,    2,    6,    6,    6,    6,    6,    2,    4,    4,    0,    2,
-	    1,    0,    1,    0,    1,    0,    1,    0,    6,    0,    6,    1,
-	    0,    6,    1,    1,    1,    0,    0
+	    0,    2,    6,    6,    6,    6,    6,    2,    4,    4,    2,    1,
+	    0,    1,    0,    1,    0,    1,    0,    6,    0,    6,    1,    0,
+	    6,    1,    1,    1,    0,    0
 	};
 }
 
@@ -468,8 +460,8 @@ private static short[] init__warc_index_offsets_0()
 	  124,  126,  128,  130,  132,  134,  136,  138,  140,  142,  154,  157,
 	  159,  162,  174,  186,  200,  205,  210,  214,  226,  237,  247,  260,
 	  266,  270,  273,  286,  298,  310,  323,  335,  343,  351,  360,  365,
-	  370,  373,  375,  378,  380,  383,  385,  388,  390,  401,  403,  414,
-	  420,  422,  435,  441,  447,  453,  454
+	  368,  370,  373,  375,  378,  380,  383,  385,  396,  398,  409,  415,
+	  417,  430,  436,  442,  448,  449
 	};
 }
 
@@ -491,32 +483,32 @@ private static byte[] init__warc_indicies_0()
 	    1,   40,   41,    1,   42,    1,   43,    1,   44,    1,   45,    1,
 	   46,    1,   47,    1,   48,    1,   49,    1,   50,    1,   51,    1,
 	   52,    1,   53,    1,   54,    1,   55,    1,   56,    1,    1,   58,
-	   59,   59,   59,   59,   59,   59,   59,   59,   59,   57,    1,   60,
-	   57,   61,    1,   62,   61,    1,    1,   58,   59,   63,   59,   59,
-	   59,   59,   59,   59,   59,   57,    1,   60,   64,   64,   64,   64,
-	   64,   64,   64,   64,   64,   57,   65,    1,   66,   64,   67,   64,
-	   64,   64,   64,   64,   64,   64,   64,   57,   65,    1,   68,   67,
-	   57,   69,   69,   70,   61,    1,   69,   69,   70,    1,   70,   70,
-	   71,   71,   71,   71,   71,   71,   71,   71,   71,    1,   71,   72,
-	   71,   71,   71,   71,   71,   71,   71,   71,    1,   74,   73,   73,
-	   73,   73,   73,   73,   73,   73,    1,   69,   66,   73,   70,   73,
-	   73,   73,   73,   73,   73,   73,   73,    1,   74,   75,   76,   74,
-	   74,    1,   69,   66,   70,    1,   74,   74,    1,   67,    1,   77,
-	   78,   78,   78,   78,   78,   78,   78,   78,   78,   57,   70,   70,
-	   71,   71,   71,   71,   71,   71,   79,   71,   71,    1,   62,   71,
-	   72,   71,   71,   71,   71,   71,   79,   71,   71,    1,    1,   60,
-	   78,   80,   78,   78,   78,   78,   78,   78,   78,   78,   57,    1,
-	   60,   81,   64,   64,   64,   64,   64,   64,   64,   64,   57,   81,
-	    1,   82,   83,   84,   81,   81,   57,   74,   75,   76,   74,   85,
-	   74,   74,    1,   74,   62,   75,   76,   74,   85,   74,   74,    1,
-	   65,    1,   66,   67,   57,   74,   82,   81,   81,   57,   40,   86,
-	    1,   40,    1,   37,   87,    1,   37,    1,   34,   88,    1,   34,
-	    1,   31,   89,    1,   31,    1,   90,   91,   91,   91,   91,   91,
-	   91,   91,   91,   91,    1,   92,    1,   91,   93,   91,   91,   91,
-	   91,   91,   91,   91,   91,    1,   94,   95,   94,    1,    1,   96,
-	   97,    1,   98,   99,   98,  100,  100,  100,  100,  100,  100,  100,
-	  100,  100,    1,   98,  101,   98,    1,    1,  102,  103,  104,  103,
-	    1,    1,   96,  105,   95,  105,    1,    1,   96,    1,    1,    0
+	   59,   59,   59,   59,   59,   59,   59,   59,   59,   57,    1,   58,
+	   57,   60,    1,   61,   60,    1,    1,   58,   59,   62,   59,   59,
+	   59,   59,   59,   59,   59,   57,    1,   58,   63,   63,   63,   63,
+	   63,   63,   63,   63,   63,   57,   64,    1,   65,   63,   66,   63,
+	   63,   63,   63,   63,   63,   63,   63,   57,   64,    1,   65,   66,
+	   57,   67,   67,   68,   60,    1,   67,   67,   68,    1,   68,   68,
+	   69,   69,   69,   69,   69,   69,   69,   69,   69,    1,   69,   70,
+	   69,   69,   69,   69,   69,   69,   69,   69,    1,   72,   71,   71,
+	   71,   71,   71,   71,   71,   71,    1,   67,   65,   71,   68,   71,
+	   71,   71,   71,   71,   71,   71,   71,    1,   72,   73,   74,   72,
+	   72,    1,   67,   65,   68,    1,   72,   72,    1,   66,    1,   75,
+	   76,   76,   76,   76,   76,   76,   76,   76,   76,   57,   68,   68,
+	   69,   69,   69,   69,   69,   69,   77,   69,   69,    1,   61,   69,
+	   70,   69,   69,   69,   69,   69,   77,   69,   69,    1,    1,   58,
+	   76,   78,   76,   76,   76,   76,   76,   76,   76,   76,   57,    1,
+	   58,   79,   63,   63,   63,   63,   63,   63,   63,   63,   57,   79,
+	    1,   80,   64,   81,   79,   79,   57,   72,   73,   74,   72,   82,
+	   72,   72,    1,   72,   61,   73,   74,   72,   82,   72,   72,    1,
+	   72,   80,   79,   79,   57,   40,   83,    1,   40,    1,   37,   84,
+	    1,   37,    1,   34,   85,    1,   34,    1,   31,   86,    1,   31,
+	    1,   87,   88,   88,   88,   88,   88,   88,   88,   88,   88,    1,
+	   89,    1,   88,   90,   88,   88,   88,   88,   88,   88,   88,   88,
+	    1,   91,   92,   91,    1,    1,   93,   94,    1,   95,   96,   95,
+	   97,   97,   97,   97,   97,   97,   97,   97,   97,    1,   95,   98,
+	   95,    1,    1,   99,  100,  101,  100,    1,    1,   93,  102,   92,
+	  102,    1,    1,   93,    1,    1,    0
 	};
 }
 
@@ -527,14 +519,14 @@ private static byte[] init__warc_trans_targs_0()
 {
 	return new byte [] {
 	    2,    0,   20,    3,    4,    5,    6,    7,    8,    9,   10,   11,
-	   12,   13,   89,   14,   14,   15,   18,   16,   17,   12,   13,   15,
-	   18,   19,   15,   19,   21,   22,   23,   24,   78,   25,   26,   76,
-	   27,   28,   74,   29,   30,   72,   31,   32,   33,   34,   35,   36,
+	   12,   13,   88,   14,   14,   15,   18,   16,   17,   12,   13,   15,
+	   18,   19,   15,   19,   21,   22,   23,   24,   77,   25,   26,   75,
+	   27,   28,   73,   29,   30,   71,   31,   32,   33,   34,   35,   36,
 	   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   49,
-	   47,   48,   89,   50,   51,   52,   53,   62,   53,   54,   55,   56,
-	   57,   58,   59,   60,   61,   63,   65,   64,   66,   67,   68,   70,
-	   71,   69,   73,   75,   77,   79,   81,   82,   90,   83,   83,   84,
-	   87,   85,   86,   81,   82,   84,   87,   88,   84,   88
+	   48,   88,   50,   51,   52,   53,   62,   54,   55,   56,   57,   58,
+	   59,   60,   61,   63,   65,   64,   66,   67,   68,   70,   69,   72,
+	   74,   76,   78,   80,   81,   89,   82,   82,   83,   86,   84,   85,
+	   80,   81,   83,   86,   87,   83,   87
 	};
 }
 
@@ -545,14 +537,14 @@ private static byte[] init__warc_trans_actions_0()
 {
 	return new byte [] {
 	    0,    0,    1,    0,    0,    0,    0,    3,    0,    5,    0,    0,
-	    0,    1,   23,   11,    0,    0,    1,    0,    0,   13,   34,    9,
-	   31,   28,    7,    1,    1,   15,    1,    1,    1,    1,    1,    1,
+	    0,    1,   21,   11,    0,    0,    1,    0,    0,   13,   29,    9,
+	   26,   23,    7,    1,    1,   15,    1,    1,    1,    1,    1,    1,
 	    1,    1,    1,    1,   17,    1,    1,    1,    1,    1,    1,    1,
-	    1,    1,    1,    1,    1,    1,    1,    1,   19,    0,   21,    1,
-	    0,    1,   37,    1,    1,    1,   25,    1,    1,    1,    1,    1,
-	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-	    1,    1,    1,    1,    1,    1,    0,    1,    0,   11,    0,    0,
-	    1,    0,    0,   13,   34,    9,   31,   28,    7,    1
+	    1,    1,    1,    1,    1,    1,    1,    1,   19,    0,    0,    0,
+	    1,   32,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+	    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,    1,    1,
+	    1,    1,    1,    0,    1,    0,   11,    0,    0,    1,    0,    0,
+	   13,   29,    9,   26,   23,    7,    1
 	};
 }
 
@@ -560,12 +552,12 @@ private static final byte _warc_trans_actions[] = init__warc_trans_actions_0();
 
 
 static final int warc_start = 1;
-static final int warc_first_final = 89;
+static final int warc_first_final = 88;
 static final int warc_error = 0;
 
-static final int warc_en_warc_fields = 80;
+static final int warc_en_warc_fields = 79;
 static final int warc_en_any_header = 1;
 
 
-// line 262 ""WarcParser.rl""
+// line 257 ""WarcParser.rl""
 }
\ No newline at end of file
"
iipc-jwarc-d47a479c9025,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.netpreserve.jwarc.cdx.CdxRequestEncoderTest#test
Type: org.junit.ComparisonFailure
Message: Case 3 expected:<...method=POST&snowman=[%E2%98%83]> but was:<...method=POST&snowman=[☃]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.iipc-jwarc-d47a479c9025:msbench-0.0.1,"diff --git a/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java b/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
index c3d5220..db57870 100644
--- a/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
+++ b/src/org/netpreserve/jwarc/cdx/CdxRequestEncoder.java
@@ -56,13 +56,24 @@ public class CdxRequestEncoder {
             byte[] body = IOUtils.readNBytes(stream, limit);
             String decodedBody = String.valueOf(UTF_8.newDecoder().decode(ByteBuffer.wrap(body)));
             out.append('&');
-            out.append(URIs.percentPlusDecode(decodedBody));
+            percentEncodeNonPercent(URIs.percentPlusDecode(decodedBody), out);
         } catch (MalformedInputException e) {
             stream.reset();
             encodeBinaryBody(stream, out);
         }
     }
 
+    private static void percentEncodeNonPercent(String s, StringBuilder out) {
+        for (byte rawByte : s.getBytes(UTF_8)) {
+            int b = rawByte & 0xff;
+            if (b == '#' || b <= 0x20 || b >= 0x7f) {
+                out.append('%').append(String.format(""%02X"", b));
+            } else {
+                out.append((char) b);
+            }
+        }
+    }
+
     private static void encodeJsonBody(InputStream stream, StringBuilder output, int maxLength, boolean binaryFallback) throws IOException {
         stream.mark(BUFFER_SIZE);
         JsonTokenizer tokenizer = new JsonTokenizer(new BufferedReader(new InputStreamReader(stream, UTF_8)),
@@ -150,7 +161,7 @@ public class CdxRequestEncoder {
     public static String percentPlusEncode(String string) {
         StringBuilder output = new StringBuilder();
         Formatter formatter = new Formatter(output);
-        byte[] bytes = string.getBytes(StandardCharsets.UTF_8);
+        byte[] bytes = string.getBytes(UTF_8);
         for (byte rawByte : bytes) {
             int b = rawByte & 0xff;
             if (percentPlusUnreserved.get(b)) {
"
iipc-jwarc-6c7083b72172,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.netpreserve.jwarc.WarcParserTest#testParsingArcWithCorruptDates
Type: java.lang.AssertionError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.iipc-jwarc-6c7083b72172:msbench-0.0.1,"diff --git a/src/org/netpreserve/jwarc/MessageParser.java b/src/org/netpreserve/jwarc/MessageParser.java
index 278511a..a8c4daa 100644
--- a/src/org/netpreserve/jwarc/MessageParser.java
+++ b/src/org/netpreserve/jwarc/MessageParser.java
@@ -6,8 +6,20 @@
 package org.netpreserve.jwarc;
 
 import java.nio.ByteBuffer;
+import java.util.function.Consumer;
 
 public class MessageParser {
+    private Consumer<String> warningHandler;
+
+    protected void emitWarning(String message) {
+        if (warningHandler != null) {
+            warningHandler.accept(message);
+        }
+    }
+
+    void onWarning(Consumer<String> warningHandler) {
+        this.warningHandler = warningHandler;
+    }
 
     protected static String getErrorContext(String input, int position, int length) {
         StringBuilder context = new StringBuilder();
diff --git a/src/org/netpreserve/jwarc/WarcParser.java b/src/org/netpreserve/jwarc/WarcParser.java
index 753d66d..ed2c167 100644
--- a/src/org/netpreserve/jwarc/WarcParser.java
+++ b/src/org/netpreserve/jwarc/WarcParser.java
@@ -13,6 +13,7 @@ import java.time.Instant;
 import java.time.LocalDateTime;
 import java.time.ZoneOffset;
 import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeParseException;
 import java.util.*;
 
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
@@ -20,7 +21,7 @@ import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 
-// line 142 ""WarcParser.rl""
+// line 156 ""WarcParser.rl""
 
 
 /**
@@ -83,7 +84,7 @@ public class WarcParser extends MessageParser {
         int pe = data.limit();
 
         
-// line 87 ""WarcParser.java""
+// line 88 ""WarcParser.java""
 	{
 	int _klen;
 	int _trans = 0;
@@ -164,23 +165,23 @@ case 1:
 			switch ( _warc_actions[_acts++] )
 			{
 	case 0:
-// line 26 ""WarcParser.rl""
+// line 27 ""WarcParser.rl""
 	{ push(data.get(p)); }
 	break;
 	case 1:
-// line 27 ""WarcParser.rl""
+// line 28 ""WarcParser.rl""
 	{ major = major * 10 + data.get(p) - '0'; }
 	break;
 	case 2:
-// line 28 ""WarcParser.rl""
+// line 29 ""WarcParser.rl""
 	{ minor = minor * 10 + data.get(p) - '0'; }
 	break;
 	case 3:
-// line 29 ""WarcParser.rl""
+// line 30 ""WarcParser.rl""
 	{ endOfText = bufPos; }
 	break;
 	case 4:
-// line 31 ""WarcParser.rl""
+// line 32 ""WarcParser.rl""
 	{
     if (bufPos > 0) {
         bufPos = endOfText;
@@ -189,14 +190,14 @@ case 1:
 }
 	break;
 	case 5:
-// line 38 ""WarcParser.rl""
+// line 39 ""WarcParser.rl""
 	{
     name = new String(buf, 0, bufPos, US_ASCII);
     bufPos = 0;
 }
 	break;
 	case 6:
-// line 43 ""WarcParser.rl""
+// line 44 ""WarcParser.rl""
 	{
     String value = new String(buf, 0, endOfText, UTF_8);
     headerMap.computeIfAbsent(name, n -> new ArrayList<>()).add(value);
@@ -205,7 +206,7 @@ case 1:
 }
 	break;
 	case 7:
-// line 50 ""WarcParser.rl""
+// line 51 ""WarcParser.rl""
 	{
     String url = new String(buf, 0, bufPos, ISO_8859_1);
     if (url.startsWith(""filedesc://"")) {
@@ -225,30 +226,42 @@ case 1:
 }
 	break;
 	case 8:
-// line 68 ""WarcParser.rl""
+// line 69 ""WarcParser.rl""
 	{
     setHeader(""WARC-IP-Address"", new String(buf, 0, bufPos, US_ASCII));
     bufPos = 0;
 }
 	break;
 	case 9:
-// line 73 ""WarcParser.rl""
+// line 74 ""WarcParser.rl""
 	{
     String arcDate = new String(buf, 0, bufPos, US_ASCII);
-    Instant instant = LocalDateTime.parse(arcDate, arcTimeFormat).toInstant(ZoneOffset.UTC);
-    setHeader(""WARC-Date"", instant.toString());
+    // Some WARC files have been seen in the wild with truncated dates
+    if (arcDate.length() < 14) {
+        emitWarning(""ARC date too short ("" + arcDate.length() + "" digits)"");
+        arcDate = arcDate + ""00000000000000"".substring(arcDate.length());
+    } else if (arcDate.length() > 14) {
+        emitWarning(""ARC date too long ("" + arcDate.length() + "" digits)"");
+        arcDate = arcDate.substring(0, 14);
+    }
+    try {
+        Instant instant = LocalDateTime.parse(arcDate, arcTimeFormat).toInstant(ZoneOffset.UTC);
+        setHeader(""WARC-Date"", instant.toString());
+    } catch (DateTimeParseException e) {
+        emitWarning(""ARC date not parsable"");
+    }
     bufPos = 0;
 }
 	break;
 	case 10:
-// line 80 ""WarcParser.rl""
+// line 93 ""WarcParser.rl""
 	{
     setHeader(""Content-Length"", new String(buf, 0, bufPos, US_ASCII));
     bufPos = 0;
 }
 	break;
 	case 11:
-// line 85 ""WarcParser.rl""
+// line 98 ""WarcParser.rl""
 	{
     protocol = ""ARC"";
     major = 1;
@@ -256,10 +269,10 @@ case 1:
 }
 	break;
 	case 12:
-// line 140 ""WarcParser.rl""
+// line 154 ""WarcParser.rl""
 	{ { p += 1; _goto_targ = 5; if (true)  continue _goto;} }
 	break;
-// line 263 ""WarcParser.java""
+// line 276 ""WarcParser.java""
 			}
 		}
 	}
@@ -279,7 +292,7 @@ case 5:
 	break; }
 	}
 
-// line 204 ""WarcParser.rl""
+// line 218 ""WarcParser.rl""
 
         position += p - data.position();
         data.position(p);
@@ -333,7 +346,7 @@ case 5:
     }
 
     
-// line 337 ""WarcParser.java""
+// line 350 ""WarcParser.java""
 private static byte[] init__warc_actions_0()
 {
 	return new byte [] {
@@ -352,11 +365,12 @@ private static short[] init__warc_key_offsets_0()
 	    0,    0,    3,    4,    5,    6,    7,    9,   12,   14,   17,   18,
 	   34,   35,   51,   57,   58,   76,   82,   88,   94,   97,   99,  101,
 	  104,  106,  109,  111,  114,  116,  119,  121,  123,  125,  127,  129,
-	  131,  133,  135,  137,  139,  141,  143,  145,  147,  148,  165,  167,
-	  169,  172,  188,  205,  224,  228,  233,  236,  253,  269,  284,  302,
-	  309,  312,  316,  334,  351,  368,  386,  403,  412,  423,  435,  441,
-	  444,  445,  448,  449,  452,  453,  456,  457,  473,  474,  490,  496,
-	  497,  515,  521,  527,  533,  533
+	  131,  133,  135,  138,  155,  157,  159,  162,  178,  195,  214,  218,
+	  223,  226,  243,  259,  274,  292,  299,  302,  306,  324,  341,  358,
+	  376,  393,  402,  413,  425,  431,  434,  437,  440,  443,  446,  449,
+	  452,  455,  458,  461,  464,  467,  470,  473,  476,  479,  482,  485,
+	  488,  489,  492,  493,  496,  497,  500,  501,  504,  505,  521,  522,
+	  538,  544,  545,  563,  569,  575,  581,  581
 	};
 }
 
@@ -377,32 +391,36 @@ private static char[] init__warc_trans_keys_0()
 	  122,   10,   32,   48,   57,   46,   48,   57,   48,   57,   46,   48,
 	   57,   48,   57,   46,   48,   57,   48,   57,   32,   48,   57,   48,
 	   57,   48,   57,   48,   57,   48,   57,   48,   57,   48,   57,   48,
-	   57,   48,   57,   48,   57,   48,   57,   48,   57,   48,   57,   48,
-	   57,   48,   57,   32,   10,   32,   33,  124,  126,   35,   39,   42,
-	   43,   45,   46,   48,   57,   65,   90,   94,  122,   10,   32,   48,
-	   57,   10,   48,   57,   10,   32,   33,   47,  124,  126,   35,   39,
-	   42,   43,   45,   57,   65,   90,   94,  122,   10,   32,   33,  124,
-	  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,   94,
-	  122,    9,   10,   32,   33,   59,  124,  126,   35,   39,   42,   43,
-	   45,   46,   48,   57,   65,   90,   94,  122,    9,   10,   32,   59,
-	    9,   32,   59,   48,   57,    9,   32,   59,    9,   32,   33,  124,
-	  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,   94,
-	  122,   33,   61,  124,  126,   35,   39,   42,   43,   45,   46,   48,
-	   57,   65,   90,   94,  122,   34,  124,  126,   33,   39,   42,   43,
-	   45,   46,   48,   57,   65,   90,   94,  122,    9,   32,   33,   59,
-	  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,
-	   94,  122,    9,   34,   92,   32,  126,  128,  255,    9,   32,   59,
-	    0,  191,  194,  244,    9,   10,   32,   33,  124,  126,   35,   39,
-	   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,   32,
+	   57,   48,   57,   32,   48,   57,   10,   32,   33,  124,  126,   35,
+	   39,   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,   10,
+	   32,   48,   57,   10,   48,   57,   10,   32,   33,   47,  124,  126,
+	   35,   39,   42,   43,   45,   57,   65,   90,   94,  122,   10,   32,
 	   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,
-	   90,   94,  122,   10,   33,   61,  124,  126,   35,   39,   42,   43,
-	   45,   46,   48,   57,   65,   90,   94,  122,   10,   32,   33,   61,
-	  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,
-	   94,  122,   10,   32,   34,  124,  126,   33,   39,   42,   43,   45,
-	   46,   48,   57,   65,   90,   94,  122,    9,   10,   32,   34,   92,
-	   33,  126,  128,  255,    9,   34,   92,   32,   47,   48,   57,   58,
-	  126,  128,  255,    9,   10,   34,   92,   32,   47,   48,   57,   58,
-	  126,  128,  255,   10,   32,    0,  191,  194,  244,   32,   48,   57,
+	   90,   94,  122,    9,   10,   32,   33,   59,  124,  126,   35,   39,
+	   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,   10,
+	   32,   59,    9,   32,   59,   48,   57,    9,   32,   59,    9,   32,
+	   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,   65,
+	   90,   94,  122,   33,   61,  124,  126,   35,   39,   42,   43,   45,
+	   46,   48,   57,   65,   90,   94,  122,   34,  124,  126,   33,   39,
+	   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,   32,
+	   33,   59,  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,
+	   65,   90,   94,  122,    9,   34,   92,   32,  126,  128,  255,    9,
+	   32,   59,    0,  191,  194,  244,    9,   10,   32,   33,  124,  126,
+	   35,   39,   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,
+	    9,   32,   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,
+	   57,   65,   90,   94,  122,   10,   33,   61,  124,  126,   35,   39,
+	   42,   43,   45,   46,   48,   57,   65,   90,   94,  122,   10,   32,
+	   33,   61,  124,  126,   35,   39,   42,   43,   45,   46,   48,   57,
+	   65,   90,   94,  122,   10,   32,   34,  124,  126,   33,   39,   42,
+	   43,   45,   46,   48,   57,   65,   90,   94,  122,    9,   10,   32,
+	   34,   92,   33,  126,  128,  255,    9,   34,   92,   32,   47,   48,
+	   57,   58,  126,  128,  255,    9,   10,   34,   92,   32,   47,   48,
+	   57,   58,  126,  128,  255,   10,   32,    0,  191,  194,  244,   32,
+	   48,   57,   32,   48,   57,   32,   48,   57,   32,   48,   57,   32,
+	   48,   57,   32,   48,   57,   32,   48,   57,   32,   48,   57,   32,
+	   48,   57,   32,   48,   57,   32,   48,   57,   32,   48,   57,   32,
+	   48,   57,   32,   48,   57,   32,   48,   57,   32,   48,   57,   32,
+	   48,   57,   32,   48,   57,   32,   48,   57,   32,   32,   48,   57,
 	   32,   46,   48,   57,   46,   46,   48,   57,   46,   46,   48,   57,
 	   46,   13,   33,  124,  126,   35,   39,   42,   43,   45,   46,   48,
 	   57,   65,   90,   94,  122,   10,   33,   58,  124,  126,   35,   39,
@@ -423,11 +441,12 @@ private static byte[] init__warc_single_lengths_0()
 	    0,    1,    1,    1,    1,    1,    0,    1,    0,    1,    1,    4,
 	    1,    4,    4,    1,    6,    4,    4,    4,    1,    2,    0,    1,
 	    0,    1,    0,    1,    0,    1,    0,    0,    0,    0,    0,    0,
-	    0,    0,    0,    0,    0,    0,    0,    0,    1,    5,    2,    0,
-	    1,    6,    5,    7,    4,    3,    3,    5,    4,    3,    6,    3,
-	    3,    0,    6,    5,    5,    6,    5,    5,    3,    4,    2,    1,
-	    1,    1,    1,    1,    1,    1,    1,    4,    1,    4,    4,    1,
-	    6,    4,    4,    4,    0,    0
+	    0,    0,    1,    5,    2,    0,    1,    6,    5,    7,    4,    3,
+	    3,    5,    4,    3,    6,    3,    3,    0,    6,    5,    5,    6,
+	    5,    5,    3,    4,    2,    1,    1,    1,    1,    1,    1,    1,
+	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+	    1,    1,    1,    1,    1,    1,    1,    1,    1,    4,    1,    4,
+	    4,    1,    6,    4,    4,    4,    0,    0
 	};
 }
 
@@ -440,11 +459,12 @@ private static byte[] init__warc_range_lengths_0()
 	    0,    1,    0,    0,    0,    0,    1,    1,    1,    1,    0,    6,
 	    0,    6,    1,    0,    6,    1,    1,    1,    1,    0,    1,    1,
 	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-	    1,    1,    1,    1,    1,    1,    1,    1,    0,    6,    0,    1,
-	    1,    5,    6,    6,    0,    1,    0,    6,    6,    6,    6,    2,
-	    0,    2,    6,    6,    6,    6,    6,    2,    4,    4,    2,    1,
-	    0,    1,    0,    1,    0,    1,    0,    6,    0,    6,    1,    0,
-	    6,    1,    1,    1,    0,    0
+	    1,    1,    1,    6,    0,    1,    1,    5,    6,    6,    0,    1,
+	    0,    6,    6,    6,    6,    2,    0,    2,    6,    6,    6,    6,
+	    6,    2,    4,    4,    2,    1,    1,    1,    1,    1,    1,    1,
+	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+	    0,    1,    0,    1,    0,    1,    0,    1,    0,    6,    0,    6,
+	    1,    0,    6,    1,    1,    1,    0,    0
 	};
 }
 
@@ -457,11 +477,12 @@ private static short[] init__warc_index_offsets_0()
 	    0,    0,    3,    5,    7,    9,   11,   13,   16,   18,   21,   23,
 	   34,   36,   47,   53,   55,   68,   74,   80,   86,   89,   92,   94,
 	   97,   99,  102,  104,  107,  109,  112,  114,  116,  118,  120,  122,
-	  124,  126,  128,  130,  132,  134,  136,  138,  140,  142,  154,  157,
-	  159,  162,  174,  186,  200,  205,  210,  214,  226,  237,  247,  260,
-	  266,  270,  273,  286,  298,  310,  323,  335,  343,  351,  360,  365,
-	  368,  370,  373,  375,  378,  380,  383,  385,  396,  398,  409,  415,
-	  417,  430,  436,  442,  448,  449
+	  124,  126,  128,  131,  143,  146,  148,  151,  163,  175,  189,  194,
+	  199,  203,  215,  226,  236,  249,  255,  259,  262,  275,  287,  299,
+	  312,  324,  332,  340,  349,  354,  357,  360,  363,  366,  369,  372,
+	  375,  378,  381,  384,  387,  390,  393,  396,  399,  402,  405,  408,
+	  411,  413,  416,  418,  421,  423,  426,  428,  431,  433,  444,  446,
+	  457,  463,  465,  478,  484,  490,  496,  497
 	};
 }
 
@@ -481,34 +502,38 @@ private static byte[] init__warc_indicies_0()
 	    1,   18,   28,    2,    1,    1,   29,   28,   30,    1,   31,   32,
 	    1,   33,    1,   34,   35,    1,   36,    1,   37,   38,    1,   39,
 	    1,   40,   41,    1,   42,    1,   43,    1,   44,    1,   45,    1,
-	   46,    1,   47,    1,   48,    1,   49,    1,   50,    1,   51,    1,
-	   52,    1,   53,    1,   54,    1,   55,    1,   56,    1,    1,   58,
-	   59,   59,   59,   59,   59,   59,   59,   59,   59,   57,    1,   58,
-	   57,   60,    1,   61,   60,    1,    1,   58,   59,   62,   59,   59,
-	   59,   59,   59,   59,   59,   57,    1,   58,   63,   63,   63,   63,
-	   63,   63,   63,   63,   63,   57,   64,    1,   65,   63,   66,   63,
-	   63,   63,   63,   63,   63,   63,   63,   57,   64,    1,   65,   66,
-	   57,   67,   67,   68,   60,    1,   67,   67,   68,    1,   68,   68,
-	   69,   69,   69,   69,   69,   69,   69,   69,   69,    1,   69,   70,
-	   69,   69,   69,   69,   69,   69,   69,   69,    1,   72,   71,   71,
-	   71,   71,   71,   71,   71,   71,    1,   67,   65,   71,   68,   71,
-	   71,   71,   71,   71,   71,   71,   71,    1,   72,   73,   74,   72,
-	   72,    1,   67,   65,   68,    1,   72,   72,    1,   66,    1,   75,
-	   76,   76,   76,   76,   76,   76,   76,   76,   76,   57,   68,   68,
-	   69,   69,   69,   69,   69,   69,   77,   69,   69,    1,   61,   69,
-	   70,   69,   69,   69,   69,   69,   77,   69,   69,    1,    1,   58,
-	   76,   78,   76,   76,   76,   76,   76,   76,   76,   76,   57,    1,
-	   58,   79,   63,   63,   63,   63,   63,   63,   63,   63,   57,   79,
-	    1,   80,   64,   81,   79,   79,   57,   72,   73,   74,   72,   82,
-	   72,   72,    1,   72,   61,   73,   74,   72,   82,   72,   72,    1,
-	   72,   80,   79,   79,   57,   40,   83,    1,   40,    1,   37,   84,
-	    1,   37,    1,   34,   85,    1,   34,    1,   31,   86,    1,   31,
-	    1,   87,   88,   88,   88,   88,   88,   88,   88,   88,   88,    1,
-	   89,    1,   88,   90,   88,   88,   88,   88,   88,   88,   88,   88,
-	    1,   91,   92,   91,    1,    1,   93,   94,    1,   95,   96,   95,
-	   97,   97,   97,   97,   97,   97,   97,   97,   97,    1,   95,   98,
-	   95,    1,    1,   99,  100,  101,  100,    1,    1,   93,  102,   92,
-	  102,    1,    1,   93,    1,    1,    0
+	   46,    1,   47,    1,   48,    1,   49,    1,   50,   51,    1,    1,
+	   53,   54,   54,   54,   54,   54,   54,   54,   54,   54,   52,    1,
+	   53,   52,   55,    1,   56,   55,    1,    1,   53,   54,   57,   54,
+	   54,   54,   54,   54,   54,   54,   52,    1,   53,   58,   58,   58,
+	   58,   58,   58,   58,   58,   58,   52,   59,    1,   60,   58,   61,
+	   58,   58,   58,   58,   58,   58,   58,   58,   52,   59,    1,   60,
+	   61,   52,   62,   62,   63,   55,    1,   62,   62,   63,    1,   63,
+	   63,   64,   64,   64,   64,   64,   64,   64,   64,   64,    1,   64,
+	   65,   64,   64,   64,   64,   64,   64,   64,   64,    1,   67,   66,
+	   66,   66,   66,   66,   66,   66,   66,    1,   62,   60,   66,   63,
+	   66,   66,   66,   66,   66,   66,   66,   66,    1,   67,   68,   69,
+	   67,   67,    1,   62,   60,   63,    1,   67,   67,    1,   61,    1,
+	   70,   71,   71,   71,   71,   71,   71,   71,   71,   71,   52,   63,
+	   63,   64,   64,   64,   64,   64,   64,   72,   64,   64,    1,   56,
+	   64,   65,   64,   64,   64,   64,   64,   72,   64,   64,    1,    1,
+	   53,   71,   73,   71,   71,   71,   71,   71,   71,   71,   71,   52,
+	    1,   53,   74,   58,   58,   58,   58,   58,   58,   58,   58,   52,
+	   74,    1,   75,   59,   76,   74,   74,   52,   67,   68,   69,   67,
+	   77,   67,   67,    1,   67,   56,   68,   69,   67,   77,   67,   67,
+	    1,   67,   75,   74,   74,   52,   50,   78,    1,   50,   79,    1,
+	   50,   80,    1,   50,   81,    1,   50,   82,    1,   50,   83,    1,
+	   50,   84,    1,   50,   85,    1,   50,   86,    1,   50,   87,    1,
+	   50,   88,    1,   50,   89,    1,   50,   90,    1,   50,   91,    1,
+	   50,   92,    1,   50,   93,    1,   50,   94,    1,   50,   95,    1,
+	   50,   96,    1,   50,    1,   40,   97,    1,   40,    1,   37,   98,
+	    1,   37,    1,   34,   99,    1,   34,    1,   31,  100,    1,   31,
+	    1,  101,  102,  102,  102,  102,  102,  102,  102,  102,  102,    1,
+	  103,    1,  102,  104,  102,  102,  102,  102,  102,  102,  102,  102,
+	    1,  105,  106,  105,    1,    1,  107,  108,    1,  109,  110,  109,
+	  111,  111,  111,  111,  111,  111,  111,  111,  111,    1,  109,  112,
+	  109,    1,    1,  113,  114,  115,  114,    1,    1,  107,  116,  106,
+	  116,    1,    1,  107,    1,    1,    0
 	};
 }
 
@@ -519,14 +544,15 @@ private static byte[] init__warc_trans_targs_0()
 {
 	return new byte [] {
 	    2,    0,   20,    3,    4,    5,    6,    7,    8,    9,   10,   11,
-	   12,   13,   88,   14,   14,   15,   18,   16,   17,   12,   13,   15,
-	   18,   19,   15,   19,   21,   22,   23,   24,   77,   25,   26,   75,
-	   27,   28,   73,   29,   30,   71,   31,   32,   33,   34,   35,   36,
-	   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   49,
-	   48,   88,   50,   51,   52,   53,   62,   54,   55,   56,   57,   58,
-	   59,   60,   61,   63,   65,   64,   66,   67,   68,   70,   69,   72,
-	   74,   76,   78,   80,   81,   89,   82,   82,   83,   86,   84,   85,
-	   80,   81,   83,   86,   87,   83,   87
+	   12,   13,  102,   14,   14,   15,   18,   16,   17,   12,   13,   15,
+	   18,   19,   15,   19,   21,   22,   23,   24,   91,   25,   26,   89,
+	   27,   28,   87,   29,   30,   85,   31,   32,   33,   34,   35,   36,
+	   37,   38,   39,   65,   40,   41,   43,   42,  102,   44,   45,   46,
+	   47,   56,   48,   49,   50,   51,   52,   53,   54,   55,   57,   59,
+	   58,   60,   61,   62,   64,   63,   66,   67,   68,   69,   70,   71,
+	   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,   82,   83,
+	   84,   86,   88,   90,   92,   94,   95,  103,   96,   96,   97,  100,
+	   98,   99,   94,   95,   97,  100,  101,   97,  101
 	};
 }
 
@@ -540,11 +566,12 @@ private static byte[] init__warc_trans_actions_0()
 	    0,    1,   21,   11,    0,    0,    1,    0,    0,   13,   29,    9,
 	   26,   23,    7,    1,    1,   15,    1,    1,    1,    1,    1,    1,
 	    1,    1,    1,    1,   17,    1,    1,    1,    1,    1,    1,    1,
-	    1,    1,    1,    1,    1,    1,    1,    1,   19,    0,    0,    0,
-	    1,   32,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-	    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,    1,    1,
-	    1,    1,    1,    0,    1,    0,   11,    0,    0,    1,    0,    0,
-	   13,   29,    9,   26,   23,    7,    1
+	    1,    1,   19,    1,    0,    0,    0,    1,   32,    0,    0,    0,
+	    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+	    1,    0,    0,    0,    0,    1,    1,    1,    1,    1,    1,    1,
+	    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+	    1,    1,    1,    1,    1,    0,    1,    0,   11,    0,    0,    1,
+	    0,    0,   13,   29,    9,   26,   23,    7,    1
 	};
 }
 
@@ -552,12 +579,12 @@ private static final byte _warc_trans_actions[] = init__warc_trans_actions_0();
 
 
 static final int warc_start = 1;
-static final int warc_first_final = 88;
+static final int warc_first_final = 102;
 static final int warc_error = 0;
 
-static final int warc_en_warc_fields = 79;
+static final int warc_en_warc_fields = 93;
 static final int warc_en_any_header = 1;
 
 
-// line 257 ""WarcParser.rl""
+// line 271 ""WarcParser.rl""
 }
\ No newline at end of file
diff --git a/src/org/netpreserve/jwarc/WarcReader.java b/src/org/netpreserve/jwarc/WarcReader.java
index 2b884b9..60254ef 100644
--- a/src/org/netpreserve/jwarc/WarcReader.java
+++ b/src/org/netpreserve/jwarc/WarcReader.java
@@ -363,6 +363,7 @@ public class WarcReader implements Iterable<WarcRecord>, Closeable {
      */
     public void onWarning(Consumer<String> warningHandler) {
         this.warningHandler = warningHandler;
+        parser.onWarning(warningHandler);
     }
 
     /**
diff --git a/src/org/netpreserve/jwarc/cdx/CdxWriter.java b/src/org/netpreserve/jwarc/cdx/CdxWriter.java
index 6e319c3..741894f 100644
--- a/src/org/netpreserve/jwarc/cdx/CdxWriter.java
+++ b/src/org/netpreserve/jwarc/cdx/CdxWriter.java
@@ -100,6 +100,12 @@ public class CdxWriter implements Closeable {
                     record = reader.next().orElse(null);
                     long length = reader.position() - position;
 
+                    // skip records without a date, this often occurs in old ARC files with a corrupt date field
+                    if (!capture.headers().first(""WARC-Date"").isPresent()) {
+                        emitWarning(filename, position, ""Skipping record due to missing or invalid date"");
+                        continue;
+                    }
+
                     String encodedRequest = null;
                     if (postAppend) {
                         // check for a corresponding request record
"
jhy-jsoup-29be991198d3,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#wrapTextAfterBr
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>Hello<br>
 there<br>
 now.</p>> but was: <<p>Hello<br>there<br>now.</p>>

Test: org.jsoup.parser.HtmlParserTest#selfClosingVoidIsNotAnError
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>test<br>
 test<br></p>> but was: <<p>test<br>test<br></p>>

Test: org.jsoup.parser.XmlTreeBuilderTest#testDoesNotForceSelfClosingKnownTags
Type: org.opentest4j.AssertionFailedError
Message: expected: <<br>
one<br>> but was: <<br>one<br>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-29be991198d3:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/TextNode.java b/src/main/java/org/jsoup/nodes/TextNode.java
index 4dbd116..ecb39aa 100644
--- a/src/main/java/org/jsoup/nodes/TextNode.java
+++ b/src/main/java/org/jsoup/nodes/TextNode.java
@@ -93,13 +93,18 @@ public class TextNode extends LeafNode {
             trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();
 
             // if this text is just whitespace, and the next node will cause an indent, skip this text:
-            Node next = this.nextSibling();
+            Node next = nextSibling();
+            boolean isBlank = isBlank();
             boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent
                 || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting
-            if (couldSkip && isBlank()) return;
-
-            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank()) ||
-                (out.outline() && siblingNodes().size() > 0 && !isBlank()))
+            if (couldSkip && isBlank) return;
+
+            Node prev = previousSibling();
+            if (
+                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||
+                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||
+                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(""br"")) // special case wrap on inline <br> - doesn't make sense as a block tag
+            )
                 indent(accum, depth, out);
         }
 
"
jhy-jsoup-9e5869b6e1e2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#noDanglingSpaceAfterCustomElement
Type: org.opentest4j.AssertionFailedError
Message: expected: <<bar>
 <p></p>
</bar>> but was: <<bar>
 <p></p> 
</bar>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-9e5869b6e1e2:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/TextNode.java b/src/main/java/org/jsoup/nodes/TextNode.java
index ecb39aa..6d8ab63 100644
--- a/src/main/java/org/jsoup/nodes/TextNode.java
+++ b/src/main/java/org/jsoup/nodes/TextNode.java
@@ -84,13 +84,12 @@ public class TextNode extends LeafNode {
         final boolean prettyPrint = out.prettyPrint();
         final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;
         final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);
+        final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());
+        boolean trimLeading = false, trimTrailing = false;
 
-        boolean trimLeading = false;
-        boolean trimTrailing = false;
         if (normaliseWhite) {
-            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||
-                parentNode instanceof Document;
-            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();
+            trimLeading = (trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document;
+            trimTrailing = trimLikeBlock && nextSibling() == null;
 
             // if this text is just whitespace, and the next node will cause an indent, skip this text:
             Node next = nextSibling();
"
jhy-jsoup-45ed00232722,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.HttpConnectionTest#encodeUrl
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://test.com/foo%20bar/%5BOne%5D?q=white%20space#frag> but was: <https://test.com/foo bar/[One]?q=white space#frag>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-45ed00232722:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java
index 6b856fe..cb45448 100644
--- a/src/main/java/org/jsoup/helper/HttpConnection.java
+++ b/src/main/java/org/jsoup/helper/HttpConnection.java
@@ -125,11 +125,9 @@ public class HttpConnection implements Connection {
     static URL encodeUrl(URL u) {
 	    u = punyUrl(u);
         try {
-            //  odd way to encode urls, but it works!
-            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)
-            urlS = urlS.replace("" "", ""%20"");
-            final URI uri = new URI(urlS);
-            return new URL(uri.toASCIIString());
+            // run the URL through URI, so components are encoded
+            URI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());
+            return uri.toURL();
         } catch (URISyntaxException | MalformedURLException e) {
             // give up and return the original input
             return u;
"
jhy-jsoup-f2913bd731f1,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#spanInBlockTrims
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>Lorem ipsum</p><span>Thanks</span>> but was: <<p>Lorem ipsum</p> <span>Thanks</span>>

Test: org.jsoup.nodes.ElementTest#elementIndentAndSpaceTrims
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 <p>One Two</p><a> Hello </a>
 <p>Some text</p>
</div>> but was: <<div>
 <p>One Two</p> <a> Hello </a>
 <p>Some text</p>
</div>>

Test: org.jsoup.parser.HtmlParserTest#nestedAnchorAdoption
Type: org.opentest4j.AssertionFailedError
Message: expected: <<a> <b> </b></a><b><div><a> </a><a>test</a></div></b>> but was: <<a> <b> </b></a><b><div><a> </a><a>test</a></div> </b>>

Test: org.jsoup.parser.HtmlParserTest#testSpanContents
Type: org.opentest4j.AssertionFailedError
Message: expected: <<span>Hello <div>there</div><span>now</span></span>> but was: <<span>Hello <div>there</div> <span>now</span></span>>

Test: org.jsoup.parser.HtmlParserTest#reconstructFormattingElementsInTable
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p><b>One</b></p><b>
 <table>
  <tbody>
   <tr>
    <td><p><i>Three</i></p><p><i>Four</i></p></td>
   </tr>
  </tbody>
 </table><p>Five</p></b>> but was: <<p><b>One</b></p><b>
 <table>
  <tbody>
   <tr>
    <td><p><i>Three</i></p><p><i>Four</i></p></td>
   </tr>
  </tbody>
 </table> <p>Five</p></b>>

Test: org.jsoup.parser.HtmlParserTest#testFontFlowContents
Type: org.opentest4j.AssertionFailedError
Message: expected: <<font>Hello <div>there</div><span>now</span></font>> but was: <<font>Hello <div>there</div> <span>now</span></font>>

Test: org.jsoup.parser.HtmlParserTest#testAFlowContents
Type: org.opentest4j.AssertionFailedError
Message: expected: <<a>Hello <div>there</div><span>now</span></a>> but was: <<a>Hello <div>there</div> <span>now</span></a>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-f2913bd731f1:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/TextNode.java b/src/main/java/org/jsoup/nodes/TextNode.java
index 6d8ab63..df67a84 100644
--- a/src/main/java/org/jsoup/nodes/TextNode.java
+++ b/src/main/java/org/jsoup/nodes/TextNode.java
@@ -93,12 +93,14 @@ public class TextNode extends LeafNode {
 
             // if this text is just whitespace, and the next node will cause an indent, skip this text:
             Node next = nextSibling();
+            Node prev = previousSibling();
             boolean isBlank = isBlank();
             boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent
-                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting
+                || (next instanceof TextNode && (((TextNode) next).isBlank())) // next is blank text, from re-parenting
+                || (prev instanceof Element && ((Element) prev).isBlock())
+                ;
             if (couldSkip && isBlank) return;
 
-            Node prev = previousSibling();
             if (
                 (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||
                 (out.outline() && siblingNodes().size() > 0 && !isBlank) ||
"
jhy-jsoup-9bb07d2ab43c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#replaceWithSelf
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>Two</p>> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-9bb07d2ab43c:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java
index eee9291..f271b17 100644
--- a/src/main/java/org/jsoup/nodes/Node.java
+++ b/src/main/java/org/jsoup/nodes/Node.java
@@ -480,6 +480,8 @@ public abstract class Node implements Cloneable {
     protected void replaceChild(Node out, Node in) {
         Validate.isTrue(out.parentNode == this);
         Validate.notNull(in);
+        if (out == in) return; // no-op self replacement
+
         if (in.parentNode != null)
             in.parentNode.removeChild(in);
 
"
jhy-jsoup-e52224fbfe66,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#prettyprintBrInBlock
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 <br>
</div>> but was: <<div>
 <br>
 
</div>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-e52224fbfe66:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/TextNode.java b/src/main/java/org/jsoup/nodes/TextNode.java
index eae444a..7a7f00a 100644
--- a/src/main/java/org/jsoup/nodes/TextNode.java
+++ b/src/main/java/org/jsoup/nodes/TextNode.java
@@ -98,7 +98,7 @@ public class TextNode extends LeafNode {
             boolean isBlank = isBlank();
             boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent
                 || (next instanceof TextNode && (((TextNode) next).isBlank())) // next is blank text, from re-parenting
-                || (prev instanceof Element && ((Element) prev).isBlock())
+                || (prev instanceof Element && (((Element) prev).isBlock() || prev.isNode(""br""))) // br is a bit special - make sure we don't get a dangling blank line, but not a block otherwise wraps in head
                 ;
             if (couldSkip && isBlank) return;
 
"
jhy-jsoup-a96ebc95f9ad,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.HttpConnectionTest#connectToEncodedUrl
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://example.com/a%20b%20c?query%20string> but was: <https://example.com/a%2520b%2520c?query+string>

Test: org.jsoup.helper.HttpConnectionTest#encodedUrlDoesntDoubleEncode
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://test.com/foo%20bar/%5BOne%5D?q=white%20space#frag%20ment> but was: <https://test.com/foo%2520bar/%255BOne%255D?q=white%2520space#frag%2520ment>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-a96ebc95f9ad:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java
index d183a52..88595c3 100644
--- a/src/main/java/org/jsoup/helper/HttpConnection.java
+++ b/src/main/java/org/jsoup/helper/HttpConnection.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
 import java.net.CookieManager;
 import java.net.CookieStore;
 import java.net.HttpURLConnection;
@@ -30,6 +31,7 @@ import java.net.Proxy;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.net.URLDecoder;
 import java.net.URLEncoder;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
@@ -127,14 +129,21 @@ public class HttpConnection implements Connection {
 	    u = punyUrl(u);
         try {
             // run the URL through URI, so components are encoded
-            URI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());
+            URI uri = new URI(
+                u.getProtocol(), decodePart(u.getUserInfo()), u.getHost(), u.getPort(),
+                decodePart(u.getPath()), decodePart(u.getQuery()), decodePart(u.getRef()));
             return uri.toURL();
-        } catch (URISyntaxException | MalformedURLException e) {
+        } catch (URISyntaxException | MalformedURLException | UnsupportedEncodingException e) {
             // give up and return the original input
             return u;
         }
     }
 
+    @Nullable private static String decodePart(@Nullable String encoded) throws UnsupportedEncodingException {
+        if (encoded == null) return null;
+        return URLDecoder.decode(encoded, UTF_8.name());
+    }
+
     /**
      Convert an International URL to a Punycode URL.
      @param url input URL that may include an international hostname
"
jhy-jsoup-220a3b21be3b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.parser.HtmlParserTest#supportsRuby
Type: org.opentest4j.AssertionFailedError
Message: expected: <<ruby><rbc><rb>10</rb><rb>31</rb><rb>2002</rb></rbc><rtc><rt>Month</rt><rt>Day</rt><rt>Year</rt></rtc><rtc><rt>Expiration Date</rt><rp>(*)</rp></rtc></ruby>> but was: <<ruby><rbc><rb>10</rb><rb>31</rb><rb>2002</rb></rbc><rtc></rtc><rt>Month</rt><rt>Day</rt><rt>Year</rt><rtc></rtc><rt>Expiration Date</rt><rp>(*)</rp></ruby>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-220a3b21be3b:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 7a9c0be..715a995 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -838,6 +838,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
         return onStack(formattingElements, el);
     }
 
+    @Nullable
     Element getActiveFormattingElement(String nodeName) {
         for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
             Element next = formattingElements.get(pos);
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index 354b217..1ab9f7a 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -611,7 +611,7 @@ enum HtmlTreeBuilderState {
                     }
                     tb.insert(startTag);
                     break;
-                // static final String[] InBodyStartOptions = new String[]{""optgroup"", ""option""};
+
                 case ""optgroup"":
                 case ""option"":
                     if (tb.currentElementIs(""option""))
@@ -619,19 +619,27 @@ enum HtmlTreeBuilderState {
                     tb.reconstructFormattingElements();
                     tb.insert(startTag);
                     break;
-                // static final String[] InBodyStartRuby = new String[]{""rp"", ""rt""};
+
+                case ""rb"":
+                case ""rtc"":
+                    if (tb.onStack(""ruby"")) {
+                        tb.generateImpliedEndTags();
+                        if (!tb.currentElementIs(""ruby""))
+                            tb.error(this);
+                    }
+                    tb.insert(startTag);
+                    break;
+
                 case ""rp"":
                 case ""rt"":
                     if (tb.inScope(""ruby"")) {
-                        tb.generateImpliedEndTags();
-                        if (!tb.currentElementIs(""ruby"")) {
+                        tb.generateImpliedEndTags(""rtc"");
+                        if (!tb.currentElementIs(""rtc"") && !tb.currentElementIs(""ruby""))
                             tb.error(this);
-                            tb.popStackToBefore(""ruby""); // i.e. close up to but not include name
-                        }
-                        tb.insert(startTag);
                     }
-                    // todo - is this right? drops rp, rt if ruby not in scope?
+                    tb.insert(startTag);
                     break;
+
                 // InBodyStartEmptyFormatters:
                 case ""area"":
                 case ""br"":
"
jhy-jsoup-a349582236a7,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.parser.HtmlTreeBuilderStateTest#nestedAnchorElements01
Type: org.opentest4j.AssertionFailedError
Message: expected: <<html>
 <head></head>
 <body>
  <a href=""#1""> </a>
  <div>
   <a href=""#1""> </a><a href=""#2"">child</a>
  </div>
 </body>
</html>> but was: <<html>
 <head></head>
 <body><a href=""#1""> </a>
  <div>
   <a href=""#1""> </a><a href=""#2"">child</a>
  </div>
 </body>
</html>>

Test: org.jsoup.parser.HtmlTreeBuilderStateTest#nestedAnchorElements02
Type: org.opentest4j.AssertionFailedError
Message: expected: <<html>
 <head></head>
 <body>
  <a href=""#1""> </a>
  <div>
   <a href=""#1""> </a>
   <div>
    <a href=""#1""> </a><a href=""#2"">child</a>
   </div>
  </div>
 </body>
</html>> but was: <<html>
 <head></head>
 <body><a href=""#1""> </a>
  <div>
   <a href=""#1""> </a>
   <div>
    <a href=""#1""> </a><a href=""#2"">child</a>
   </div>
  </div>
 </body>
</html>>

Test: org.jsoup.nodes.ElementTest#inlineInBlockShouldIndent
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 One <span>Hello</span><span>!</span>
</div>
<div>
 <span>There</span>
</div>
<div>
 <span>Now</span>
</div>> but was: <<div>
 One <span>Hello</span><span>!</span>
</div>
<div><span>There</span>
</div>
<div><span>Now</span>
</div>>

Test: org.jsoup.nodes.ElementTest#divAInlineable
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 <a>Text</a>
</div>> but was: <<div><a>Text</a>
</div>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-a349582236a7:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index 507fce9..ad3b022 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -1846,9 +1846,15 @@ public class Element extends Node {
     }
 
     private boolean isInlineable(Document.OutputSettings out) {
-        return tag().isInline()
-            && (parent() == null || parent().isBlock())
-            && previousSibling() != null
+        if (!tag.isInline())
+            return false;
+
+        final Node prev = previousSibling();
+        boolean isFirst = siblingIndex == 0;
+        if (siblingIndex == 1 && prev instanceof TextNode && (((TextNode) prev).isBlank()))
+            isFirst = true;
+        return (parent() == null || parent().isBlock())
+            && !isFirst
             && !out.outline();
     }
 }
"
jhy-jsoup-195f484ba5de,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#rubyInline
Type: org.opentest4j.AssertionFailedError
Message: expected: <<ruby>T<rp>(</rp><rtc>!</rtc><rt>)</rt></ruby>> but was: <<ruby>T<rp>(</rp>
 <rtc>
  !
 </rtc><rt>)</rt></ruby>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-195f484ba5de:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java
index d573033..366bc63 100644
--- a/src/main/java/org/jsoup/parser/Tag.java
+++ b/src/main/java/org/jsoup/parser/Tag.java
@@ -242,7 +242,7 @@ public class Tag implements Cloneable {
     };
     private static final String[] inlineTags = {
             ""object"", ""base"", ""font"", ""tt"", ""i"", ""b"", ""u"", ""big"", ""small"", ""em"", ""strong"", ""dfn"", ""code"", ""samp"", ""kbd"",
-            ""var"", ""cite"", ""abbr"", ""time"", ""acronym"", ""mark"", ""ruby"", ""rt"", ""rp"", ""a"", ""img"", ""br"", ""wbr"", ""map"", ""q"",
+            ""var"", ""cite"", ""abbr"", ""time"", ""acronym"", ""mark"", ""ruby"", ""rt"", ""rp"", ""rtc"", ""a"", ""img"", ""br"", ""wbr"", ""map"", ""q"",
             ""sub"", ""sup"", ""bdo"", ""iframe"", ""embed"", ""span"", ""input"", ""select"", ""textarea"", ""label"", ""button"", ""optgroup"",
             ""option"", ""legend"", ""datalist"", ""keygen"", ""output"", ""progress"", ""meter"", ""area"", ""param"", ""source"", ""track"",
             ""summary"", ""command"", ""device"", ""area"", ""basefont"", ""bgsound"", ""menuitem"", ""param"", ""source"", ""track"",
"
jhy-jsoup-a90bae7928f9,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.CommentTest#stableIndentInBlock
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 <!-- comment --> Text
</div>
<p><!-- comment --> Text</p>> but was: <<div><!-- comment --> Text
</div>
<p><!-- comment --> Text</p>>

Test: org.jsoup.parser.HtmlParserTest#handlesXmlDeclAndCommentsBeforeDoctype
Type: org.opentest4j.AssertionFailedError
Message: expected: <<!--?xml version=""1.0"" encoding=""utf-8""?--><!-- so --> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""><!-- what --> <html xml:lang=""en"" lang=""en"" xmlns=""http://www.w3.org/1999/xhtml""> <!-- now --> <head> <!-- then --> <meta http-equiv=""Content-type"" content=""text/html; charset=utf-8""> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>> but was: <<!--?xml version=""1.0"" encoding=""utf-8""?--><!-- so --> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""><!-- what --> <html xml:lang=""en"" lang=""en"" xmlns=""http://www.w3.org/1999/xhtml""><!-- now --> <head><!-- then --> <meta http-equiv=""Content-type"" content=""text/html; charset=utf-8""> <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-a90bae7928f9:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Comment.java b/src/main/java/org/jsoup/nodes/Comment.java
index 8ac8f70..f7fc9f3 100644
--- a/src/main/java/org/jsoup/nodes/Comment.java
+++ b/src/main/java/org/jsoup/nodes/Comment.java
@@ -38,7 +38,7 @@ public class Comment extends LeafNode {
 
     @Override
 	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
-        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))
+        if (out.prettyPrint() && ((isEffectivelyFirst() && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))
             indent(accum, depth, out);
         accum
                 .append(""<!--"")
diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index 2432fef..ab1b748 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -1849,13 +1849,8 @@ public class Element extends Node {
     private boolean isInlineable(Document.OutputSettings out) {
         if (!tag.isInline())
             return false;
-
-        final Node prev = previousSibling();
-        boolean isFirst = siblingIndex == 0;
-        if (siblingIndex == 1 && prev instanceof TextNode && (((TextNode) prev).isBlank()))
-            isFirst = true;
         return (parent() == null || parent().isBlock())
-            && !isFirst
+            && !isEffectivelyFirst()
             && !out.outline();
     }
 }
diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java
index fc5ac3b..851bd8a 100644
--- a/src/main/java/org/jsoup/nodes/Node.java
+++ b/src/main/java/org/jsoup/nodes/Node.java
@@ -762,6 +762,16 @@ public abstract class Node implements Cloneable {
         return normalName().equals(normalName);
     }
 
+    /** Test if this node is the first child, or first following blank text. */
+    final boolean isEffectivelyFirst() {
+        if (siblingIndex == 0) return true;
+        if (siblingIndex == 1) {
+            final Node prev = previousSibling();
+            return prev instanceof TextNode && (((TextNode) prev).isBlank());
+        }
+        return false;
+    }
+
     /**
      * Gets this node's outer HTML.
      * @return outer HTML.
"
jhy-jsoup-2f48a617fe48,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#doesNotWrapBlocksInPre
Type: org.opentest4j.AssertionFailedError
Message: expected: <<pre><span><foo><div>TEST
 TEST</div></foo></span></pre>> but was: <<pre><span>
  <foo>
   <div>TEST
 TEST
   </div>
  </foo></span></pre>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-2f48a617fe48:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index ad3b022..2432fef 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -1670,7 +1670,7 @@ public class Element extends Node {
     }
 
     boolean shouldIndent(final Document.OutputSettings out) {
-        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out);
+        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out) && !preserveWhitespace(parentNode);
     }
 
     @Override
@@ -1701,7 +1701,8 @@ public class Element extends Node {
     void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {
             if (out.prettyPrint() && (!childNodes.isEmpty() && (
-                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))
+                (tag.formatAsBlock() && !preserveWhitespace(parentNode)) ||
+                    (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))
             )))
                 indent(accum, depth, out);
             accum.append(""</"").append(tagName()).append('>');
"
jhy-jsoup-111919256590,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#prettyprintBrWhenNotFirstChild
Type: org.opentest4j.AssertionFailedError
Message: expected: <<div>
 <p><br>
  Foo</p>
 <br>
</div>> but was: <<div>
 <p><br>
  Foo</p><br>
</div>>

Test: org.jsoup.parser.XmlTreeBuilderTest#testDoesNotForceSelfClosingKnownTags
Type: org.opentest4j.AssertionFailedError
Message: expected: <<br>
one
<br>> but was: <<br>
one<br>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-111919256590:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index ab1b748..5142fa2 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -1851,6 +1851,7 @@ public class Element extends Node {
             return false;
         return (parent() == null || parent().isBlock())
             && !isEffectivelyFirst()
-            && !out.outline();
+            && !out.outline()
+            && !isNode(""br"");
     }
 }
"
jhy-jsoup-0121311b1bd5,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.integration.ConnectTest#fetchUnicodeUrl
Type: org.opentest4j.AssertionFailedError
Message: expected: <%E9%8D%B5=%E5%80%A4> but was: <鍵=値>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-0121311b1bd5:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/UrlBuilder.java b/src/main/java/org/jsoup/helper/UrlBuilder.java
index c62d064..89f46a1 100644
--- a/src/main/java/org/jsoup/helper/UrlBuilder.java
+++ b/src/main/java/org/jsoup/helper/UrlBuilder.java
@@ -17,8 +17,8 @@ import static org.jsoup.helper.DataUtil.UTF_8;
 
 /**
  A utility class to normalize input URLs. jsoup internal; API subject to change.
- <p>Normalization includes puny-coding the host, and encoding non-ascii path components. The query-string
- is left mostly as-is, to avoid inadvertently/incorrectly decoding a desired '+' literal ('%2B') as a ' '.</p>
+ <p>Normalization includes puny-coding the host, and encoding non-ascii path components. Any non-ascii characters in
+ the query string (or the fragment/anchor) are escaped, but any existing escapes in those components are preserved.</p>
  */
 final class UrlBuilder {
     URL u;
@@ -47,19 +47,20 @@ final class UrlBuilder {
                 StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);
                 if (q != null) {
                     sb.append('?');
-                    sb.append(normalizeQuery(StringUtil.releaseBuilder(q)));
+                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);
                 }
                 if (u.getRef() != null) {
                     sb.append('#');
-                    sb.append(normalizeRef(u.getRef()));
+                    appendToAscii(u.getRef(), false, sb);
                 }
                 normUrl = StringUtil.releaseBuilder(sb);
             }
             u =  new URL(normUrl);
             return u;
-        } catch (MalformedURLException | URISyntaxException e) {
+        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {
             // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,
-            // the remote end will be able to handle it, so in prod we just pass the original URL
+            // the remote end will be able to handle it, so in prod we just pass the original URL.
+            // The UnsupportedEncodingException would never happen as always UTF8
             assert Validate.assertFail(e.toString());
             return u;
         }
@@ -84,14 +85,19 @@ final class UrlBuilder {
         }
     }
 
-    private static String normalizeQuery(String q) {
-        // minimal space normal; other characters left as supplied - if generated from jsoup data, will be encoded
-        return q.replace(' ', '+');
-    }
-
-    private static String normalizeRef(String r) {
-        // minimal space normal; other characters left as supplied
-        return r.replace("" "", ""%20"");
+    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {
+        // minimal normalization of Unicode -> Ascii, and space normal. Existing escapes are left as-is.
+        for (int i = 0; i < s.length(); i++) {
+            int c = s.codePointAt(i);
+            if (c == ' ') {
+                sb.append(spaceAsPlus ? '+' : ""%20"");
+            } else if (c > 127) { // out of ascii range
+                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));
+                // ^^ is a bit heavy-handed - if perf critical, we could optimize
+            } else {
+                sb.append((char) c);
+            }
+        }
     }
 
 
diff --git a/src/main/java/org/jsoup/internal/StringUtil.java b/src/main/java/org/jsoup/internal/StringUtil.java
index 73a589b..a24cad5 100644
--- a/src/main/java/org/jsoup/internal/StringUtil.java
+++ b/src/main/java/org/jsoup/internal/StringUtil.java
@@ -256,7 +256,7 @@ public final class StringUtil {
         final int len = haystack.length;
         for (int i = 0; i < len; i++) {
             if (haystack[i].equals(needle))
-            return true;
+               return true;
         }
         return false;
     }
"
jhy-jsoup-dea49696e976,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.parser.HtmlTreeBuilderStateTest#ensureArraysAreSorted
Type: org.opentest4j.AssertionFailedError
Message: expected: <39> but was: <38>

Test: org.jsoup.parser.HtmlParserTest#errorOnEofIfOpen
Type: org.opentest4j.AssertionFailedError
Message: expected: <1> but was: <0>

Test: org.jsoup.parser.HtmlParserTest#rubyScopeError
Type: org.opentest4j.AssertionFailedError
Message: expected: <2> but was: <1>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-dea49696e976:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 785643e..9de525b 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -301,9 +301,14 @@ public class HtmlTreeBuilder extends TreeBuilder {
         insertNode(comment, commentToken);
     }
 
+    /** Inserts the provided character token into the current element. */
     void insert(Token.Character characterToken) {
+        final Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)
+        insert(characterToken, el);
+    }
+
+    void insert(Token.Character characterToken, Element el) {
         final Node node;
-        Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)
         final String tagName = el.normalName();
         final String data = characterToken.getData();
 
@@ -317,6 +322,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
         onNodeInserted(node, characterToken);
     }
 
+    /** Inserts the provided character token into the provided element. Use when not going onto stack element */
     private void insertNode(Node node, @Nullable Token token) {
         // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc
         if (stack.isEmpty())
@@ -632,6 +638,20 @@ public class HtmlTreeBuilder extends TreeBuilder {
         return false;
     }
 
+    /** Tests if there is some element on the stack that is not in the provided set. */
+    boolean onStackNot(String[] allowedTags) {
+        final int bottom = stack.size() -1;
+        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;
+        // don't walk too far up the tree
+
+        for (int pos = bottom; pos >= top; pos--) {
+            final String elName = stack.get(pos).normalName();
+            if (!inSorted(elName, allowedTags))
+                return true;
+        }
+        return false;
+    }
+
     void setHeadElement(Element headElement) {
         this.headElement = headElement;
     }
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index baa16c4..99edf8c 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -310,7 +310,8 @@ enum HtmlTreeBuilderState {
                 case EOF:
                     if (tb.templateModeSize() > 0)
                         return tb.process(t, InTemplate);
-                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
+                    if (tb.onStackNot(InBodyEndOtherErrors))
+                        tb.error(this);
                     // stop parsing
                     break;
             }
@@ -726,16 +727,22 @@ enum HtmlTreeBuilderState {
                         tb.error(this);
                         return false;
                     } else {
-                        // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html
-                        anyOtherEndTag(t, tb);
+                        if (tb.onStackNot(InBodyEndOtherErrors))
+                            tb.error(this);
                         tb.transition(AfterBody);
                     }
                     break;
                 case ""html"":
-                    boolean notIgnored = tb.processEndTag(""body"");
-                    if (notIgnored)
-                        return tb.process(endTag);
-                    break;
+                    if (!tb.onStack(""body"")) {
+                        tb.error(this);
+                        return false; // ignore
+                    } else {
+                        if (tb.onStackNot(InBodyEndOtherErrors))
+                            tb.error(this);
+                        tb.transition(AfterBody);
+                        return tb.process(t); // re-process
+                    }
+
                 case ""form"":
                     if (!tb.onStack(""template"")) {
                         Element currentForm = tb.getFormElement();
@@ -1594,7 +1601,12 @@ enum HtmlTreeBuilderState {
     AfterBody {
         boolean process(Token t, HtmlTreeBuilder tb) {
             if (isWhitespace(t)) {
-                tb.insert(t.asCharacter()); // out of spec - include whitespace. spec would move into body
+                // spec deviation - currently body is still on stack, but we want this to go to the html node
+                Element html = tb.getFromStack(""html"");
+                if (html != null)
+                    tb.insert(t.asCharacter(), html);
+                else
+                    tb.process(t, InBody); // will get into body
             } else if (t.isComment()) {
                 tb.insert(t.asComment()); // into html node
             } else if (t.isDoctype()) {
@@ -1607,7 +1619,6 @@ enum HtmlTreeBuilderState {
                     tb.error(this);
                     return false;
                 } else {
-                    if (tb.onStack(""html"")) tb.popStackToClose(""html"");
                     tb.transition(AfterAfterBody);
                 }
             } else if (t.isEOF()) {
@@ -1699,7 +1710,9 @@ enum HtmlTreeBuilderState {
             } else if (t.isDoctype() || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
                 return tb.process(t, InBody);
             } else if (isWhitespace(t)) {
-                tb.insert(t.asCharacter());
+                // spec deviation - body and html still on stack, but want this space to go after </html>
+                Element doc = tb.getDocument();
+                tb.insert(t.asCharacter(), doc);
             }else if (t.isEOF()) {
                 // nice work chuck
             } else {
@@ -1786,6 +1799,7 @@ enum HtmlTreeBuilderState {
         static final String[] InBodyEndClosers = new String[]{""address"", ""article"", ""aside"", ""blockquote"", ""button"", ""center"", ""details"", ""dir"", ""div"",
             ""dl"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""header"", ""hgroup"", ""listing"", ""menu"",
             ""nav"", ""ol"", ""pre"", ""section"", ""summary"", ""ul""};
+        static final String[] InBodyEndOtherErrors = new String[] {""body"", ""dd"", ""dt"", ""html"", ""li"", ""optgroup"", ""option"", ""p"", ""rb"", ""rp"", ""rt"", ""rtc"", ""tbody"", ""td"", ""tfoot"", ""th"", ""thead"", ""tr""};
         static final String[] InBodyEndAdoptionFormatters = new String[]{""a"", ""b"", ""big"", ""code"", ""em"", ""font"", ""i"", ""nobr"", ""s"", ""small"", ""strike"", ""strong"", ""tt"", ""u""};
         static final String[] InBodyEndTableFosters = new String[]{""table"", ""tbody"", ""tfoot"", ""thead"", ""tr""};
         static final String[] InTableToBody = new String[]{""tbody"", ""tfoot"", ""thead""};
diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java
index 366bc63..97ed500 100644
--- a/src/main/java/org/jsoup/parser/Tag.java
+++ b/src/main/java/org/jsoup/parser/Tag.java
@@ -246,7 +246,8 @@ public class Tag implements Cloneable {
             ""sub"", ""sup"", ""bdo"", ""iframe"", ""embed"", ""span"", ""input"", ""select"", ""textarea"", ""label"", ""button"", ""optgroup"",
             ""option"", ""legend"", ""datalist"", ""keygen"", ""output"", ""progress"", ""meter"", ""area"", ""param"", ""source"", ""track"",
             ""summary"", ""command"", ""device"", ""area"", ""basefont"", ""bgsound"", ""menuitem"", ""param"", ""source"", ""track"",
-            ""data"", ""bdi"", ""s"", ""strike"", ""nobr""
+            ""data"", ""bdi"", ""s"", ""strike"", ""nobr"",
+            ""rb"" // deprecated but still known / special handling
     };
     private static final String[] emptyTags = {
             ""meta"", ""link"", ""base"", ""frame"", ""img"", ""br"", ""wbr"", ""embed"", ""hr"", ""input"", ""keygen"", ""col"", ""command"",
"
jhy-jsoup-c93ea51dabfb,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.PositionTest#tracksTableMovedText
Type: org.opentest4j.AssertionFailedError
Message: expected: <1,8:7-1,11:10> but was: <1,1:0-1,0:-1>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-c93ea51dabfb:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 9de525b..06e9c74 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -53,7 +53,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     private @Nullable Element contextElement; // fragment parse context -- could be null even if fragment parsing
     private ArrayList<Element> formattingElements; // active (open) formatting elements
     private ArrayList<HtmlTreeBuilderState> tmplInsertMode; // stack of Template Insertion modes
-    private List<String> pendingTableCharacters; // chars in table to be shifted out
+    private List<Token.Character> pendingTableCharacters; // chars in table to be shifted out
     private Token.EndTag emptyEnd; // reused empty end tag
 
     private boolean framesetOk; // if ok to go into frameset
@@ -676,14 +676,20 @@ public class HtmlTreeBuilder extends TreeBuilder {
         this.formElement = formElement;
     }
 
-    void newPendingTableCharacters() {
+    void resetPendingTableCharacters() {
         pendingTableCharacters = new ArrayList<>();
     }
 
-    List<String> getPendingTableCharacters() {
+    List<Token.Character> getPendingTableCharacters() {
         return pendingTableCharacters;
     }
 
+    void addPendingTableCharacters(Token.Character c) {
+        // make a clone of the token to maintain its state (as Tokens are otherwise reset)
+        Token.Character clone = c.clone();
+        pendingTableCharacters.add(clone);
+    }
+
     /**
      13.2.6.3 Closing elements that have implied end tags
      When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index 99edf8c..3c5352e 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -6,7 +6,6 @@ import org.jsoup.nodes.Attributes;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.DocumentType;
 import org.jsoup.nodes.Element;
-import org.jsoup.nodes.Node;
 
 import java.util.ArrayList;
 
@@ -995,7 +994,7 @@ enum HtmlTreeBuilderState {
     InTable {
         boolean process(Token t, HtmlTreeBuilder tb) {
             if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
-                tb.newPendingTableCharacters();
+                tb.resetPendingTableCharacters();
                 tb.markInsertionMode();
                 tb.transition(InTableText);
                 return tb.process(t);
@@ -1106,25 +1105,25 @@ enum HtmlTreeBuilderState {
                     tb.error(this);
                     return false;
                 } else {
-                    tb.getPendingTableCharacters().add(c.getData());
+                    tb.addPendingTableCharacters(c);
                 }
-            } else {// todo - don't really like the way these table character data lists are built
+            } else {
                 if (tb.getPendingTableCharacters().size() > 0) {
-                    for (String character : tb.getPendingTableCharacters()) {
-                        if (!isWhitespace(character)) {
+                    for (Token.Character c : tb.getPendingTableCharacters()) {
+                        if (!isWhitespace(c)) {
                             // InTable anything else section:
                             tb.error(this);
                             if (inSorted(tb.currentElement().normalName(), InTableFoster)) {
                                 tb.setFosterInserts(true);
-                                tb.process(new Token.Character().data(character), InBody);
+                                tb.process(c, InBody);
                                 tb.setFosterInserts(false);
                             } else {
-                                tb.process(new Token.Character().data(character), InBody);
+                                tb.process(c, InBody);
                             }
                         } else
-                            tb.insert(new Token.Character().data(character));
+                            tb.insert(c);
                     }
-                    tb.newPendingTableCharacters();
+                    tb.resetPendingTableCharacters();
                 }
                 tb.transition(tb.originalState());
                 return tb.process(t);
@@ -1759,10 +1758,6 @@ enum HtmlTreeBuilderState {
         return false;
     }
 
-    private static boolean isWhitespace(String data) {
-        return StringUtil.isBlank(data);
-    }
-
     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {
         tb.tokeniser.transition(TokeniserState.Rcdata);
         tb.markInsertionMode();
diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java
index 819b8ae..b0fc0af 100644
--- a/src/main/java/org/jsoup/parser/Token.java
+++ b/src/main/java/org/jsoup/parser/Token.java
@@ -382,7 +382,7 @@ abstract class Token {
         }
     }
 
-    static class Character extends Token {
+    static class Character extends Token implements Cloneable {
         private String data;
 
         Character() {
@@ -410,6 +410,14 @@ abstract class Token {
         public String toString() {
             return getData();
         }
+
+        @Override protected Token.Character clone() {
+            try {
+                return (Token.Character) super.clone();
+            } catch (CloneNotSupportedException e) {
+                throw new RuntimeException(e);
+            }
+        }
     }
 
     final static class CData extends Character {
"
jhy-jsoup-f0ae81b13eb3,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.parser.HtmlParserTest#largeTextareaContents
Type: org.opentest4j.AssertionFailedError
Message: expected: <
<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>

<text>foo</text>
> but was: <
>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-f0ae81b13eb3:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java
index df902b1..1d00ec6 100644
--- a/src/main/java/org/jsoup/parser/CharacterReader.java
+++ b/src/main/java/org/jsoup/parser/CharacterReader.java
@@ -116,6 +116,11 @@ public final class CharacterReader {
         return readerPos + bufPos;
     }
 
+    /** Tests if the buffer has been fully read. */
+    boolean readFully() {
+        return readFully;
+    }
+
     /**
      Enables or disables line number tracking. By default, will be <b>off</b>.Tracking line numbers improves the
      legibility of parser error messages, for example. Tracking should be enabled before any content is read to be of
diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java
index 874fed0..f269fc6 100644
--- a/src/main/java/org/jsoup/parser/TokeniserState.java
+++ b/src/main/java/org/jsoup/parser/TokeniserState.java
@@ -186,7 +186,7 @@ enum TokeniserState {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
-            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
+            } else if (r.readFully() && r.matchesAsciiAlpha() && t.appropriateEndTagName() != null &&  !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());
"
jhy-jsoup-8e2b86839b27,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.ElementTest#nestedFormatAsInlinePrintsAsBlock
Type: org.opentest4j.AssertionFailedError
Message: expected: <<table>
 <tbody>
  <tr>
   <td>
    <p style=""display:inline;"">A</p>
    <p style=""display:inline;"">B</p></td>
  </tr>
 </tbody>
</table>> but was: <<table>
 <tbody>
  <tr>
   <td><p style=""display:inline;"">A</p><p style=""display:inline;"">B</p></td>
  </tr>
 </tbody>
</table>>

Test: org.jsoup.parser.HtmlParserTest#handlesUnclosedTitle
Type: org.opentest4j.AssertionFailedError
Message: expected: <<b>Two 
 <p>Test</p></b>> but was: <<b>Two <p>Test</p></b>>

Test: org.jsoup.parser.HtmlParserTest#nestedPFragments
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>
 <p></p><a></a></p>> but was: <<p><p></p><a></a></p>>

Test: org.jsoup.parser.HtmlParserTest#parseFragmentOnCreatedDocument
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p>
 <h2>text</h2></p>> but was: <<p><h2>text</h2></p>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-8e2b86839b27:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index 8b27637..05ee2e7 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -1844,7 +1844,7 @@ public class Element extends Node {
     }
 
     private boolean isFormatAsBlock(Document.OutputSettings out) {
-        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();
+        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();
     }
 
     private boolean isInlineable(Document.OutputSettings out) {
"
jhy-jsoup-4a278e9b8e9c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.W3CDomTest#testRoundTripDoctype
Type: org.opentest4j.AssertionFailedError
Message: expected: <<!doctype html system ""about:legacy-compat""><html xmlns=""http://www.w3.org/1999/xhtml""><head><meta http-equiv=""content-type"" content=""text/html; charset=utf-8""></head><body><p>one</p></body></html>> but was: <<!doctype html system ""about:legacy-compat""><html><head><meta http-equiv=""content-type"" content=""text/html; charset=utf-8""></head><body><p>one</p></body></html>>

Test: org.jsoup.helper.W3CDomTest#simpleConversion
Type: org.opentest4j.AssertionFailedError
Message: expected: <<?xml version=""1.0"" encoding=""UTF-8""?><html xmlns=""http://www.w3.org/1999/xhtml""><head><title>W3c</title></head><body><p class=""one"" id=""12"">Text</p><!-- comment --><invalid>What<script>alert('!')</script></invalid></body></html>> but was: <<?xml version=""1.0"" encoding=""UTF-8""?><html><head><title>W3c</title></head><body><p class=""one"" id=""12"">Text</p><!-- comment --><invalid>What<script>alert('!')</script></invalid></body></html>>

Test: org.jsoup.helper.W3CDomTest#xmlInputDocMaintainsHtmlAttributeNames
Type: org.opentest4j.AssertionFailedError
Message: expected: <<!DOCTYPE html SYSTEM ""about:legacy-compat""><html xmlns=""http://www.w3.org/1999/xhtml""><head><META http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""></head><body><p hnh=""2"">unicode attr names coerced</p></body></html>> but was: <<!DOCTYPE html SYSTEM ""about:legacy-compat""><html><head><META http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""></head><body><p hnh=""2"">unicode attr names coerced</p></body></html>>

Test: org.jsoup.helper.W3CDomTest#htmlInputDocMaintainsHtmlAttributeNames
Type: org.opentest4j.AssertionFailedError
Message: expected: <<!DOCTYPE html SYSTEM ""about:legacy-compat""><html xmlns=""http://www.w3.org/1999/xhtml""><head><META http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""></head><body><p hành=""1"" hình=""2"">unicode attr names</p></body></html>> but was: <<!DOCTYPE html SYSTEM ""about:legacy-compat""><html><head><META http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""></head><body><p hành=""1"" hình=""2"">unicode attr names</p></body></html>>

Test: org.jsoup.helper.W3CDomTest#treatsUndeclaredNamespaceAsLocalName
Type: org.opentest4j.AssertionFailedError
Message: expected: <http://www.w3.org/1999/xhtml> but was: <null>

Test: org.jsoup.helper.W3CDomTest#handlesInvalidAttributeNames
Type: org.opentest4j.AssertionFailedError
Message: expected: <<?xml version=""1.0"" encoding=""UTF-8""?><html xmlns=""http://www.w3.org/1999/xhtml""><head/><body name="""" style=""color: red""/></html>> but was: <<?xml version=""1.0"" encoding=""UTF-8""?><html><head/><body name="""" style=""color: red""/></html>>

Test: org.jsoup.helper.W3CDomTest#handlesInvalidTagAsText
Type: org.opentest4j.AssertionFailedError
Message: expected: <<?xml version=""1.0"" encoding=""UTF-8""?><html xmlns=""http://www.w3.org/1999/xhtml""><head/><body>&lt;インセンティブで高収入！&gt;Text <p>More</p></body></html>> but was: <<?xml version=""1.0"" encoding=""UTF-8""?><html><head/><body>&lt;インセンティブで高収入！&gt;Text <p>More</p></body></html>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-4a278e9b8e9c:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java
index 8caf31f..29296b1 100644
--- a/src/main/java/org/jsoup/helper/W3CDom.java
+++ b/src/main/java/org/jsoup/helper/W3CDom.java
@@ -3,6 +3,7 @@ package org.jsoup.helper;
 import org.jsoup.internal.StringUtil;
 import org.jsoup.nodes.Attribute;
 import org.jsoup.nodes.Attributes;
+import org.jsoup.parser.HtmlTreeBuilder;
 import org.jsoup.select.NodeTraversor;
 import org.jsoup.select.NodeVisitor;
 import org.jsoup.select.Selector;
@@ -77,6 +78,8 @@ public class W3CDom {
 
     /**
      Update the namespace aware setting. This impacts the factory that is used to create W3C nodes from jsoup nodes.
+     <p>For HTML documents, controls if the document will be in the default {@code http://www.w3.org/1999/xhtml}
+     namespace if otherwise unset.</p>.
      @param namespaceAware the updated setting
      @return this W3CDom, for chaining.
      */
@@ -337,6 +340,7 @@ public class W3CDom {
     protected static class W3CBuilder implements NodeVisitor {
         private static final String xmlnsKey = ""xmlns"";
         private static final String xmlnsPrefix = ""xmlns:"";
+        private static final String xhtmlNs = ""http://www.w3.org/1999/xhtml"";
 
         private final Document doc;
         private boolean namespaceAware = true;
@@ -350,7 +354,12 @@ public class W3CDom {
             namespacesStack.push(new HashMap<>());
             dest = doc;
             contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element
-        }
+            final org.jsoup.nodes.Document inDoc = contextElement.ownerDocument();
+            if (namespaceAware && inDoc != null && inDoc.parser().getTreeBuilder() instanceof HtmlTreeBuilder) {
+              // as per the WHATWG HTML5 spec § 2.1.3, elements are in the HTML namespace by default
+              namespacesStack.peek().put("""", xhtmlNs);
+            }
+          }
 
         public void head(org.jsoup.nodes.Node source, int depth) {
             namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack
@@ -366,9 +375,9 @@ public class W3CDom {
                 tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be
                 how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */
                 try {
-                    Element el = namespace == null && tagName.contains("":"") ?
-                        doc.createElementNS("""", tagName) : // doesn't have a real namespace defined
-                        doc.createElementNS(namespace, tagName);
+                    // use an empty namespace if none is present but the tag name has a prefix
+                    String imputedNamespace = namespace == null && tagName.contains("":"") ? """" : namespace;
+                    Element el = doc.createElementNS(imputedNamespace, tagName);
                     copyAttributes(sourceEl, el);
                     append(el, sourceEl);
                     if (sourceEl == contextElement)
"
jhy-jsoup-401c8b010e01,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.parser.HtmlParserTest#dropsDuplicateAttributes(String, String)[2]
Type: org.opentest4j.AssertionFailedError
Message: expected: <<img one=""One"" two=""two"">> but was: <<img one=""One"" one=""Two"" two=""two"" one=""Three"" one=""Four"" two=""Five"">>

Test: org.jsoup.parser.HtmlParserTest#dropsDuplicateAttributes(String, String)[3]
Type: org.opentest4j.AssertionFailedError
Message: expected: <<form one=""One"" two=""two""></form>> but was: <<form one=""One"" one=""Two"" two=""two"" one=""Three"" one=""Four"" two=""Five""></form>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-401c8b010e01:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 06e9c74..be0498c 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -10,6 +10,7 @@ import org.jsoup.nodes.Element;
 import org.jsoup.nodes.FormElement;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
+import org.jsoup.parser.Token.StartTag;
 
 import javax.annotation.Nullable;
 import javax.annotation.ParametersAreNonnullByDefault;
@@ -227,13 +228,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     Element insert(final Token.StartTag startTag) {
-        // cleanup duplicate attributes:
-        if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
-            int dupes = startTag.attributes.deduplicate(settings);
-            if (dupes > 0) {
-                error(""Dropped duplicate attribute(s) in tag [%s]"", startTag.normalName);
-            }
-        }
+        dedupeAttributes(startTag);
 
         // handle empty unknown tags
         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
@@ -250,7 +245,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
         return el;
     }
 
-    Element insertStartTag(String startTagName) {
+	Element insertStartTag(String startTagName) {
         Element el = new Element(tagFor(startTagName, settings), null);
         insert(el);
         return el;
@@ -267,6 +262,8 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     Element insertEmpty(Token.StartTag startTag) {
+        dedupeAttributes(startTag);
+
         Tag tag = tagFor(startTag.name(), settings);
         Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));
         insertNode(el, startTag);
@@ -282,6 +279,8 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     FormElement insertForm(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {
+        dedupeAttributes(startTag);
+
         Tag tag = tagFor(startTag.name(), settings);
         FormElement el = new FormElement(tag, null, settings.normalizeAttributes(startTag.attributes));
         if (checkTemplateStack) {
@@ -340,6 +339,16 @@ public class HtmlTreeBuilder extends TreeBuilder {
         onNodeInserted(node, token);
     }
 
+    /** Cleanup duplicate attributes. **/
+    private void dedupeAttributes(StartTag startTag) {
+        if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
+            int dupes = startTag.attributes.deduplicate(settings);
+            if (dupes > 0) {
+                error(""Dropped duplicate attribute(s) in tag [%s]"", startTag.normalName);
+            }
+        }
+    }
+
     Element pop() {
         int size = stack.size();
         return stack.remove(size-1);
"
jhy-jsoup-1e69577e358c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.HttpConnectionTest#encodedUrlPathIsPreserved
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://example.com/%2B32> but was: <https://example.com/+32>

Test: org.jsoup.helper.HttpConnectionTest#urlPathPlusIsPreserved
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://example.com/123+456> but was: <https://example.com/123%20456>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-1e69577e358c:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/UrlBuilder.java b/src/main/java/org/jsoup/helper/UrlBuilder.java
index 89f46a1..4deda36 100644
--- a/src/main/java/org/jsoup/helper/UrlBuilder.java
+++ b/src/main/java/org/jsoup/helper/UrlBuilder.java
@@ -38,24 +38,20 @@ final class UrlBuilder {
                 u.getUserInfo(),
                 IDN.toASCII(decodePart(u.getHost())), // puny-code
                 u.getPort(),
-                decodePart(u.getPath()),
-                null, null // query and fragment appended later so as not to encode
+                null, null, null // path, query and fragment appended later so as not to encode
             );
 
-            String normUrl = uri.toASCIIString();
-            if (q != null || u.getRef() != null) {
-                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);
-                if (q != null) {
-                    sb.append('?');
-                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);
-                }
-                if (u.getRef() != null) {
-                    sb.append('#');
-                    appendToAscii(u.getRef(), false, sb);
-                }
-                normUrl = StringUtil.releaseBuilder(sb);
+            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());
+            appendToAscii(u.getPath(), false, normUrl);
+            if (q != null) {
+                normUrl.append('?');
+                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);
             }
-            u =  new URL(normUrl);
+            if (u.getRef() != null) {
+                normUrl.append('#');
+                appendToAscii(u.getRef(), false, normUrl);
+            }
+            u = new URL(StringUtil.releaseBuilder(normUrl));
             return u;
         } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {
             // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,
"
jhy-jsoup-8e8970650951,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.EntitiesTest#escapeByClonedOutputSettings
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception thrown: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-8e8970650951:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java
index 70c571f..9930dc5 100644
--- a/src/main/java/org/jsoup/nodes/Document.java
+++ b/src/main/java/org/jsoup/nodes/Document.java
@@ -385,9 +385,9 @@ public class Document extends Element {
         public enum Syntax {html, xml}
 
         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
-        private Charset charset = DataUtil.UTF_8;
+        private Charset charset;
+        Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8
         private final ThreadLocal<CharsetEncoder> encoderThreadLocal = new ThreadLocal<>(); // initialized by start of OuterHtmlVisitor
-        @Nullable Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8
 
         private boolean prettyPrint = true;
         private boolean outline = false;
@@ -395,7 +395,9 @@ public class Document extends Element {
         private int maxPaddingWidth = 30;
         private Syntax syntax = Syntax.html;
 
-        public OutputSettings() {}
+        public OutputSettings() {
+            charset(DataUtil.UTF_8);
+        }
         
         /**
          * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML
@@ -439,6 +441,7 @@ public class Document extends Element {
          */
         public OutputSettings charset(Charset charset) {
             this.charset = charset;
+            coreCharset = Entities.CoreCharset.byName(charset.name());
             return this;
         }
 
@@ -456,7 +459,6 @@ public class Document extends Element {
             // created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads
             CharsetEncoder encoder = charset.newEncoder();
             encoderThreadLocal.set(encoder);
-            coreCharset = Entities.CoreCharset.byName(encoder.charset().name());
             return encoder;
         }
 
@@ -570,7 +572,7 @@ public class Document extends Element {
             } catch (CloneNotSupportedException e) {
                 throw new RuntimeException(e);
             }
-            clone.charset(charset.name()); // new charset and charset encoder
+            clone.charset(charset.name()); // new charset, coreCharset, and charset encoder
             clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());
             // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle
             return clone;
"
jhy-jsoup-91b630f86b5c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.nodes.AttributesTest#testIteratorRemoveConcurrentException
Type: org.opentest4j.AssertionFailedError
Message: expected: <1> but was: <2>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-91b630f86b5c:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java
index 76b6590..f246952 100644
--- a/src/main/java/org/jsoup/nodes/Attributes.java
+++ b/src/main/java/org/jsoup/nodes/Attributes.java
@@ -12,6 +12,7 @@ import java.util.AbstractSet;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -320,10 +321,12 @@ public class Attributes implements Iterable<Attribute>, Cloneable {
 
     public Iterator<Attribute> iterator() {
         return new Iterator<Attribute>() {
+            int expectedSize = size;
             int i = 0;
 
             @Override
             public boolean hasNext() {
+                checkModified();
                 while (i < size) {
                     if (isInternalKey(keys[i])) // skip over internal keys
                         i++;
@@ -336,14 +339,20 @@ public class Attributes implements Iterable<Attribute>, Cloneable {
 
             @Override
             public Attribute next() {
+                checkModified();
                 final Attribute attr = new Attribute(keys[i], (String) vals[i], Attributes.this);
                 i++;
                 return attr;
             }
 
+            private void checkModified() {
+                if (size != expectedSize) throw new ConcurrentModificationException(""Use Iterator#remove() instead to remove attributes while iterating."");
+            }
+
             @Override
             public void remove() {
                 Attributes.this.remove(--i); // next() advanced, so rewind
+                expectedSize--;
             }
         };
     }
"
jhy-jsoup-5f20fcc2f728,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.safety.SafelistTest#noscriptIsBlocked
Type: org.opentest4j.AssertionFailedError
Message: expected: <true> but was: <false>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-5f20fcc2f728:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/safety/Safelist.java b/src/main/java/org/jsoup/safety/Safelist.java
index 710c070..75e80b8 100644
--- a/src/main/java/org/jsoup/safety/Safelist.java
+++ b/src/main/java/org/jsoup/safety/Safelist.java
@@ -248,6 +248,8 @@ public class Safelist {
 
         for (String tagName : tags) {
             Validate.notEmpty(tagName);
+            Validate.isFalse(tagName.equalsIgnoreCase(""noscript""),
+                ""noscript is unsupported in Safelists, due to incompatibilities between parsers with and without script-mode enabled"");
             tagNames.add(TagName.valueOf(tagName));
         }
         return this;
"
jhy-jsoup-9de27fa7cd82,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.HttpConnectionTest#setHeaderWithUnicodeValue
Type: org.opentest4j.AssertionFailedError
Message: expected: </foo/我的> but was: </foo/??>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-9de27fa7cd82:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/Connection.java b/src/main/java/org/jsoup/Connection.java
index 4e279a9..f422deb 100644
--- a/src/main/java/org/jsoup/Connection.java
+++ b/src/main/java/org/jsoup/Connection.java
@@ -412,11 +412,11 @@ public interface Connection {
 
         /**
          * Get the value of a header. If there is more than one header value with the same name, the headers are returned
-         * comma seperated, per <a href=""https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2"">rfc2616-sec4</a>.
+         * comma separated, per <a href=""https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2"">rfc2616-sec4</a>.
          * <p>
-         * Header names are case insensitive.
+         * Header names are case-insensitive.
          * </p>
-         * @param name name of header (case insensitive)
+         * @param name name of header (case-insensitive)
          * @return value of header, or null if not set.
          * @see #hasHeader(String)
          * @see #cookie(String)
@@ -425,14 +425,16 @@ public interface Connection {
 
         /**
          * Get the values of a header.
-         * @param name header name, case insensitive.
+         * @param name header name, case-insensitive.
          * @return a list of values for this header, or an empty list if not set.
          */
         List<String> headers(String name);
 
         /**
-         * Set a header. This method will overwrite any existing header with the same case insensitive name. (If there
+         * Set a header. This method will overwrite any existing header with the same case-insensitive name. If there
          * is more than one value for this header, this method will update the first matching header.
+         * <p>For compatibility, if the content of the header includes text that cannot be represented by ISO-8859-1,
+         * then it should be encoded first per <a href=""https://www.ietf.org/rfc/rfc2047.txt"">RFC 2047</a>.</p>
          * @param name Name of header
          * @param value Value of header
          * @return this, for chaining
@@ -442,6 +444,8 @@ public interface Connection {
 
         /**
          * Add a header. The header will be added regardless of whether a header with the same name already exists.
+         * <p>For compatibility, if the content of the header includes text that cannot be represented by ISO-8859-1,
+         * then it should be encoded first per <a href=""https://www.ietf.org/rfc/rfc2047.txt"">RFC 2047</a>.</p>
          * @param name Name of new header
          * @param value Value of new header
          * @return this, for chaining
@@ -450,22 +454,22 @@ public interface Connection {
 
         /**
          * Check if a header is present
-         * @param name name of header (case insensitive)
+         * @param name name of header (case-insensitive)
          * @return if the header is present in this request/response
          */
         boolean hasHeader(String name);
 
         /**
          * Check if a header is present, with the given value
-         * @param name header name (case insensitive)
-         * @param value value (case insensitive)
+         * @param name header name (case-insensitive)
+         * @param value value (case-insensitive)
          * @return if the header and value pair are set in this req/res
          */
         boolean hasHeaderWithValue(String name, String value);
 
         /**
          * Remove headers by name. If there is more than one header with this name, they will all be removed.
-         * @param name name of header to remove (case insensitive)
+         * @param name name of header to remove (case-insensitive)
          * @return this, for chaining
          */
         T removeHeader(String name);
diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java
index d87c9f4..af7a18a 100644
--- a/src/main/java/org/jsoup/helper/HttpConnection.java
+++ b/src/main/java/org/jsoup/helper/HttpConnection.java
@@ -448,7 +448,7 @@ public class HttpConnection implements Connection {
         }
 
         @Override
-        public T addHeader(String name, String value) {
+        public T addHeader(String name, @Nullable String value) {
             Validate.notEmptyParam(name, ""name"");
             //noinspection ConstantConditions
             value = value == null ? """" : value;
@@ -458,7 +458,7 @@ public class HttpConnection implements Connection {
                 values = new ArrayList<>();
                 headers.put(name, values);
             }
-            values.add(fixHeaderEncoding(value));
+            values.add(value);
 
             return (T) this;
         }
@@ -469,55 +469,6 @@ public class HttpConnection implements Connection {
             return getHeadersCaseInsensitive(name);
         }
 
-        private static String fixHeaderEncoding(String val) {
-            byte[] bytes = val.getBytes(ISO_8859_1);
-            if (!looksLikeUtf8(bytes))
-                return val;
-            return new String(bytes, UTF_8);
-        }
-
-        private static boolean looksLikeUtf8(byte[] input) {
-            int i = 0;
-            // BOM:
-            if (input.length >= 3
-                && (input[0] & 0xFF) == 0xEF
-                && (input[1] & 0xFF) == 0xBB
-                && (input[2] & 0xFF) == 0xBF) {
-                i = 3;
-            }
-
-            int end;
-            for (int j = input.length; i < j; ++i) {
-                int o = input[i];
-                if ((o & 0x80) == 0) {
-                    continue; // ASCII
-                }
-
-                // UTF-8 leading:
-                if ((o & 0xE0) == 0xC0) {
-                    end = i + 1;
-                } else if ((o & 0xF0) == 0xE0) {
-                    end = i + 2;
-                } else if ((o & 0xF8) == 0xF0) {
-                    end = i + 3;
-                } else {
-                    return false;
-                }
-
-                if (end >= input.length)
-                    return false;
-
-                while (i < end) {
-                    i++;
-                    o = input[i];
-                    if ((o & 0xC0) != 0x80) {
-                        return false;
-                    }
-                }
-            }
-            return true;
-        }
-
         @Override
         public T header(String name, String value) {
             Validate.notEmptyParam(name, ""name"");
@@ -1162,9 +1113,67 @@ public class HttpConnection implements Connection {
                     }
                 }
                 for (String value : values) {
-                    addHeader(name, value);
+                    addHeader(name, fixHeaderEncoding(value));
+                }
+            }
+        }
+
+        /**
+         Servers may encode response headers in UTF-8 instead of RFC defined 8859. This method attempts to detect that
+         and re-decode the string as UTF-8.
+         * @param val a header value string that may have been incorrectly decoded as 8859.
+         * @return a potentially re-decoded string.
+         */
+        @Nullable
+        private static String fixHeaderEncoding(@Nullable String val) {
+            if (val == null) return val;
+            byte[] bytes = val.getBytes(ISO_8859_1);
+            if (looksLikeUtf8(bytes))
+                return new String(bytes, UTF_8);
+            else
+                return val;
+        }
+
+        private static boolean looksLikeUtf8(byte[] input) {
+            int i = 0;
+            // BOM:
+            if (input.length >= 3
+                && (input[0] & 0xFF) == 0xEF
+                && (input[1] & 0xFF) == 0xBB
+                && (input[2] & 0xFF) == 0xBF) {
+                i = 3;
+            }
+
+            int end;
+            for (int j = input.length; i < j; ++i) {
+                int o = input[i];
+                if ((o & 0x80) == 0) {
+                    continue; // ASCII
+                }
+
+                // UTF-8 leading:
+                if ((o & 0xE0) == 0xC0) {
+                    end = i + 1;
+                } else if ((o & 0xF0) == 0xE0) {
+                    end = i + 2;
+                } else if ((o & 0xF8) == 0xF0) {
+                    end = i + 3;
+                } else {
+                    return false;
+                }
+
+                if (end >= input.length)
+                    return false;
+
+                while (i < end) {
+                    i++;
+                    o = input[i];
+                    if ((o & 0xC0) != 0x80) {
+                        return false;
+                    }
                 }
             }
+            return true;
         }
 
         private @Nullable static String setOutputContentType(final Connection.Request req) {
"
jhy-jsoup-6ccd158754e2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.HttpConnectionTest#encodeUrlSupplementary
Type: org.opentest4j.AssertionFailedError
Message: expected: <https://example.com/tools/test%F0%9F%92%A9.html> but was: <https://example.com/tools/test%F0%9F%92%A9%3F.html>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-6ccd158754e2:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/helper/UrlBuilder.java b/src/main/java/org/jsoup/helper/UrlBuilder.java
index 4deda36..3ef9c56 100644
--- a/src/main/java/org/jsoup/helper/UrlBuilder.java
+++ b/src/main/java/org/jsoup/helper/UrlBuilder.java
@@ -90,6 +90,7 @@ final class UrlBuilder {
             } else if (c > 127) { // out of ascii range
                 sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));
                 // ^^ is a bit heavy-handed - if perf critical, we could optimize
+                if (Character.charCount(c) == 2) i++; // advance past supplemental
             } else {
                 sb.append((char) c);
             }
"
jhy-jsoup-1657e8fd6588,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.helper.W3CDomTest#canXmlParseCdataNodes
Type: org.opentest4j.AssertionFailedError
Message: expected: <true> but was: <false>

Test: org.jsoup.nodes.ElementTest#datanodesOutputCdataInXhtml
Type: org.opentest4j.AssertionFailedError
Message: expected: <<p><script><![CDATA[1 && 2]]></script><style><![CDATA[3 && 4]]></style> 5 &amp;&amp; 6</p>> but was: <<p><script>1 && 2</script><style>3 && 4</style> 5 &amp;&amp; 6</p>>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-1657e8fd6588:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/nodes/DataNode.java b/src/main/java/org/jsoup/nodes/DataNode.java
index 65ae7a3..4a0cf43 100644
--- a/src/main/java/org/jsoup/nodes/DataNode.java
+++ b/src/main/java/org/jsoup/nodes/DataNode.java
@@ -1,6 +1,7 @@
 package org.jsoup.nodes;
 
 import java.io.IOException;
+import org.jsoup.nodes.Entities.EscapeMode;
 
 /**
  A data node, for contents of style, script tags etc, where contents should not show in text().
@@ -40,7 +41,16 @@ public class DataNode extends LeafNode {
 
     @Override
     void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
-        accum.append(getWholeData()); // data is not escaped in return from data nodes, so "" in script, style is plain
+        if (out.syntax() == Document.OutputSettings.Syntax.xml) {
+            // In XML mode, output data nodes as CDATA, so can parse as XML
+            accum
+                .append(""<![CDATA["")
+                .append(getWholeData())
+                .append(""]]>"");
+        } else {
+            // In HTML, data is not escaped in return from data nodes, so "" in script, style is plain
+            accum.append(getWholeData());
+        }
     }
 
     @Override
"
jhy-jsoup-2a4a9cf83dea,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.select.SelectorTest#parentFromSpecifiedDescender
Type: org.opentest4j.AssertionFailedError
Message: expected: <2> but was: <3>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-2a4a9cf83dea:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/select/StructuralEvaluator.java b/src/main/java/org/jsoup/select/StructuralEvaluator.java
index 96ff252..560ffbc 100644
--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java
+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java
@@ -189,7 +189,9 @@ abstract class StructuralEvaluator extends Evaluator {
 
         @Override
         public boolean matches(Element root, Element element) {
-            // evaluate from last to first
+            if (element == root)
+                return false; // cannot match as the second eval (first parent test) would be above the root
+
             for (int i = evaluators.size() -1; i >= 0; --i) {
                 if (element == null)
                     return false;
"
jhy-jsoup-d126488db626,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.jsoup.select.QueryParserTest#testConsumeSubQuery
Type: org.opentest4j.AssertionFailedError
Message: expected: <l1 yes> but was: <l1 l2 yes>

Test: org.jsoup.select.SelectorTest#rootImmediateParentSubquery
Type: org.opentest4j.AssertionFailedError
Message: expected: <2> but was: <3>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.jhy-jsoup-d126488db626:msbench-0.0.1,"diff --git a/src/main/java/org/jsoup/select/QueryParser.java b/src/main/java/org/jsoup/select/QueryParser.java
index 09f53bd..30872eb 100644
--- a/src/main/java/org/jsoup/select/QueryParser.java
+++ b/src/main/java/org/jsoup/select/QueryParser.java
@@ -145,18 +145,21 @@ public class QueryParser {
 
     private String consumeSubQuery() {
         StringBuilder sq = StringUtil.borrowBuilder();
+        boolean seenNonCombinator = false; // eat until we hit a combinator after eating something else
         while (!tq.isEmpty()) {
             if (tq.matches(""(""))
                 sq.append(""("").append(tq.chompBalanced('(', ')')).append("")"");
             else if (tq.matches(""[""))
                 sq.append(""["").append(tq.chompBalanced('[', ']')).append(""]"");
             else if (tq.matchesAny(Combinators))
-                if (sq.length() > 0)
+                if (seenNonCombinator)
                     break;
                 else
-                    tq.consume();
-            else
+                    sq.append(tq.consume());
+            else {
+                seenNonCombinator = true;
                 sq.append(tq.consume());
+            }
         }
         return StringUtil.releaseBuilder(sq);
     }
"
klausbrunner-solarpositioning-79c0044373b4,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: net.e175.klaus.solarpositioning.Grena3Test#testSillyLatLon
Type: org.opentest4j.AssertionFailedError
Message: Expected java.lang.IllegalArgumentException to be thrown, but nothing was thrown.

Test: net.e175.klaus.solarpositioning.SPATest#testSillyLatLon
Type: org.opentest4j.AssertionFailedError
Message: Expected java.lang.IllegalArgumentException to be thrown, but nothing was thrown.

Test: net.e175.klaus.solarpositioning.SPASunriseTransitSetTest#testSillyLatLon
Type: org.opentest4j.AssertionFailedError
Message: Expected java.lang.IllegalArgumentException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.klausbrunner-solarpositioning-79c0044373b4:msbench-0.0.1,"diff --git a/src/main/java/net/e175/klaus/solarpositioning/Grena3.java b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
index 40274ed..35a6a9c 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
@@ -38,6 +38,7 @@ public final class Grena3 {
      * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time),
      *                  in seconds. See {@link JulianDate#JulianDate(ZonedDateTime, double)} and {@link DeltaT}.
      * @return Topocentric solar position (azimuth measured eastward from north)
+     * @throws IllegalArgumentException for nonsensical latitude/longitude
      * @see AzimuthZenithAngle
      */
     public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
@@ -63,11 +64,16 @@ public final class Grena3 {
      *                    correction of zenith angle. If unsure, 1000 is a reasonable default.
      * @param temperature Annual average local temperature, in degrees Celsius. Used for refraction correction of zenith angle.
      * @return Topocentric solar position (azimuth measured eastward from north)
+     * @throws IllegalArgumentException for nonsensical latitude/longitude
      * @see AzimuthZenithAngle
      */
     public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double deltaT, final double pressure,
                                                             final double temperature) {
+        if(latitude < -90.0 || latitude > 90.0 || longitude < -180.0 || longitude > 180.0) {
+            throw new IllegalArgumentException(""latitude/longitude out of range"");
+        }
+
         final double t = calcT(date);
         final double tE = t + 1.1574e-5 * deltaT;
         final double omegaAtE = 0.0172019715 * tE;
diff --git a/src/main/java/net/e175/klaus/solarpositioning/SPA.java b/src/main/java/net/e175/klaus/solarpositioning/SPA.java
index 20d091e..fd7d6ff 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/SPA.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/SPA.java
@@ -43,11 +43,13 @@ public final class SPA {
      *                    correction of zenith angle. If unsure, 1000 is a reasonable default.
      * @param temperature Annual average local temperature, in degrees Celsius. Used for refraction correction of zenith angle.
      * @return Topocentric solar position (azimuth measured eastward from north)
+     * @throws IllegalArgumentException for nonsensical latitude/longitude
      * @see AzimuthZenithAngle
      */
     public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double elevation, final double deltaT, final double pressure,
                                                             final double temperature) {
+        checkLatLonRange(latitude, longitude);
 
         // calculate Julian (ephemeris) date and millennium
         final JulianDate jd = new JulianDate(date, deltaT);
@@ -124,6 +126,12 @@ public final class SPA {
         return calculateTopocentricSolarPosition(pressure, temperature, phi, deltaPrime, hPrime);
     }
 
+    private static void checkLatLonRange(double latitude, double longitude) {
+        if(latitude < -90.0 || latitude > 90.0 || longitude < -180.0 || longitude > 180.0) {
+            throw new IllegalArgumentException(""latitude/longitude out of range"");
+        }
+    }
+
     /**
      * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
      * certain point of the Earth's surface.
@@ -141,6 +149,7 @@ public final class SPA {
      * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time),
      *                  in seconds. See {@link JulianDate#JulianDate(ZonedDateTime, double)} and {@link DeltaT}.
      * @return Topocentric solar position (azimuth measured eastward from north)
+     * @throws IllegalArgumentException for nonsensical latitude/longitude
      * @see AzimuthZenithAngle
      */
     public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
@@ -168,11 +177,14 @@ public final class SPA {
      * @param longitude Observer's longitude, in degrees (negative west of Greenwich).
      * @param deltaT    Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time),
      *                  in seconds. See {@link JulianDate#JulianDate(ZonedDateTime, double)} and {@link DeltaT}.
+     * @throws IllegalArgumentException for nonsensical latitude/longitude
      */
     public static SunriseTransitSet calculateSunriseTransitSet(final ZonedDateTime day,
                                                                final double latitude,
                                                                final double longitude,
                                                                final double deltaT) {
+        checkLatLonRange(latitude, longitude);
+
         final ZonedDateTime dayStart = startOfDayUT(day);
         final JulianDate jd = new JulianDate(dayStart, 0);
 
"
klausbrunner-solarpositioning-4d35aecb4840,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: net.e175.klaus.solarpositioning.DeltaTTest#testObservedValues
Type: org.opentest4j.AssertionFailedError
Message: expected: <67.6439> but was: <69.03049470312504>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.klausbrunner-solarpositioning-4d35aecb4840:msbench-0.0.1,"diff --git a/src/main/java/net/e175/klaus/solarpositioning/DeltaT.java b/src/main/java/net/e175/klaus/solarpositioning/DeltaT.java
index ff60ea7..5e382ac 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/DeltaT.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/DeltaT.java
@@ -13,7 +13,8 @@ public final class DeltaT {
 
     /**
      * Estimate Delta T for the given date. This is based on Espenak and Meeus, ""Five Millennium Canon of
-     * Solar Eclipses: -1999 to +3000"" (NASA/TP-2006-214141).
+     * Solar Eclipses: -1999 to +3000"" (NASA/TP-2006-214141) and updated by Espenak in 2014 at
+     * <a href=""https://www.eclipsewise.com/help/deltatpoly2014.html"">Eclipsewise</a>.
      *
      * @param forDate date and time
      * @return estimated delta T value (seconds)
@@ -63,14 +64,14 @@ public final class DeltaT {
             double t = year - 2000;
             deltaT = 63.86 + 0.3345 * t - 0.060374 * pow(t, 2) + 0.0017275 * pow(t, 3) + 0.000651814 * pow(t, 4)
                     + 0.00002373599 * pow(t, 5);
-        } else if (year < 2050) {
-            double t = year - 2000;
-            deltaT = 62.92 + 0.32217 * t + 0.005589 * pow(t, 2);
-        } else if (year < 2150) {
-            deltaT = -20 + 32 * pow(((year - 1820) / 100), 2) - 0.5628 * (2150 - year);
+        } else if (year < 2015) {
+            double t = year - 2005;
+            deltaT = 64.69 + 0.2930 * t;
+        } else if (year <= 3000) {
+            double t = year - 2015;
+            deltaT = 67.62 + 0.3645 * t + 0.0039755 * pow(t, 2);
         } else {
-            double u = (year - 1820) / 100;
-            deltaT = -20 + 32 * pow(u, 2);
+            throw new IllegalArgumentException(""no estimates possible for this time"");
         }
 
         return deltaT;
"
mthmulders-mcs-12a39786d753,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: it.mulders.mcs.search.SearchCommandHandlerTest$WildcardSearchTest#should_propagate_tls_exception_to_runtime_exception
Type: java.lang.AssertionError
Message: 
Expecting code to raise a throwable.

Test: it.mulders.mcs.search.SearchCommandHandlerTest$CoordinateSearchTest#should_propagate_tls_exception_to_runtime_exception
Type: java.lang.AssertionError
Message: 
Expecting code to raise a throwable.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.mthmulders-mcs-12a39786d753:msbench-0.0.1,"diff --git a/src/main/java/it/mulders/mcs/common/Result.java b/src/main/java/it/mulders/mcs/common/Result.java
index ad7b46d..297a29b 100644
--- a/src/main/java/it/mulders/mcs/common/Result.java
+++ b/src/main/java/it/mulders/mcs/common/Result.java
@@ -21,6 +21,11 @@ public sealed interface Result<T> permits Result.Success, Result.Failure {
         }
 
         @Override
+        public void ifPresentOrElse(Consumer<T> successConsumer, Consumer<Throwable> failureConsumer) {
+            successConsumer.accept(value);
+        }
+
+        @Override
         public Throwable cause() {
             throw new NoSuchElementException(""success: "" + this.value);
         }
@@ -37,6 +42,11 @@ public sealed interface Result<T> permits Result.Success, Result.Failure {
         }
 
         @Override
+        public void ifPresentOrElse(Consumer<T> successConsumer, Consumer<Throwable> failureConsumer) {
+            failureConsumer.accept(cause);
+        }
+
+        @Override
         public T value() {
             throw new NoSuchElementException(""failure: "" + this.cause.getLocalizedMessage());
         }
@@ -46,6 +56,8 @@ public sealed interface Result<T> permits Result.Success, Result.Failure {
 
     void ifPresent(final Consumer<T> consumer);
 
+    void ifPresentOrElse(final Consumer<T> successConsumer, final Consumer<Throwable> failureConsumer);
+
     T value();
 
     Throwable cause();
diff --git a/src/main/java/it/mulders/mcs/search/SearchCommandHandler.java b/src/main/java/it/mulders/mcs/search/SearchCommandHandler.java
index f68a0d0..3dcba38 100644
--- a/src/main/java/it/mulders/mcs/search/SearchCommandHandler.java
+++ b/src/main/java/it/mulders/mcs/search/SearchCommandHandler.java
@@ -27,7 +27,10 @@ public class SearchCommandHandler {
     public void search(final SearchQuery query) {
         performSearch(query)
                 .map(response -> performAdditionalSearch(query, response))
-                .ifPresent(response -> printResponse(query, response));
+                .ifPresentOrElse(
+                        response -> printResponse(query, response),
+                        failure -> { throw new RuntimeException(failure); }
+                );
     }
 
     private SearchResponse.Response performAdditionalSearch(final SearchQuery query,
"
mthmulders-mcs-7c8b5bc9c7f2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: it.mulders.mcs.search.printer.CoordinatePrinterTest#should_print_snippet(CoordinatePrinter, String, Response)[2]
Type: org.opentest4j.AssertionFailedError
Message: 
Expecting actual:
  ""
    <dependency>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <version>3.3.0</version>
    </dependency>


""
to be equal to:
  ""<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>3.3.0</version>
</plugin>
""
when ignoring whitespace differences

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.mthmulders-mcs-7c8b5bc9c7f2:msbench-0.0.1,"diff --git a/src/main/java/it/mulders/mcs/search/printer/BuildrOutput.java b/src/main/java/it/mulders/mcs/search/printer/BuildrOutput.java
index 81299ac..74c7ddc 100644
--- a/src/main/java/it/mulders/mcs/search/printer/BuildrOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/BuildrOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class BuildrOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return ""'%s:%s:jar:%s'"".formatted(group, artifact, version);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/CoordinatePrinter.java b/src/main/java/it/mulders/mcs/search/printer/CoordinatePrinter.java
index fb98f4c..9e27fb9 100644
--- a/src/main/java/it/mulders/mcs/search/printer/CoordinatePrinter.java
+++ b/src/main/java/it/mulders/mcs/search/printer/CoordinatePrinter.java
@@ -9,7 +9,7 @@ public sealed interface CoordinatePrinter extends OutputPrinter
         permits BuildrOutput, GradleGroovyOutput, GradleGroovyShortOutput, GradleKotlinOutput, GrapeOutput,
         IvyXmlOutput, LeiningenOutput, PomXmlOutput, SbtOutput {
 
-    String provideCoordinates(final String group, final String artifact, final String version);
+    String provideCoordinates(final String group, final String artifact, final String version, final String packaging);
 
     @Override
     default void print(final SearchQuery query, final SearchResponse.Response response, final PrintStream stream) {
@@ -19,7 +19,7 @@ public sealed interface CoordinatePrinter extends OutputPrinter
 
         var doc = response.docs()[0];
         stream.println();
-        stream.println(provideCoordinates(doc.g(), doc.a(), first(doc.v(), doc.latestVersion())));
+        stream.println(provideCoordinates(doc.g(), doc.a(), first(doc.v(), doc.latestVersion()), doc.p()));
         stream.println();
     }
 
diff --git a/src/main/java/it/mulders/mcs/search/printer/GradleGroovyOutput.java b/src/main/java/it/mulders/mcs/search/printer/GradleGroovyOutput.java
index 653ddaf..21edd9f 100644
--- a/src/main/java/it/mulders/mcs/search/printer/GradleGroovyOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/GradleGroovyOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class GradleGroovyOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return ""implementation group: '%s', name: '%s', version: '%s'"".formatted(group, artifact, version);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/GradleGroovyShortOutput.java b/src/main/java/it/mulders/mcs/search/printer/GradleGroovyShortOutput.java
index dd74a11..041b066 100644
--- a/src/main/java/it/mulders/mcs/search/printer/GradleGroovyShortOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/GradleGroovyShortOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class GradleGroovyShortOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return ""implementation '%s:%s:%s'"".formatted(group, artifact, version);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/GradleKotlinOutput.java b/src/main/java/it/mulders/mcs/search/printer/GradleKotlinOutput.java
index 0dede3a..5db3031 100644
--- a/src/main/java/it/mulders/mcs/search/printer/GradleKotlinOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/GradleKotlinOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class GradleKotlinOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return ""implementation(\""%s:%s:%s\"")"".formatted(group, artifact, version);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/GrapeOutput.java b/src/main/java/it/mulders/mcs/search/printer/GrapeOutput.java
index cbea0d4..692fa7f 100644
--- a/src/main/java/it/mulders/mcs/search/printer/GrapeOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/GrapeOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class GrapeOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return """"""
                 @Grapes(
                     @Grab(group='%s', module='%s', version='%s')
diff --git a/src/main/java/it/mulders/mcs/search/printer/IvyXmlOutput.java b/src/main/java/it/mulders/mcs/search/printer/IvyXmlOutput.java
index 995c15d..4ade67d 100644
--- a/src/main/java/it/mulders/mcs/search/printer/IvyXmlOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/IvyXmlOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class IvyXmlOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return """"""
                 <dependency org=""%s"" name=""%s"" rev=""%s""/>
                 """""".formatted(group, artifact, version);
diff --git a/src/main/java/it/mulders/mcs/search/printer/LeiningenOutput.java b/src/main/java/it/mulders/mcs/search/printer/LeiningenOutput.java
index 2f150cf..b3bdcfa 100644
--- a/src/main/java/it/mulders/mcs/search/printer/LeiningenOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/LeiningenOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class LeiningenOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return ""[%s/%s \""%s\""]"".formatted(group, artifact, version);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/PomXmlOutput.java b/src/main/java/it/mulders/mcs/search/printer/PomXmlOutput.java
index 68474f7..f34c46c 100644
--- a/src/main/java/it/mulders/mcs/search/printer/PomXmlOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/PomXmlOutput.java
@@ -3,13 +3,14 @@ package it.mulders.mcs.search.printer;
 public final class PomXmlOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
+        String element = ""maven-plugin"".equals(packaging) ? ""plugin"" : ""dependency"";
         return """"""
-                    <dependency>
+                    <%4$s>
                         <groupId>%s</groupId>
                         <artifactId>%s</artifactId>
                         <version>%s</version>
-                    </dependency>
-                """""".formatted(group, artifact, version);
+                    </%4$s>
+                """""".formatted(group, artifact, version, element);
     }
 }
diff --git a/src/main/java/it/mulders/mcs/search/printer/SbtOutput.java b/src/main/java/it/mulders/mcs/search/printer/SbtOutput.java
index f4c57e8..9ff8894 100644
--- a/src/main/java/it/mulders/mcs/search/printer/SbtOutput.java
+++ b/src/main/java/it/mulders/mcs/search/printer/SbtOutput.java
@@ -3,7 +3,7 @@ package it.mulders.mcs.search.printer;
 public final class SbtOutput implements CoordinatePrinter {
 
     @Override
-    public String provideCoordinates(final String group, final String artifact, final String version) {
+    public String provideCoordinates(final String group, final String artifact, final String version, String packaging) {
         return """"""
                 libraryDependencies += ""%s"" %% ""%s"" %% ""%s""
                 """""".formatted(group, artifact, version);
"
mthmulders-mcs-eff905bef8d8,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: it.mulders.mcs.search.printer.TabularOutputPrinterTest#should_print_gav
Type: java.lang.AssertionError
Message: 
Expecting actual:
  ""Found 1 results

  Coordinates                        Last updated
  ===========                        ============
  org.codehaus.plexus:plexus-utils   27 Aug 2021 at 00:08 (UTC)

""
to contain:
  ""org.codehaus.plexus:plexus-utils:3.4.1"" 

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.mthmulders-mcs-eff905bef8d8:msbench-0.0.1,"diff --git a/src/main/java/it/mulders/mcs/search/printer/TabularOutputPrinter.java b/src/main/java/it/mulders/mcs/search/printer/TabularOutputPrinter.java
index c36b641..58022f5 100644
--- a/src/main/java/it/mulders/mcs/search/printer/TabularOutputPrinter.java
+++ b/src/main/java/it/mulders/mcs/search/printer/TabularOutputPrinter.java
@@ -61,6 +61,6 @@ public class TabularOutputPrinter implements OutputPrinter {
                 Instant.ofEpochMilli(doc.timestamp()).atZone(ZoneId.systemDefault())
         );
 
-        table.addRowValues(doc.id(), lastUpdated);
+        table.addRowValues(doc.id() + "":"" + doc.latestVersion(), lastUpdated);
     }
 }
"
nikoo28-java-solutions-8d81307ea165,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: leetcode.medium.OnlineStockSpanTest#testCalculateSpans6
Type: org.opentest4j.AssertionFailedError
Message: array contents differ at index [1], expected: <1> but was: <2>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.nikoo28-java-solutions-8d81307ea165:msbench-0.0.1,"diff --git a/src/main/java/leetcode/medium/OnlineStockSpan.java b/src/main/java/leetcode/medium/OnlineStockSpan.java
index ee013ef..dc22f4f 100644
--- a/src/main/java/leetcode/medium/OnlineStockSpan.java
+++ b/src/main/java/leetcode/medium/OnlineStockSpan.java
@@ -35,7 +35,7 @@ public class OnlineStockSpan {
 
     for (int i = 1; i < prices.length; i++) {
       while (!indexStack.isEmpty()
-          && prices[indexStack.peek()] <= prices[i])
+          && prices[indexStack.peek()] < prices[i])
         indexStack.pop();
 
       // If index stack is empty, the price at index 'i'
"
retel-io-ari-proxy-610e9b6725e1,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: io.retel.ariproxy.boundary.commandsandresponses.AriCommandResponseProcessingTest#doesNotTryToRegisterACallContextForDeleteRequests
Type: java.lang.AssertionError
Message: Received unexpected message RegisterCallContext[callContext=theCallContext,resourceId=CHANNEL_ID]

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.retel-io-ari-proxy-610e9b6725e1:msbench-0.0.1,"diff --git a/src/main/java/io/retel/ariproxy/boundary/commandsandresponses/AriCommandResponseProcessing.java b/src/main/java/io/retel/ariproxy/boundary/commandsandresponses/AriCommandResponseProcessing.java
index a2fc156..a247ce9 100644
--- a/src/main/java/io/retel/ariproxy/boundary/commandsandresponses/AriCommandResponseProcessing.java
+++ b/src/main/java/io/retel/ariproxy/boundary/commandsandresponses/AriCommandResponseProcessing.java
@@ -17,7 +17,8 @@ public class AriCommandResponseProcessing {
       final String callContext,
       final AriCommand ariCommand) {
 
-    if (!ariCommand.extractCommandType().isCreationCommand()) {
+    if (!(ariCommand.extractCommandType().isCreationCommand()
+        && ""POST"".equals(ariCommand.getMethod()))) {
       return Try.success(Done.done());
     }
 
"
revelc-formatter-maven-plugin-3e9843d2ab99,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: net.revelc.code.formatter.css.CssFormatterTest#testDoFormatFile
Type: org.opentest4j.AssertionFailedError
Message: expected: <6434062bd7499e707dea1ea17d301556712222b7671fae79ec20d906cda467a2b2210896a196dbaa9da7d221f04cab87a6b2e5538ca3c46fa7fdbedb46010a8c> but was: <1af0032669532658f137ff80186df756abcfbccbe84e9663b54ef70be2c641f5af9e8c16ceeb3da7df9dc02599a3da0c0139a9397f93e383d6e8c6c50fd65c53>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.revelc-formatter-maven-plugin-3e9843d2ab99:msbench-0.0.1,"diff --git a/src/main/java/net/revelc/code/formatter/css/CssFormatter.java b/src/main/java/net/revelc/code/formatter/css/CssFormatter.java
index 1115835..f73773d 100644
--- a/src/main/java/net/revelc/code/formatter/css/CssFormatter.java
+++ b/src/main/java/net/revelc/code/formatter/css/CssFormatter.java
@@ -60,6 +60,12 @@ public class CssFormatter extends AbstractCacheableFormatter implements Formatte
         // Patch converted 'tab' back to '\9' for IE 7,8, and 9 hack. Cssparser switches it to 'tab'.
         formattedCode = formattedCode.replace(""\t;"", ""\\9;"");
 
+        // Adding new line at end of file when needed
+        String[] lines = formattedCode.split(ending.getChars());
+        if (!lines[lines.length - 1].equals(ending.getChars())) {
+            formattedCode = formattedCode + ending.getChars();
+        }
+
         if (code.equals(formattedCode)) {
             return null;
         }
"
salesforce-grammaticus-cdf67a1ad578,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.force.i18n.grammar.impl.GrammaticalTermMapImplTest#testSerialization
Type: junit.framework.AssertionFailedError
Message: The map returns different isSkinny  expected:<true> but was:<false>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.salesforce-grammaticus-cdf67a1ad578:msbench-0.0.1,"diff --git a/src/main/java/com/force/i18n/grammar/impl/GrammaticalTermMapImpl.java b/src/main/java/com/force/i18n/grammar/impl/GrammaticalTermMapImpl.java
index c53fa3f..10cb487 100644
--- a/src/main/java/com/force/i18n/grammar/impl/GrammaticalTermMapImpl.java
+++ b/src/main/java/com/force/i18n/grammar/impl/GrammaticalTermMapImpl.java
@@ -27,10 +27,13 @@ import static com.force.i18n.commons.util.settings.IniFileUtil.intern;
  * @author ytanida
  */
 public class GrammaticalTermMapImpl<T extends GrammaticalTerm> implements GrammaticalTermMap<T>, Serializable {
-    protected Map<String, T> map;
+    private static final long serialVersionUID = 2099717329853215271L;
+
+    protected transient Map<String, T> map;
     private boolean isSkinny = false;
+
     public GrammaticalTermMapImpl() {
-        map = new HashMap<String, T>();        
+        map = new HashMap<>();        
     }
 
     public GrammaticalTermMapImpl(Map<String, T> map, boolean isSkinny) {
@@ -49,6 +52,7 @@ public class GrammaticalTermMapImpl<T extends GrammaticalTerm> implements Gramma
         if(!(obj instanceof GrammaticalTermMapImpl)) 
             return false;
 
+        @SuppressWarnings(""unchecked"")
         GrammaticalTermMapImpl<T> other = (GrammaticalTermMapImpl<T>)obj;
         return isSkinny == other.isSkinny && map.equals(other.map);
     }
@@ -65,12 +69,12 @@ public class GrammaticalTermMapImpl<T extends GrammaticalTerm> implements Gramma
 
     @Override
     public GrammaticalTermMap<T> makeSkinny() {
-        return new GrammaticalTermMapImpl<T>(map, true);
+        return new GrammaticalTermMapImpl<>(map, true);
     }
 
     @Override
     public void writeJson(Appendable out, RenamingProvider renamingProvider, LanguageDictionary dictionary, Collection<String> termsToInclude) throws IOException {
-        Set<String> wrote = new HashSet<String>();
+        Set<String> wrote = new HashSet<>();
         out.append('{');
         if (termsToInclude != null) {
             boolean first = true;
@@ -166,7 +170,9 @@ public class GrammaticalTermMapImpl<T extends GrammaticalTerm> implements Gramma
      * @param in
      * @throws IOException
      */
+    @SuppressWarnings(""unchecked"")
     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
         this.map = ((TermMapSerializer<T>)in.readObject()).getMap();
     }
 
@@ -176,7 +182,8 @@ public class GrammaticalTermMapImpl<T extends GrammaticalTerm> implements Gramma
      * @throws IOException
      */
     private void writeObject(ObjectOutputStream out) throws IOException {
-        out.writeObject(new TermMapSerializer<T>(map));
+        out.defaultWriteObject();
+        out.writeObject(new TermMapSerializer<>(map));
     }
 
     static final class TermMapSerializer<T extends GrammaticalTerm> extends MapSerializer<String, T> {
"
semver4j-semver4j-10102b374298,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.semver4j.RangesListTest#shouldOmitOuterParentheses
Type: org.opentest4j.AssertionFailedError
Message: 
expected: "">=3.0.0 and <=3.0.1""
 but was: ""(>=3.0.0 and <=3.0.1)""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.semver4j-semver4j-10102b374298:msbench-0.0.1,"diff --git a/src/main/java/org/semver4j/RangesList.java b/src/main/java/org/semver4j/RangesList.java
index c70ac62..d1bc4f6 100644
--- a/src/main/java/org/semver4j/RangesList.java
+++ b/src/main/java/org/semver4j/RangesList.java
@@ -81,7 +81,8 @@ public class RangesList {
     public String toString() {
         return rangesList.stream()
             .map(RangesList::formatRanges)
-            .collect(joining(OR_JOINER));
+            .collect(joining(OR_JOINER))
+            .replaceAll(""^\\(([^()]+)\\)$"", ""$1"");
     }
 
     private static String formatRanges(List<Range> ranges) {
"
semver4j-semver4j-de7dadc7ece6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.semver4j.SemverTest#shouldTryCoerceVersion{String, String}[52]
Type: org.opentest4j.AssertionFailedError
Message: 
expected: ""3.2.1-rc.2""
 but was: ""3.2.1""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.semver4j-semver4j-de7dadc7ece6:msbench-0.0.1,"diff --git a/src/main/java/org/semver4j/Semver.java b/src/main/java/org/semver4j/Semver.java
index 89203d3..cd3ed09 100644
--- a/src/main/java/org/semver4j/Semver.java
+++ b/src/main/java/org/semver4j/Semver.java
@@ -4,8 +4,11 @@ import org.semver4j.internal.*;
 import org.semver4j.internal.StrictParser.Version;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Objects;
 
+import static java.lang.String.format;
+import static java.lang.String.join;
 import static java.util.Objects.hash;
 
 /**
@@ -15,7 +18,7 @@ import static java.util.Objects.hash;
 public class Semver implements Comparable<Semver> {
     public static final Semver ZERO = new Semver(""0.0.0"");
 
-    private final String version;
+    private final String originalVersion;
 
     private final int major;
     private final int minor;
@@ -23,16 +26,27 @@ public class Semver implements Comparable<Semver> {
     private final List<String> preRelease;
     private final List<String> build;
 
+    private final String version;
+
     public Semver(String version) {
-        this.version = version.trim();
+        this.originalVersion = version.trim();
 
-        Version parsedVersion = new StrictParser().parse(this.version);
+        Version parsedVersion = new StrictParser().parse(this.originalVersion);
 
         major = parsedVersion.getMajor();
         minor = parsedVersion.getMinor();
         patch = parsedVersion.getPatch();
         preRelease = parsedVersion.getPreRelease();
         build = parsedVersion.getBuild();
+
+        String resultVersion = format(Locale.ROOT, ""%d.%d.%d"", major, minor, patch);
+        if (!preRelease.isEmpty()) {
+            resultVersion += ""-"" + join(""."", preRelease);
+        }
+        if (!build.isEmpty()) {
+            resultVersion += ""+"" + join(""."", build);
+        }
+        this.version = resultVersion;
     }
 
     /**
@@ -56,6 +70,10 @@ public class Semver implements Comparable<Semver> {
      * @return {@link Semver} if can coerce version, {@code null} otherwise
      */
     public static Semver coerce(String version) {
+        Semver semver = parse(version);
+        if (semver != null) {
+            return semver;
+        }
         String coerce = Coerce.coerce(version);
         return parse(coerce);
     }
@@ -466,12 +484,12 @@ public class Semver implements Comparable<Semver> {
             return false;
         }
         Semver semver = (Semver) o;
-        return Objects.equals(version, semver.version);
+        return Objects.equals(originalVersion, semver.originalVersion);
     }
 
     @Override
     public int hashCode() {
-        return hash(version);
+        return hash(originalVersion);
     }
 
     @Override
"
semver4j-semver4j-beb7e5d466c7,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.semver4j.SemverTest#shouldCheckSatisfies{String, String, boolean}[134]
Type: org.opentest4j.AssertionFailedError
Message: 
expected: true
 but was: false

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.semver4j-semver4j-beb7e5d466c7:msbench-0.0.1,"diff --git a/src/main/java/org/semver4j/internal/range/processor/XRangeProcessor.java b/src/main/java/org/semver4j/internal/range/processor/XRangeProcessor.java
index 3864446..b336ff7 100644
--- a/src/main/java/org/semver4j/internal/range/processor/XRangeProcessor.java
+++ b/src/main/java/org/semver4j/internal/range/processor/XRangeProcessor.java
@@ -47,9 +47,6 @@ public class XRangeProcessor implements Processor {
                 }
 
                 if (!compareSign.isEmpty() && isX(patch)) {
-                    if (isX(minor)) {
-                        minor = 0;
-                    }
                     patch = 0;
                     if (compareSign.equals(GT.asString())) {
                         compareSign = GTE.asString();
@@ -64,9 +61,12 @@ public class XRangeProcessor implements Processor {
                         compareSign = LT.asString();
                         if (isX(minor)) {
                             major = major + 1;
+                            minor = 0;
                         } else {
                             minor = minor + 1;
                         }
+                    } else if (isX(minor)) {
+                        minor = 0;
                     }
 
                     String from = format(Locale.ROOT, ""%s%d.%d.%d"", compareSign, major, minor, patch);
"
slub-urnlib-106be8d1b804,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: de.slub.urn.RQFRFC8141Test#ToString_With_Parameters_And_Fragment
Type: org.junit.ComparisonFailure
Message: expected:<...utionParameter1=foo1[resolutionParameter0=foo0?=queryParameter0=bar0]queryParameters1=bar...> but was:<...utionParameter1=foo1[&resolutionParameter0=foo0?=queryParameter0=bar0&]queryParameters1=bar...>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.slub-urnlib-106be8d1b804:msbench-0.0.1,"diff --git a/src/main/java/de/slub/urn/RQF_RFC8141.java b/src/main/java/de/slub/urn/RQF_RFC8141.java
index 02a0df4..0915cea 100644
--- a/src/main/java/de/slub/urn/RQF_RFC8141.java
+++ b/src/main/java/de/slub/urn/RQF_RFC8141.java
@@ -17,11 +17,13 @@
 
 package de.slub.urn;
 
+import static java.util.Collections.EMPTY_MAP;
+
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
-import static java.util.Collections.EMPTY_MAP;
-
 /**
  * Class for representing and parsing optional resolution, query and fragment components
  * and making them accessible via unmodifiable maps.
@@ -92,15 +94,19 @@ public final class RQF_RFC8141 {
         StringBuilder sb = new StringBuilder();
         if (!resolutionParameters.isEmpty()) {
             sb.append(""?+"");
+            final List<String> acc = new ArrayList<>();
             for (Map.Entry<String, String> kv : resolutionParameters.entrySet()) {
-                sb.append(kv.getKey()).append('=').append(kv.getValue());
+                acc.add(kv.getKey() + ""="" + kv.getValue());
             }
+            sb.append(String.join(""&"", acc));
         }
         if (!queryParameters.isEmpty()) {
             sb.append(""?="");
+            final List<String> acc = new ArrayList<>();
             for (Map.Entry<String, String> kv : queryParameters.entrySet()) {
-                sb.append(kv.getKey()).append('=').append(kv.getValue());
+            	acc.add(kv.getKey() + ""="" + kv.getValue());
             }
+            sb.append(String.join(""&"", acc));
         }
         if (!fragment.isEmpty()) {
             sb.append('#').append(fragment);
"
spring-projects-spring-guice-ce15b8e5802a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.springframework.guice.module.SpringModuleMetadataTests#threeServicesByQualifier
Type: org.opentest4j.AssertionFailedError
Message: [Extracted: name] 
expected: ""emptyQualifierService""
 but was: ""primary""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.spring-projects-spring-guice-ce15b8e5802a:msbench-0.0.1,"diff --git a/src/main/java/org/springframework/guice/module/SpringModule.java b/src/main/java/org/springframework/guice/module/SpringModule.java
index f373d59..d4d9f45 100644
--- a/src/main/java/org/springframework/guice/module/SpringModule.java
+++ b/src/main/java/org/springframework/guice/module/SpringModule.java
@@ -17,11 +17,9 @@
 package org.springframework.guice.module;
 
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -58,11 +56,9 @@ import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.beans.factory.support.RootBeanDefinition;
 import org.springframework.context.ApplicationContext;
 import org.springframework.core.ResolvableType;
-import org.springframework.core.annotation.AnnotationUtils;
+import org.springframework.core.annotation.MergedAnnotation;
 import org.springframework.core.type.MethodMetadata;
-import org.springframework.core.type.StandardMethodMetadata;
 import org.springframework.util.ClassUtils;
-import org.springframework.util.ReflectionUtils;
 
 /**
  * A Guice module that wraps a Spring {@link ApplicationContext}.
@@ -137,7 +133,7 @@ public class SpringModule extends AbstractModule {
 			if (definition.hasAttribute(SPRING_GUICE_SOURCE)) {
 				continue;
 			}
-			Optional<Annotation> bindingAnnotation = getAnnotationForBeanDefinition(definition, beanFactory);
+			Optional<Annotation> bindingAnnotation = getAnnotationForBeanDefinition(definition);
 			if (definition.isAutowireCandidate() && definition.getRole() == AbstractBeanDefinition.ROLE_APPLICATION) {
 				Type type;
 				Class<?> clazz = beanFactory.getType(name);
@@ -204,16 +200,15 @@ public class SpringModule extends AbstractModule {
 		}
 	}
 
-	private static Optional<Annotation> getAnnotationForBeanDefinition(BeanDefinition definition,
-			ConfigurableListableBeanFactory beanFactory) {
-		if (definition instanceof AnnotatedBeanDefinition
-				&& ((AnnotatedBeanDefinition) definition).getFactoryMethodMetadata() != null) {
-			try {
-				Method factoryMethod = getFactoryMethod(beanFactory, definition);
-				return Arrays.stream(AnnotationUtils.getAnnotations(factoryMethod))
-						.filter((a) -> Annotations.isBindingAnnotation(a.annotationType())).findFirst();
+	private static Optional<Annotation> getAnnotationForBeanDefinition(BeanDefinition definition) {
+		if (definition instanceof AnnotatedBeanDefinition) {
+			MethodMetadata methodMetadata = ((AnnotatedBeanDefinition) definition).getFactoryMethodMetadata();
+			if (methodMetadata != null) {
+				return methodMetadata.getAnnotations().stream().filter(MergedAnnotation::isDirectlyPresent)
+						.filter((mergedAnnotation) -> Annotations.isBindingAnnotation(mergedAnnotation.getType()))
+						.map(MergedAnnotation::synthesize).findFirst();
 			}
-			catch (Exception ex) {
+			else {
 				return Optional.empty();
 			}
 		}
@@ -222,49 +217,6 @@ public class SpringModule extends AbstractModule {
 		}
 	}
 
-	private static Method getFactoryMethod(ConfigurableListableBeanFactory beanFactory, BeanDefinition definition)
-			throws Exception {
-		if (definition instanceof AnnotatedBeanDefinition) {
-			MethodMetadata factoryMethodMetadata = ((AnnotatedBeanDefinition) definition).getFactoryMethodMetadata();
-			if (factoryMethodMetadata instanceof StandardMethodMetadata) {
-				return ((StandardMethodMetadata) factoryMethodMetadata).getIntrospectedMethod();
-			}
-		}
-		BeanDefinition factoryDefinition = beanFactory.getBeanDefinition(definition.getFactoryBeanName());
-		Class<?> factoryClass = ClassUtils.forName(factoryDefinition.getBeanClassName(),
-				beanFactory.getBeanClassLoader());
-		return getFactoryMethod(definition, factoryClass);
-	}
-
-	private static Method getFactoryMethod(BeanDefinition definition, Class<?> factoryClass) {
-		Method uniqueMethod = null;
-		for (Method candidate : getCandidateFactoryMethods(definition, factoryClass)) {
-			if (candidate.getName().equals(definition.getFactoryMethodName())) {
-				if (uniqueMethod == null) {
-					uniqueMethod = candidate;
-				}
-				else if (!hasMatchingParameterTypes(candidate, uniqueMethod)) {
-					return null;
-				}
-			}
-		}
-		return uniqueMethod;
-	}
-
-	private static Method[] getCandidateFactoryMethods(BeanDefinition definition, Class<?> factoryClass) {
-		return shouldConsiderNonPublicMethods(definition) ? ReflectionUtils.getAllDeclaredMethods(factoryClass)
-				: factoryClass.getMethods();
-	}
-
-	private static boolean shouldConsiderNonPublicMethods(BeanDefinition definition) {
-		return (definition instanceof AbstractBeanDefinition)
-				&& ((AbstractBeanDefinition) definition).isNonPublicAccessAllowed();
-	}
-
-	private static boolean hasMatchingParameterTypes(Method candidate, Method current) {
-		return Arrays.equals(candidate.getParameterTypes(), current.getParameterTypes());
-	}
-
 	private static Set<Type> getAllSuperTypes(Type originalType, Class<?> clazz) {
 		Set<Type> allInterfaces = new HashSet<>();
 		TypeLiteral<?> typeToken = TypeLiteral.get(originalType);
@@ -420,34 +372,65 @@ public class SpringModule extends AbstractModule {
 
 				String[] named = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory,
 						ResolvableType.forType(this.type));
-				List<String> names = new ArrayList<String>(named.length);
-				if (named.length == 1) {
-					names.add(named[0]);
+
+				List<String> candidateBeanNames = new ArrayList<>(named.length);
+				for (String name : named) {
+					BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(name);
+					// This is a Guice component bridged to spring
+					// If this were the target candidate,
+					// Guice would have injected it natively.
+					// Thus, it cannot be a candidate.
+					// GuiceFactoryBeans don't have 1-to-1 annotation mapping
+					// (since annotation attributes are ignored)
+					// Skip this candidate to avoid unexpected matches
+					// due to imprecise annotation mapping
+					if (!beanDefinition.hasAttribute(SPRING_GUICE_SOURCE)) {
+						candidateBeanNames.add(name);
+					}
+				}
+
+				List<String> matchingBeanNames;
+				if (candidateBeanNames.size() == 1) {
+					matchingBeanNames = candidateBeanNames;
 				}
 				else {
-					for (String name : named) {
-						if (this.bindingAnnotation.isPresent()) {
-							if (this.bindingAnnotation.get() instanceof Named
-									|| this.bindingAnnotation.get() instanceof javax.inject.Named) {
-								Optional<Annotation> annotation = SpringModule.getAnnotationForBeanDefinition(
-										this.beanFactory.getMergedBeanDefinition(name), this.beanFactory);
-								String boundName = getNameFromBindingAnnotation(this.bindingAnnotation);
-								if (annotation.isPresent() && this.bindingAnnotation.get().equals(annotation.get())
-										|| name.equals(boundName)) {
-									names.add(name);
+					matchingBeanNames = new ArrayList<String>(candidateBeanNames.size());
+					for (String name : candidateBeanNames) {
+						// Make sure we don't add the same name twice using if/else
+						if (name.equals(this.name)) {
+							// Guice is injecting dependency of this type by bean name
+							matchingBeanNames.add(name);
+						}
+						else if (this.bindingAnnotation.isPresent()) {
+							String boundName = getNameFromBindingAnnotation(this.bindingAnnotation);
+							if (name.equals(boundName)) {
+								// Spring bean definition has a Named annotation that
+								// matches the name of the bean
+								// In such cases, we dedupe namedProvider (because it's
+								// Key equals typeProvider Key)
+								// Thus, this complementary check is required
+								// (because name field is null in typeProvider,
+								// and if check above wouldn't pass)
+								matchingBeanNames.add(name);
+							}
+							else {
+								Optional<Annotation> annotationOptional = SpringModule
+										.getAnnotationForBeanDefinition(this.beanFactory.getBeanDefinition(name));
+
+								if (annotationOptional.equals(this.bindingAnnotation)) {
+									// Found a bean with matching qualifier annotation
+									matchingBeanNames.add(name);
 								}
 							}
 						}
-						if (name.equals(this.name)) {
-							names.add(name);
-						}
 					}
 				}
-				if (names.size() == 1) {
-					this.resultProvider = () -> this.beanFactory.getBean(names.get(0));
+				if (matchingBeanNames.size() == 1) {
+					this.resultProvider = () -> this.beanFactory.getBean(matchingBeanNames.get(0));
 				}
 				else {
-					for (String name : named) {
+					// Shouldn't we iterate over matching bean names here?
+					for (String name : candidateBeanNames) {
 						if (this.beanFactory.getBeanDefinition(name).isPrimary()) {
 							this.resultProvider = () -> this.beanFactory.getBean(name);
 							break;
"
spring-projects-spring-retry-e6091f790c64,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.springframework.retry.annotation.EnableRetryTests#testExpression
Type: org.opentest4j.AssertionFailedError
Message: 
expected: 5000L
 but was: 1000L

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.spring-projects-spring-retry-e6091f790c64:msbench-0.0.1,"diff --git a/src/main/java/org/springframework/retry/backoff/BackOffPolicyBuilder.java b/src/main/java/org/springframework/retry/backoff/BackOffPolicyBuilder.java
index da1dd8c..72c9185 100644
--- a/src/main/java/org/springframework/retry/backoff/BackOffPolicyBuilder.java
+++ b/src/main/java/org/springframework/retry/backoff/BackOffPolicyBuilder.java
@@ -267,7 +267,10 @@ public class BackOffPolicyBuilder {
 			return policy;
 		}
 		FixedBackOffPolicy policy = new FixedBackOffPolicy();
-		if (this.delay != null) {
+		if (this.delaySupplier != null) {
+			policy.backOffPeriodSupplier(this.delaySupplier);
+		}
+		else if (this.delay != null) {
 			policy.setBackOffPeriod(this.delay);
 		}
 		if (this.sleeper != null) {
"
spring-projects-spring-retry-c89b9516d976,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.springframework.retry.backoff.UniformRandomBackOffPolicyTests#testInterruptedStatusIsRestored
Type: org.opentest4j.AssertionFailedError
Message: 
Expecting value to be true but was false

Test: org.springframework.retry.backoff.ExponentialBackOffPolicyTests#testInterruptedStatusIsRestored
Type: org.opentest4j.AssertionFailedError
Message: 
Expecting value to be true but was false

Test: org.springframework.retry.backoff.FixedBackOffPolicyTests#testInterruptedStatusIsRestored
Type: org.opentest4j.AssertionFailedError
Message: 
Expecting value to be true but was false

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.spring-projects-spring-retry-c89b9516d976:msbench-0.0.1,"diff --git a/src/main/java/org/springframework/retry/backoff/ExponentialBackOffPolicy.java b/src/main/java/org/springframework/retry/backoff/ExponentialBackOffPolicy.java
index 194f7d4..bd1f71c 100644
--- a/src/main/java/org/springframework/retry/backoff/ExponentialBackOffPolicy.java
+++ b/src/main/java/org/springframework/retry/backoff/ExponentialBackOffPolicy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2022 the original author or authors.
+ * Copyright 2006-2023 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -41,6 +41,7 @@ import org.springframework.util.ClassUtils;
  * @author Dave Syer
  * @author Gary Russell
  * @author Artem Bilan
+ * @author Marius Lichtblau
  */
 @SuppressWarnings(""serial"")
 public class ExponentialBackOffPolicy implements SleepingBackOffPolicy<ExponentialBackOffPolicy> {
@@ -245,6 +246,7 @@ public class ExponentialBackOffPolicy implements SleepingBackOffPolicy<Exponenti
 			this.sleeper.sleep(sleepTime);
 		}
 		catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
 			throw new BackOffInterruptedException(""Thread interrupted while sleeping"", e);
 		}
 	}
diff --git a/src/main/java/org/springframework/retry/backoff/FixedBackOffPolicy.java b/src/main/java/org/springframework/retry/backoff/FixedBackOffPolicy.java
index db12bb9..fc26986 100644
--- a/src/main/java/org/springframework/retry/backoff/FixedBackOffPolicy.java
+++ b/src/main/java/org/springframework/retry/backoff/FixedBackOffPolicy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2022 the original author or authors.
+ * Copyright 2006-2023 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -31,6 +31,7 @@ import org.springframework.util.Assert;
  * @author Rob Harrop
  * @author Dave Syer
  * @author Artem Bilan
+ * @author Marius Lichtblau
  */
 public class FixedBackOffPolicy extends StatelessBackOffPolicy implements SleepingBackOffPolicy<FixedBackOffPolicy> {
 
@@ -97,6 +98,7 @@ public class FixedBackOffPolicy extends StatelessBackOffPolicy implements Sleepi
 			sleeper.sleep(this.backOffPeriod.get());
 		}
 		catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
 			throw new BackOffInterruptedException(""Thread interrupted while sleeping"", e);
 		}
 	}
diff --git a/src/main/java/org/springframework/retry/backoff/UniformRandomBackOffPolicy.java b/src/main/java/org/springframework/retry/backoff/UniformRandomBackOffPolicy.java
index ef696d8..68249f7 100644
--- a/src/main/java/org/springframework/retry/backoff/UniformRandomBackOffPolicy.java
+++ b/src/main/java/org/springframework/retry/backoff/UniformRandomBackOffPolicy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2022 the original author or authors.
+ * Copyright 2006-2023 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@ import org.springframework.util.Assert;
  * @author Rob Harrop
  * @author Dave Syer
  * @author Tomaz Fernandes
+ * @author Marius Lichtblau
  */
 public class UniformRandomBackOffPolicy extends StatelessBackOffPolicy
 		implements SleepingBackOffPolicy<UniformRandomBackOffPolicy> {
@@ -138,6 +139,7 @@ public class UniformRandomBackOffPolicy extends StatelessBackOffPolicy
 			this.sleeper.sleep(min + delta);
 		}
 		catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
 			throw new BackOffInterruptedException(""Thread interrupted while sleeping"", e);
 		}
 	}
"
st-tu-dresden-salespoint-85a764f892aa,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.salespointframework.accountancy.AccountancyTests#addExistingEntry
Type: org.opentest4j.AssertionFailedError
Message: Adding the same AccountancyEntry more than once should result in IllegalArgumentException! ==> Expected java.lang.IllegalArgumentException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.st-tu-dresden-salespoint-85a764f892aa:msbench-0.0.1,"diff --git a/src/main/java/org/salespointframework/accountancy/PersistentAccountancy.java b/src/main/java/org/salespointframework/accountancy/PersistentAccountancy.java
index 8b57faa..6f8cab1 100755
--- a/src/main/java/org/salespointframework/accountancy/PersistentAccountancy.java
+++ b/src/main/java/org/salespointframework/accountancy/PersistentAccountancy.java
@@ -45,6 +45,7 @@ import org.springframework.util.Assert;
  * @author Hannes Weisbach
  * @author Thomas Dedek
  * @author Oliver Gierke
+ * @author Rebecca Uecker
  */
 @Service
 @Transactional
@@ -62,6 +63,7 @@ class PersistentAccountancy implements Accountancy {
 	public final <T extends AccountancyEntry> T add(T accountancyEntry) {
 
 		Assert.notNull(accountancyEntry, ""Accountancy entry must not be null!"");
+		Assert.isTrue(!repository.existsById(accountancyEntry.getId()), ""Accountancy entry must not exist in repository!"");
 
 		if (!accountancyEntry.hasDate()) {
 			accountancyEntry.setDate(businessTime.getTime());
"
stellar-java-stellar-sdk-15cc6d2c8131,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.stellar.sdk.KeyPairTest#testPublicEqual
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Test: org.stellar.sdk.KeyPairTest#testPublicPrivateNotEquals
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.stellar-java-stellar-sdk-15cc6d2c8131:msbench-0.0.1,"diff --git a/src/main/java/org/stellar/sdk/KeyPair.java b/src/main/java/org/stellar/sdk/KeyPair.java
index ec7e490..97fdcc0 100644
--- a/src/main/java/org/stellar/sdk/KeyPair.java
+++ b/src/main/java/org/stellar/sdk/KeyPair.java
@@ -308,7 +308,7 @@ public class KeyPair {
     }
 
     KeyPair other = (KeyPair) object;
-    return this.mPrivateKey.equals(other.mPrivateKey) &&
+    return Objects.equal(this.mPrivateKey, other.mPrivateKey) &&
             this.mPublicKey.equals(other.mPublicKey);
 
   }
"
stellar-java-stellar-sdk-1461c2fc5b89,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.stellar.sdk.TransactionTest#testIsSorobanTransactionBumpSequenceOperation
Type: java.lang.AssertionError
Message: java.lang.AssertionError

Test: org.stellar.sdk.TransactionTest#testIsSorobanTransactionBumpFootprintExpirationOperation
Type: java.lang.AssertionError
Message: java.lang.AssertionError

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.stellar-java-stellar-sdk-1461c2fc5b89:msbench-0.0.1,"diff --git a/src/main/java/org/stellar/sdk/Transaction.java b/src/main/java/org/stellar/sdk/Transaction.java
index 316c88c..56beee7 100644
--- a/src/main/java/org/stellar/sdk/Transaction.java
+++ b/src/main/java/org/stellar/sdk/Transaction.java
@@ -402,7 +402,7 @@ public class Transaction extends AbstractTransaction {
 
     Operation op = mOperations[0];
     return op instanceof InvokeHostFunctionOperation
-        || op instanceof BumpSequenceOperation
+        || op instanceof BumpFootprintExpirationOperation
         || op instanceof RestoreFootprintOperation;
   }
 }
"
stellar-java-stellar-sdk-6e9badb007c2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.stellar.sdk.SorobanServerTest#testPrepareTransactionWithAuth
Type: java.lang.AssertionError
Message: java.lang.AssertionError: expected:<org.stellar.sdk.Transaction@a0cf60fd> but was:<org.stellar.sdk.Transaction@58acfd75>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.stellar-java-stellar-sdk-6e9badb007c2:msbench-0.0.1,"diff --git a/src/main/java/org/stellar/sdk/SorobanServer.java b/src/main/java/org/stellar/sdk/SorobanServer.java
index 410721b..ff7f29a 100644
--- a/src/main/java/org/stellar/sdk/SorobanServer.java
+++ b/src/main/java/org/stellar/sdk/SorobanServer.java
@@ -354,7 +354,11 @@ public class SorobanServer implements Closeable {
    *     must be one of {@link InvokeHostFunctionOperation}, {@link
    *     BumpFootprintExpirationOperation}, or {@link RestoreFootprintOperation}. Any provided
    *     footprint will be ignored. You can use {@link Transaction#isSorobanTransaction()} to check
-   *     if a transaction is a Soroban transaction.
+   *     if a transaction is a Soroban transaction. Any provided footprint will be overwritten.
+   *     However, if your operation has existing auth entries, they will be preferred over ALL auth
+   *     entries from the simulation. In other words, if you include auth entries, you don't care
+   *     about the auth returned from the simulation. Other fields (footprint, etc.) will be filled
+   *     as normal.
    * @return Returns a copy of the {@link Transaction}, with the expected authorizations (in the
    *     case of invocation) and ledger footprint added. The transaction fee will also automatically
    *     be padded with the contract's minimum resource fees discovered from the simulation.
@@ -422,24 +426,30 @@ public class SorobanServer implements Closeable {
     Operation operation = transaction.getOperations()[0];
 
     if (operation instanceof InvokeHostFunctionOperation) {
-      Collection<SorobanAuthorizationEntry> originalEntries =
+      // If the operation is an InvokeHostFunctionOperation, we need to update the auth entries if
+      // existing entries are empty and the simulation result contains auth entries.
+      Collection<SorobanAuthorizationEntry> existingEntries =
           ((InvokeHostFunctionOperation) operation).getAuth();
-      List<SorobanAuthorizationEntry> newEntries = new ArrayList<>(originalEntries);
-      if (simulateHostFunctionResult.getAuth() != null) {
+      if (existingEntries.isEmpty()
+          && simulateHostFunctionResult.getAuth() != null
+          && !simulateHostFunctionResult.getAuth().isEmpty()) {
+        List<SorobanAuthorizationEntry> authorizationEntries =
+            new ArrayList<>(simulateHostFunctionResult.getAuth().size());
         for (String auth : simulateHostFunctionResult.getAuth()) {
           try {
-            newEntries.add(SorobanAuthorizationEntry.fromXdrBase64(auth));
+            authorizationEntries.add(SorobanAuthorizationEntry.fromXdrBase64(auth));
           } catch (IOException e) {
             throw new IllegalArgumentException(""Invalid auth: "" + auth, e);
           }
         }
+
+        operation =
+            InvokeHostFunctionOperation.builder()
+                .hostFunction(((InvokeHostFunctionOperation) operation).getHostFunction())
+                .sourceAccount(operation.getSourceAccount())
+                .auth(authorizationEntries)
+                .build();
       }
-      operation =
-          InvokeHostFunctionOperation.builder()
-              .hostFunction(((InvokeHostFunctionOperation) operation).getHostFunction())
-              .sourceAccount(operation.getSourceAccount())
-              .auth(newEntries)
-              .build();
     }
 
     SorobanTransactionData sorobanData;
"
traccar-traccar-046076aeb6f0,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode
Type: java.lang.IndexOutOfBoundsException
Message: java.lang.IndexOutOfBoundsException: readerIndex(26) + length(2) exceeds writerIndex(27): UnpooledHeapByteBuf(ridx: 26, widx: 27, cap: 27/27)

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-046076aeb6f0:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 15588c8..ef09677 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -803,7 +803,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 getLastLocation(position, null);
             }
 
-            if (hasLbs(type)) {
+            if (hasLbs(type) && buf.readableBytes() > 6) {
                 decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM);
             }
 
"
traccar-traccar-9ff9bd75fff9,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: expected:<lowBattery> but was:<null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-9ff9bd75fff9:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index ef09677..5b639dd 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -99,7 +99,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
     public static final int MSG_LBS_2 = 0xA1;              // GK310
     public static final int MSG_WIFI_3 = 0xA2;             // GK310
     public static final int MSG_FENCE_SINGLE = 0xA3;       // GK310
-    public static final int MSG_FENCE_MULTI = 0xA4;        // GK310
+    public static final int MSG_FENCE_MULTI = 0xA4;        // GK310 & JM-LL301
     public static final int MSG_LBS_ALARM = 0xA5;          // GK310 & JM-LL301
     public static final int MSG_LBS_ADDRESS = 0xA7;        // GK310
     public static final int MSG_OBD = 0x8C;                // FM08ABC
@@ -209,6 +209,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             case MSG_GPS_LBS_STATUS_2:
             case MSG_GPS_LBS_STATUS_3:
             case MSG_GPS_LBS_STATUS_4:
+            case MSG_FENCE_MULTI:
             case MSG_LBS_ALARM:
                 return true;
             default:
@@ -804,7 +805,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             }
 
             if (hasLbs(type) && buf.readableBytes() > 6) {
-                decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM);
+                decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM && type != MSG_LBS_STATUS);
             }
 
             if (hasStatus(type)) {
"
traccar-traccar-b77131f4be38,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchProtocolDecoderTest#testDecode
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-b77131f4be38:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
index 142d1b6..6fb626d 100644
--- a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
@@ -263,7 +263,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
             Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));
 
             if (type.startsWith(""AL"")) {
-                if (position != null) {
+                if (position != null && !position.hasAttribute(Position.KEY_ALARM)) {
                     position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);
                 }
                 sendResponse(channel, id, index, ""AL"");
@@ -279,6 +279,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 || type.equalsIgnoreCase(""HEART"")
                 || type.equalsIgnoreCase(""BLOOD"")
                 || type.equalsIgnoreCase(""BPHRT"")
+                || type.equalsIgnoreCase(""TEMP"")
                 || type.equalsIgnoreCase(""btemp2"")) {
 
             if (buf.isReadable()) {
@@ -291,7 +292,9 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 String[] values = buf.toString(StandardCharsets.US_ASCII).split("","");
                 int valueIndex = 0;
 
-                if (type.equalsIgnoreCase(""btemp2"")) {
+                if (type.equalsIgnoreCase(""TEMP"")) {
+                    position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));
+                } else if (type.equalsIgnoreCase(""btemp2"")) {
                     if (Integer.parseInt(values[valueIndex++]) > 0) {
                         position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));
                     }
"
traccar-traccar-4722f9b6b648,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.GalileoProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: time < +25 hours

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-4722f9b6b648:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java b/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
index b5c6f77..d4bd45c 100644
--- a/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
@@ -272,10 +272,10 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
 
     private Position decodeIridiumPosition(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {
 
-        buf.readUnsignedShortLE(); // length
+        buf.readUnsignedShort(); // length
 
         buf.skipBytes(3); // identification header
-        buf.readUnsignedIntLE(); // index
+        buf.readUnsignedInt(); // index
 
         DeviceSession deviceSession = getDeviceSession(
                 channel, remoteAddress, buf.readSlice(15).toString(StandardCharsets.US_ASCII));
@@ -288,12 +288,19 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
 
         buf.readUnsignedByte(); // session status
         buf.skipBytes(4); // reserved
-        buf.readUnsignedIntLE(); // date and time
-
-        buf.skipBytes(23); // coordinates block
-
-        buf.skipBytes(3); // data tag header
-        decodeMinimalDataSet(position, buf);
+        position.setTime(new Date(buf.readUnsignedInt() * 1000));
+
+        buf.skipBytes(3); // coordinates header
+        int flags = buf.readUnsignedByte();
+        double latitude = buf.readUnsignedByte() + buf.readUnsignedShort() / 60000.0;
+        double longitude = buf.readUnsignedByte() + buf.readUnsignedShort() / 60000.0;
+        position.setLatitude(BitUtil.check(flags, 1) ? -latitude : latitude);
+        position.setLongitude(BitUtil.check(flags, 0) ? -longitude : longitude);
+        buf.readUnsignedInt(); // accuracy
+
+        buf.readUnsignedByte(); // data tag header
+        // ByteBuf data = buf.readSlice(buf.readUnsignedShort());
+        // decodeMinimalDataSet(position, data);
 
         return position;
     }
"
traccar-traccar-3771dd156efb,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchProtocolDecoderTest#testDecode
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""FFFF""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-3771dd156efb:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
index 6fb626d..e100d0d 100644
--- a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
@@ -139,41 +139,45 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
         String[] values = parser.next().split("","");
         int index = 0;
 
-        Network network = new Network();
-
-        int cellCount = Integer.parseInt(values[index++]);
-        if (cellCount > 0) {
-            index += 1; // timing advance
-            int mcc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
-            int mnc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
-
-            for (int i = 0; i < cellCount; i++) {
-                int lac = Integer.parseInt(values[index++]);
-                int cid = Integer.parseInt(values[index++]);
-                String rssi = values[index++];
-                if (!rssi.isEmpty()) {
-                    network.addCellTower(CellTower.from(mcc, mnc, lac, cid, Integer.parseInt(rssi)));
-                } else {
-                    network.addCellTower(CellTower.from(mcc, mnc, lac, cid));
+        if (values.length < 4 || !values[index + 3].startsWith(""F"")) {
+
+            Network network = new Network();
+
+            int cellCount = Integer.parseInt(values[index++]);
+            if (cellCount > 0) {
+                index += 1; // timing advance
+                int mcc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
+                int mnc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
+
+                for (int i = 0; i < cellCount; i++) {
+                    int lac = Integer.parseInt(values[index++]);
+                    int cid = Integer.parseInt(values[index++]);
+                    String rssi = values[index++];
+                    if (!rssi.isEmpty()) {
+                        network.addCellTower(CellTower.from(mcc, mnc, lac, cid, Integer.parseInt(rssi)));
+                    } else {
+                        network.addCellTower(CellTower.from(mcc, mnc, lac, cid));
+                    }
                 }
             }
-        }
 
-        if (index < values.length && !values[index].isEmpty()) {
-            int wifiCount = Integer.parseInt(values[index++]);
+            if (index < values.length && !values[index].isEmpty()) {
+                int wifiCount = Integer.parseInt(values[index++]);
 
-            for (int i = 0; i < wifiCount; i++) {
-                index += 1; // wifi name
-                String macAddress = values[index++];
-                String rssi = values[index++];
-                if (!macAddress.isEmpty() && !macAddress.equals(""0"") && !rssi.isEmpty()) {
-                    network.addWifiAccessPoint(WifiAccessPoint.from(macAddress, Integer.parseInt(rssi)));
+                for (int i = 0; i < wifiCount; i++) {
+                    index += 1; // wifi name
+                    String macAddress = values[index++];
+                    String rssi = values[index++];
+                    if (!macAddress.isEmpty() && !macAddress.equals(""0"") && !rssi.isEmpty()) {
+                        network.addWifiAccessPoint(WifiAccessPoint.from(macAddress, Integer.parseInt(rssi)));
+                    }
                 }
             }
-        }
 
-        if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
-            position.setNetwork(network);
+            if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
+                position.setNetwork(network);
+            }
+
         }
 
         return position;
"
traccar-traccar-1c91d35263f1,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchProtocolDecoderTest#testDecode
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""55C0""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-1c91d35263f1:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/helper/StringUtil.java b/src/main/java/org/traccar/helper/StringUtil.java
new file mode 100644
index 0000000..9b4d717
--- a/src/main/java/org/traccar/helper/StringUtil.java
+++ b/src/main/java/org/traccar/helper/StringUtil.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.helper;
+
+public final class StringUtil {
+
+    private StringUtil() {
+    }
+
+    public static boolean containsHex(String value) {
+        for (char c : value.toCharArray()) {
+            if (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F') {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
diff --git a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
index e100d0d..40d56b1 100644
--- a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2015 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.StringUtil;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
@@ -139,7 +140,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
         String[] values = parser.next().split("","");
         int index = 0;
 
-        if (values.length < 4 || !values[index + 3].startsWith(""F"")) {
+        if (values.length < 4 || !StringUtil.containsHex(values[index + 3])) {
 
             Network network = new Network();
 
@@ -150,8 +151,8 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 int mnc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
 
                 for (int i = 0; i < cellCount; i++) {
-                    int lac = Integer.parseInt(values[index++]);
-                    int cid = Integer.parseInt(values[index++]);
+                    int lac = Integer.parseInt(values[index], StringUtil.containsHex(values[index++]) ? 16 : 10);
+                    int cid = Integer.parseInt(values[index], StringUtil.containsHex(values[index++]) ? 16 : 10);
                     String rssi = values[index++];
                     if (!rssi.isEmpty()) {
                         network.addCellTower(CellTower.from(mcc, mnc, lac, cid, Integer.parseInt(rssi)));
"
traccar-traccar-b4934e05aab6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchProtocolDecoderTest#testDecode
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""55C0""

Test: org.traccar.protocol.GalileoProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: time < +25 hours

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-b4934e05aab6:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/api/resource/CommandResource.java b/src/main/java/org/traccar/api/resource/CommandResource.java
index 6ef6ee9..3460cf6 100644
--- a/src/main/java/org/traccar/api/resource/CommandResource.java
+++ b/src/main/java/org/traccar/api/resource/CommandResource.java
@@ -105,7 +105,6 @@ public class CommandResource extends ExtendedObjectResource<Command> {
     @POST
     @Path(""send"")
     public Response send(Command entity) throws Exception {
-        permissionsService.checkRestriction(getUserId(), UserRestrictions::getReadonly);
         if (entity.getId() > 0) {
             permissionsService.checkPermission(baseClass, getUserId(), entity.getId());
             long deviceId = entity.getDeviceId();
diff --git a/src/main/java/org/traccar/api/resource/ReportResource.java b/src/main/java/org/traccar/api/resource/ReportResource.java
index 70177dd..6944de9 100644
--- a/src/main/java/org/traccar/api/resource/ReportResource.java
+++ b/src/main/java/org/traccar/api/resource/ReportResource.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2016 - 2023 Anton Tananaev (anton@traccar.org)
  * Copyright 2016 - 2018 Andrey Kunitsyn (andrey@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
@@ -19,27 +19,23 @@ package org.traccar.api.resource;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.traccar.api.BaseResource;
-import org.traccar.mail.MailManager;
 import org.traccar.helper.LogAction;
 import org.traccar.model.Event;
 import org.traccar.model.Position;
-import org.traccar.model.User;
 import org.traccar.model.UserRestrictions;
 import org.traccar.reports.EventsReportProvider;
 import org.traccar.reports.RouteReportProvider;
 import org.traccar.reports.StopsReportProvider;
 import org.traccar.reports.SummaryReportProvider;
 import org.traccar.reports.TripsReportProvider;
+import org.traccar.reports.common.ReportExecutor;
+import org.traccar.reports.common.ReportMailer;
 import org.traccar.reports.model.StopReportItem;
 import org.traccar.reports.model.SummaryReportItem;
 import org.traccar.reports.model.TripReportItem;
 import org.traccar.storage.StorageException;
 
-import javax.activation.DataHandler;
 import javax.inject.Inject;
-import javax.mail.MessagingException;
-import javax.mail.internet.MimeBodyPart;
-import javax.mail.util.ByteArrayDataSource;
 import javax.ws.rs.Consumes;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
@@ -51,9 +47,6 @@ import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response;
 import javax.ws.rs.core.StreamingOutput;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
 import java.util.Collection;
 import java.util.Date;
 import java.util.List;
@@ -83,31 +76,11 @@ public class ReportResource extends BaseResource {
     private TripsReportProvider tripsReportProvider;
 
     @Inject
-    private MailManager mailManager;
+    private ReportMailer reportMailer;
 
-    private interface ReportExecutor {
-        void execute(OutputStream stream) throws StorageException, IOException;
-    }
-
-    private Response executeReport(
-            long userId, boolean mail, ReportExecutor executor) {
+    private Response executeReport(long userId, boolean mail, ReportExecutor executor) {
         if (mail) {
-            new Thread(() -> {
-                try {
-                    var stream = new ByteArrayOutputStream();
-                    executor.execute(stream);
-
-                    MimeBodyPart attachment = new MimeBodyPart();
-                    attachment.setFileName(""report.xlsx"");
-                    attachment.setDataHandler(new DataHandler(new ByteArrayDataSource(
-                            stream.toByteArray(), ""application/octet-stream"")));
-
-                    User user = permissionsService.getUser(userId);
-                    mailManager.sendMessage(user, ""Report"", ""The report is in the attachment."", attachment);
-                } catch (StorageException | IOException | MessagingException e) {
-                    LOGGER.warn(""Report failed"", e);
-                }
-            }).start();
+            reportMailer.sendAsync(userId, executor);
             return Response.noContent().build();
         } else {
             StreamingOutput stream = output -> {
diff --git a/src/main/java/org/traccar/handler/ComputedAttributesHandler.java b/src/main/java/org/traccar/handler/ComputedAttributesHandler.java
index c9f1f63..6208525 100644
--- a/src/main/java/org/traccar/handler/ComputedAttributesHandler.java
+++ b/src/main/java/org/traccar/handler/ComputedAttributesHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2017 - 2023 Anton Tananaev (anton@traccar.org)
  * Copyright 2017 Andrey Kunitsyn (andrey@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
@@ -116,17 +116,45 @@ public class ComputedAttributesHandler extends BaseDataHandler {
                 }
                 if (result != null) {
                     try {
-                        switch (attribute.getType()) {
-                            case ""number"":
-                                Number numberValue = (Number) result;
-                                position.getAttributes().put(attribute.getAttribute(), numberValue);
+                        switch (attribute.getAttribute()) {
+                            case ""valid"":
+                                position.setValid((Boolean) result);
                                 break;
-                            case ""boolean"":
-                                Boolean booleanValue = (Boolean) result;
-                                position.getAttributes().put(attribute.getAttribute(), booleanValue);
+                            case ""latitude"":
+                                position.setLatitude(((Number) result).doubleValue());
+                                break;
+                            case ""longitude"":
+                                position.setLongitude(((Number) result).doubleValue());
+                                break;
+                            case ""altitude"":
+                                position.setAltitude(((Number) result).doubleValue());
+                                break;
+                            case ""speed"":
+                                position.setSpeed(((Number) result).doubleValue());
+                                break;
+                            case ""course"":
+                                position.setCourse(((Number) result).doubleValue());
+                                break;
+                            case ""address"":
+                                position.setAddress((String) result);
+                                break;
+                            case ""accuracy"":
+                                position.setAccuracy(((Number) result).doubleValue());
                                 break;
                             default:
-                                position.getAttributes().put(attribute.getAttribute(), result.toString());
+                                switch (attribute.getType()) {
+                                    case ""number"":
+                                        Number numberValue = (Number) result;
+                                        position.getAttributes().put(attribute.getAttribute(), numberValue);
+                                        break;
+                                    case ""boolean"":
+                                        Boolean booleanValue = (Boolean) result;
+                                        position.getAttributes().put(attribute.getAttribute(), booleanValue);
+                                        break;
+                                    default:
+                                        position.getAttributes().put(attribute.getAttribute(), result.toString());
+                                }
+                                break;
                         }
                     } catch (ClassCastException error) {
                         LOGGER.warn(""Attribute cast error"", error);
diff --git a/src/main/java/org/traccar/helper/ClassScanner.java b/src/main/java/org/traccar/helper/ClassScanner.java
index c928f6a..c201d10 100644
--- a/src/main/java/org/traccar/helper/ClassScanner.java
+++ b/src/main/java/org/traccar/helper/ClassScanner.java
@@ -46,7 +46,7 @@ public final class ClassScanner {
         URL packageUrl = baseClass.getClassLoader().getResource(packagePath);
 
         if (packageUrl.getProtocol().equals(""jar"")) {
-            String jarFileName = URLDecoder.decode(packageUrl.getFile(), StandardCharsets.UTF_8.name());
+            String jarFileName = URLDecoder.decode(packageUrl.getFile(), StandardCharsets.UTF_8);
             try (JarFile jf = new JarFile(jarFileName.substring(5, jarFileName.indexOf(""!"")))) {
                 Enumeration<JarEntry> jarEntries = jf.entries();
                 while (jarEntries.hasMoreElements()) {
diff --git a/src/main/java/org/traccar/helper/StringUtil.java b/src/main/java/org/traccar/helper/StringUtil.java
new file mode 100644
index 0000000..9b4d717
--- a/src/main/java/org/traccar/helper/StringUtil.java
+++ b/src/main/java/org/traccar/helper/StringUtil.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.helper;
+
+public final class StringUtil {
+
+    private StringUtil() {
+    }
+
+    public static boolean containsHex(String value) {
+        for (char c : value.toCharArray()) {
+            if (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F') {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
diff --git a/src/main/java/org/traccar/model/Report.java b/src/main/java/org/traccar/model/Report.java
new file mode 100644
index 0000000..83bb2e9
--- a/src/main/java/org/traccar/model/Report.java
+++ b/src/main/java/org/traccar/model/Report.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2022 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.model;
+
+import org.traccar.storage.StorageName;
+
+import java.util.Date;
+
+@StorageName(""tc_reports"")
+public class Report extends ScheduledModel {
+
+    private String type;
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    private String description;
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    private Date from;
+
+    public Date getFrom() {
+        return from;
+    }
+
+    public void setFrom(Date from) {
+        this.from = from;
+    }
+
+    private Date to;
+
+    public Date getTo() {
+        return to;
+    }
+
+    public void setTo(Date to) {
+        this.to = to;
+    }
+
+}
diff --git a/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java b/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
index fc8a49c..d4bd45c 100644
--- a/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/GalileoProtocolDecoder.java
@@ -23,6 +23,7 @@ import org.traccar.BaseProtocolDecoder;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
 import org.traccar.helper.BitBuffer;
+import org.traccar.helper.BitUtil;
 import org.traccar.helper.UnitsConverter;
 import org.traccar.model.Position;
 import org.traccar.session.DeviceSession;
@@ -66,7 +67,7 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
         };
         int[] l3 = {
             0x63, 0x64, 0x6f, 0x5d, 0x65, 0x66, 0x67, 0x68,
-            0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e
+            0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0xfa
         };
         int[] l4 = {
             0x20, 0x33, 0x44, 0x90, 0xc0, 0xc2, 0xc3, 0xd3,
@@ -88,6 +89,8 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
         }
         TAG_LENGTH_MAP.put(0x5b, 7); // variable length
         TAG_LENGTH_MAP.put(0x5c, 68);
+        TAG_LENGTH_MAP.put(0xfd, 8);
+        TAG_LENGTH_MAP.put(0xfe, 8);
     }
 
     private static int getTagLength(int tag) {
@@ -239,6 +242,8 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
             }
         } else if (header == 0x07) {
             return decodePhoto(channel, remoteAddress, buf);
+        } else if (header == 0x08) {
+            return decodeCompressedPositions(channel, remoteAddress, buf);
         }
 
         return null;
@@ -259,7 +264,7 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
 
         position.setValid(bits.readUnsigned(1) == 0);
         position.setLongitude(360 * bits.readUnsigned(22) / 4194304.0 - 180);
-        position.setLatitude(360 * bits.readUnsigned(21) / 2097152.0 - 90);
+        position.setLatitude(180 * bits.readUnsigned(21) / 2097152.0 - 90);
         if (bits.readUnsigned(1) > 0) {
             position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);
         }
@@ -267,10 +272,10 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
 
     private Position decodeIridiumPosition(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {
 
-        buf.readUnsignedShortLE(); // length
+        buf.readUnsignedShort(); // length
 
         buf.skipBytes(3); // identification header
-        buf.readUnsignedIntLE(); // index
+        buf.readUnsignedInt(); // index
 
         DeviceSession deviceSession = getDeviceSession(
                 channel, remoteAddress, buf.readSlice(15).toString(StandardCharsets.US_ASCII));
@@ -283,12 +288,19 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
 
         buf.readUnsignedByte(); // session status
         buf.skipBytes(4); // reserved
-        buf.readUnsignedIntLE(); // date and time
+        position.setTime(new Date(buf.readUnsignedInt() * 1000));
 
-        buf.skipBytes(23); // coordinates block
+        buf.skipBytes(3); // coordinates header
+        int flags = buf.readUnsignedByte();
+        double latitude = buf.readUnsignedByte() + buf.readUnsignedShort() / 60000.0;
+        double longitude = buf.readUnsignedByte() + buf.readUnsignedShort() / 60000.0;
+        position.setLatitude(BitUtil.check(flags, 1) ? -latitude : latitude);
+        position.setLongitude(BitUtil.check(flags, 0) ? -longitude : longitude);
+        buf.readUnsignedInt(); // accuracy
 
-        buf.skipBytes(3); // data tag header
-        decodeMinimalDataSet(position, buf);
+        buf.readUnsignedByte(); // data tag header
+        // ByteBuf data = buf.readSlice(buf.readUnsignedShort());
+        // decodeMinimalDataSet(position, data);
 
         return position;
     }
@@ -392,4 +404,43 @@ public class GalileoProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
+    private List<Position> decodeCompressedPositions(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {
+
+        buf.readUnsignedShortLE(); // length
+
+        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);
+        if (deviceSession == null) {
+            return null;
+        }
+
+        List<Position> positions = new LinkedList<>();
+        while (buf.readableBytes() > 2) {
+
+            Position position = new Position(getProtocolName());
+            position.setDeviceId(deviceSession.getDeviceId());
+
+            decodeMinimalDataSet(position, buf);
+
+            int[] tags = new int[BitUtil.to(buf.readUnsignedByte(), 8)];
+            for (int i = 0; i < tags.length; i++) {
+                tags[i] = buf.readUnsignedByte();
+            }
+
+            for (int tag : tags) {
+                decodeTag(position, buf, tag);
+            }
+
+            positions.add(position);
+
+        }
+
+        sendResponse(channel, 0x02, buf.readUnsignedShortLE());
+
+        for (Position p : positions) {
+            p.setDeviceId(deviceSession.getDeviceId());
+        }
+
+        return positions.isEmpty() ? null : positions;
+    }
+
 }
diff --git a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
index 142d1b6..40d56b1 100644
--- a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2015 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.StringUtil;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
@@ -139,41 +140,45 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
         String[] values = parser.next().split("","");
         int index = 0;
 
-        Network network = new Network();
+        if (values.length < 4 || !StringUtil.containsHex(values[index + 3])) {
 
-        int cellCount = Integer.parseInt(values[index++]);
-        if (cellCount > 0) {
-            index += 1; // timing advance
-            int mcc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
-            int mnc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
+            Network network = new Network();
 
-            for (int i = 0; i < cellCount; i++) {
-                int lac = Integer.parseInt(values[index++]);
-                int cid = Integer.parseInt(values[index++]);
-                String rssi = values[index++];
-                if (!rssi.isEmpty()) {
-                    network.addCellTower(CellTower.from(mcc, mnc, lac, cid, Integer.parseInt(rssi)));
-                } else {
-                    network.addCellTower(CellTower.from(mcc, mnc, lac, cid));
+            int cellCount = Integer.parseInt(values[index++]);
+            if (cellCount > 0) {
+                index += 1; // timing advance
+                int mcc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
+                int mnc = !values[index].isEmpty() ? Integer.parseInt(values[index++]) : 0;
+
+                for (int i = 0; i < cellCount; i++) {
+                    int lac = Integer.parseInt(values[index], StringUtil.containsHex(values[index++]) ? 16 : 10);
+                    int cid = Integer.parseInt(values[index], StringUtil.containsHex(values[index++]) ? 16 : 10);
+                    String rssi = values[index++];
+                    if (!rssi.isEmpty()) {
+                        network.addCellTower(CellTower.from(mcc, mnc, lac, cid, Integer.parseInt(rssi)));
+                    } else {
+                        network.addCellTower(CellTower.from(mcc, mnc, lac, cid));
+                    }
                 }
             }
-        }
 
-        if (index < values.length && !values[index].isEmpty()) {
-            int wifiCount = Integer.parseInt(values[index++]);
+            if (index < values.length && !values[index].isEmpty()) {
+                int wifiCount = Integer.parseInt(values[index++]);
 
-            for (int i = 0; i < wifiCount; i++) {
-                index += 1; // wifi name
-                String macAddress = values[index++];
-                String rssi = values[index++];
-                if (!macAddress.isEmpty() && !macAddress.equals(""0"") && !rssi.isEmpty()) {
-                    network.addWifiAccessPoint(WifiAccessPoint.from(macAddress, Integer.parseInt(rssi)));
+                for (int i = 0; i < wifiCount; i++) {
+                    index += 1; // wifi name
+                    String macAddress = values[index++];
+                    String rssi = values[index++];
+                    if (!macAddress.isEmpty() && !macAddress.equals(""0"") && !rssi.isEmpty()) {
+                        network.addWifiAccessPoint(WifiAccessPoint.from(macAddress, Integer.parseInt(rssi)));
+                    }
                 }
             }
-        }
 
-        if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
-            position.setNetwork(network);
+            if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
+                position.setNetwork(network);
+            }
+
         }
 
         return position;
@@ -263,7 +268,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
             Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));
 
             if (type.startsWith(""AL"")) {
-                if (position != null) {
+                if (position != null && !position.hasAttribute(Position.KEY_ALARM)) {
                     position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);
                 }
                 sendResponse(channel, id, index, ""AL"");
@@ -279,6 +284,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 || type.equalsIgnoreCase(""HEART"")
                 || type.equalsIgnoreCase(""BLOOD"")
                 || type.equalsIgnoreCase(""BPHRT"")
+                || type.equalsIgnoreCase(""TEMP"")
                 || type.equalsIgnoreCase(""btemp2"")) {
 
             if (buf.isReadable()) {
@@ -291,7 +297,9 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 String[] values = buf.toString(StandardCharsets.US_ASCII).split("","");
                 int valueIndex = 0;
 
-                if (type.equalsIgnoreCase(""btemp2"")) {
+                if (type.equalsIgnoreCase(""TEMP"")) {
+                    position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));
+                } else if (type.equalsIgnoreCase(""btemp2"")) {
                     if (Integer.parseInt(values[valueIndex++]) > 0) {
                         position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));
                     }
diff --git a/src/main/java/org/traccar/reports/common/ReportExecutor.java b/src/main/java/org/traccar/reports/common/ReportExecutor.java
new file mode 100644
index 0000000..aed4b8c
--- a/src/main/java/org/traccar/reports/common/ReportExecutor.java
+++ b/src/main/java/org/traccar/reports/common/ReportExecutor.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.reports.common;
+
+import org.traccar.storage.StorageException;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+public interface ReportExecutor {
+    void execute(OutputStream stream) throws StorageException, IOException;
+}
diff --git a/src/main/java/org/traccar/reports/common/ReportMailer.java b/src/main/java/org/traccar/reports/common/ReportMailer.java
new file mode 100644
index 0000000..1723c0e
--- a/src/main/java/org/traccar/reports/common/ReportMailer.java
+++ b/src/main/java/org/traccar/reports/common/ReportMailer.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.reports.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.traccar.mail.MailManager;
+import org.traccar.model.User;
+import org.traccar.storage.Storage;
+import org.traccar.storage.StorageException;
+import org.traccar.storage.query.Columns;
+import org.traccar.storage.query.Condition;
+import org.traccar.storage.query.Request;
+
+import javax.activation.DataHandler;
+import javax.inject.Inject;
+import javax.mail.MessagingException;
+import javax.mail.internet.MimeBodyPart;
+import javax.mail.util.ByteArrayDataSource;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+public class ReportMailer {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ReportMailer.class);
+
+    private final Storage storage;
+    private final MailManager mailManager;
+
+    @Inject
+    public ReportMailer(Storage storage, MailManager mailManager) {
+        this.storage = storage;
+        this.mailManager = mailManager;
+    }
+
+    public void sendAsync(long userId, ReportExecutor executor) {
+        new Thread(() -> {
+            try {
+                var stream = new ByteArrayOutputStream();
+                executor.execute(stream);
+
+                MimeBodyPart attachment = new MimeBodyPart();
+                attachment.setFileName(""report.xlsx"");
+                attachment.setDataHandler(new DataHandler(new ByteArrayDataSource(
+                        stream.toByteArray(), ""application/octet-stream"")));
+
+                User user = storage.getObject(
+                        User.class, new Request(new Columns.All(), new Condition.Equals(""id"", userId)));
+                mailManager.sendMessage(user, ""Report"", ""The report is in the attachment."", attachment);
+            } catch (StorageException | IOException | MessagingException e) {
+                LOGGER.warn(""Email report failed"", e);
+            }
+        }).start();
+    }
+
+}
diff --git a/src/main/java/org/traccar/schedule/ScheduleManager.java b/src/main/java/org/traccar/schedule/ScheduleManager.java
index 6412a18..e1de3b3 100644
--- a/src/main/java/org/traccar/schedule/ScheduleManager.java
+++ b/src/main/java/org/traccar/schedule/ScheduleManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2020 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -38,8 +38,12 @@ public class ScheduleManager implements LifecycleObject {
     @Override
     public void start() {
         executor = Executors.newSingleThreadScheduledExecutor();
-        List.of(TaskDeviceInactivityCheck.class, TaskWebSocketKeepalive.class, TaskHealthCheck.class)
-                .forEach(task -> injector.getInstance(task).schedule(executor));
+        var tasks = List.of(
+                TaskReports.class,
+                TaskDeviceInactivityCheck.class,
+                TaskWebSocketKeepalive.class,
+                TaskHealthCheck.class);
+        tasks.forEach(task -> injector.getInstance(task).schedule(executor));
     }
 
     @Override
diff --git a/src/main/java/org/traccar/schedule/TaskReports.java b/src/main/java/org/traccar/schedule/TaskReports.java
new file mode 100644
index 0000000..259eb10
--- a/src/main/java/org/traccar/schedule/TaskReports.java
+++ b/src/main/java/org/traccar/schedule/TaskReports.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.schedule;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.traccar.model.BaseModel;
+import org.traccar.model.Calendar;
+import org.traccar.model.Device;
+import org.traccar.model.Group;
+import org.traccar.model.Report;
+import org.traccar.model.User;
+import org.traccar.reports.EventsReportProvider;
+import org.traccar.reports.RouteReportProvider;
+import org.traccar.reports.StopsReportProvider;
+import org.traccar.reports.SummaryReportProvider;
+import org.traccar.reports.TripsReportProvider;
+import org.traccar.reports.common.ReportMailer;
+import org.traccar.storage.Storage;
+import org.traccar.storage.StorageException;
+import org.traccar.storage.query.Columns;
+import org.traccar.storage.query.Condition;
+import org.traccar.storage.query.Request;
+
+import javax.inject.Inject;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+public class TaskReports implements ScheduleTask {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TaskReports.class);
+
+    private static final long CHECK_PERIOD_MINUTES = 1;
+
+    private final Storage storage;
+    private final ReportMailer reportMailer;
+
+    @Inject
+    private EventsReportProvider eventsReportProvider;
+
+    @Inject
+    private RouteReportProvider routeReportProvider;
+
+    @Inject
+    private StopsReportProvider stopsReportProvider;
+
+    @Inject
+    private SummaryReportProvider summaryReportProvider;
+
+    @Inject
+    private TripsReportProvider tripsReportProvider;
+
+    @Inject
+    public TaskReports(Storage storage, ReportMailer reportMailer) {
+        this.storage = storage;
+        this.reportMailer = reportMailer;
+    }
+
+    @Override
+    public void schedule(ScheduledExecutorService executor) {
+        executor.scheduleAtFixedRate(this, CHECK_PERIOD_MINUTES, CHECK_PERIOD_MINUTES, TimeUnit.MINUTES);
+    }
+
+    @Override
+    public void run() {
+        Date currentCheck = new Date();
+        Date lastCheck = new Date(System.currentTimeMillis() - TimeUnit.MINUTES.toMillis(CHECK_PERIOD_MINUTES));
+
+        try {
+            for (Report report : storage.getObjects(Report.class, new Request(new Columns.All()))) {
+                Calendar calendar = storage.getObject(Calendar.class, new Request(
+                        new Columns.All(), new Condition.Equals(""id"", report.getCalendarId())));
+                if (calendar.checkMoment(currentCheck) && !calendar.checkMoment(lastCheck)) {
+                    executeReport(report);
+                }
+            }
+        } catch (StorageException e) {
+            LOGGER.warn(""Scheduled reports error"", e);
+        }
+    }
+
+    private void executeReport(Report report) throws StorageException {
+        var deviceIds = storage.getObjects(Device.class, new Request(
+                new Columns.Include(""id""),
+                new Condition.Permission(Device.class, Report.class, report.getId())))
+                .stream().map(BaseModel::getId).collect(Collectors.toList());
+        var groupIds = storage.getObjects(Group.class, new Request(
+                new Columns.Include(""id""),
+                new Condition.Permission(Group.class, Report.class, report.getId())))
+                .stream().map(BaseModel::getId).collect(Collectors.toList());
+        var users = storage.getObjects(User.class, new Request(
+                new Columns.Include(""id""),
+                new Condition.Permission(User.class, Report.class, report.getId())));
+        for (User user : users) {
+            switch (report.getType()) {
+                case ""events"":
+                    reportMailer.sendAsync(user.getId(), stream -> {
+                        eventsReportProvider.getExcel(
+                                stream, user.getId(), deviceIds, groupIds,
+                                List.of(), report.getFrom(), report.getTo());
+                    });
+                    break;
+                case ""route"":
+                    reportMailer.sendAsync(user.getId(), stream -> {
+                        routeReportProvider.getExcel(
+                                stream, user.getId(), deviceIds, groupIds,
+                                report.getFrom(), report.getTo());
+                    });
+                    break;
+                case ""summary"":
+                    reportMailer.sendAsync(user.getId(), stream -> {
+                        summaryReportProvider.getExcel(
+                                stream, user.getId(), deviceIds, groupIds,
+                                report.getFrom(), report.getTo(), false);
+                    });
+                    break;
+                case ""trips"":
+                    reportMailer.sendAsync(user.getId(), stream -> {
+                        tripsReportProvider.getExcel(
+                                stream, user.getId(), deviceIds, groupIds,
+                                report.getFrom(), report.getTo());
+                    });
+                    break;
+                case ""stops"":
+                    reportMailer.sendAsync(user.getId(), stream -> {
+                        stopsReportProvider.getExcel(
+                                stream, user.getId(), deviceIds, groupIds,
+                                report.getFrom(), report.getTo());
+                    });
+                    break;
+                default:
+                    LOGGER.warn(""Unsupported report type {}"", report.getType());
+                    break;
+            }
+        }
+    }
+
+}
"
traccar-traccar-514582dd83c4,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TramigoFrameDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: buffer is null

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-514582dd83c4:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TramigoFrameDecoder.java b/src/main/java/org/traccar/protocol/TramigoFrameDecoder.java
index e4c94dc..4b0fe52 100644
--- a/src/main/java/org/traccar/protocol/TramigoFrameDecoder.java
+++ b/src/main/java/org/traccar/protocol/TramigoFrameDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 - 2019 Anton Tananaev (anton@traccar.org)
+ * Copyright 2015 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -33,7 +33,7 @@ public class TramigoFrameDecoder extends BaseFrameDecoder {
         if (buf.getUnsignedByte(buf.readerIndex()) == 0x80) {
             length = buf.getUnsignedShortLE(buf.readerIndex() + 6);
         } else {
-            length = buf.getUnsignedShort(buf.readerIndex() + 6);
+            length = buf.getUnsignedShortLE(buf.readerIndex() + 1);
         }
 
         if (length <= buf.readableBytes()) {
"
traccar-traccar-33af2928a581,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MeitrackProtocolDecoderTest#testDecode
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-33af2928a581:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
index 343141d..a7accf0 100644
--- a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2012 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -510,6 +510,9 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                     case 0x0D:
                         position.set(""runtime"", buf.readUnsignedIntLE());
                         break;
+                    case 0x25:
+                        position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(buf.readUnsignedIntLE()));
+                        break;
                     case 0xA0:
                         position.set(Position.KEY_FUEL_USED, buf.readUnsignedIntLE() * 0.001);
                         break;
@@ -624,6 +627,13 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                 photo = Unpooled.buffer();
                 requestPhotoPacket(channel, remoteAddress, imei, ""camera_picture.jpg"", 0);
                 return null;
+            case ""D82"":
+                Position position = new Position(getProtocolName());
+                position.setDeviceId(getDeviceSession(channel, remoteAddress, imei).getDeviceId());
+                getLastLocation(position, null);
+                String result = buf.toString(index + 1, buf.writerIndex() - index - 4, StandardCharsets.US_ASCII);
+                position.set(Position.KEY_RESULT, result);
+                return position;
             case ""CCC"":
                 return decodeBinaryC(channel, remoteAddress, buf);
             case ""CCE"":
"
traccar-traccar-782fd787d14b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TramigoProtocolDecoderTest#testDecode
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Latitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-782fd787d14b:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TramigoProtocolDecoder.java b/src/main/java/org/traccar/protocol/TramigoProtocolDecoder.java
index 1296929..ddd669b 100644
--- a/src/main/java/org/traccar/protocol/TramigoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TramigoProtocolDecoder.java
@@ -153,8 +153,8 @@ public class TramigoProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_STATUS, status);
 
                     position.setValid(true);
-                    position.setLatitude(buf.readInt() * 0.00001);
-                    position.setLongitude(buf.readInt() * 0.00001);
+                    position.setLatitude(buf.readIntLE() * 0.00001);
+                    position.setLongitude(buf.readIntLE() * 0.00001);
                     position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));
                     position.setCourse(buf.readUnsignedShortLE());
 
@@ -172,7 +172,7 @@ public class TramigoProtocolDecoder extends BaseProtocolDecoder {
                     buf.readUnsignedByte(); // reserved
                     break;
                 case 1:
-                    buf.skipBytes(buf.readUnsignedShortLE()); // landmark
+                    buf.skipBytes(buf.readUnsignedShortLE() - 3); // landmark
                     break;
                 case 4:
                     buf.skipBytes(53); // trip
@@ -191,7 +191,7 @@ public class TramigoProtocolDecoder extends BaseProtocolDecoder {
                     buf.skipBytes(40); // analog
                     break;
                 case 50:
-                    buf.skipBytes(buf.readUnsignedShortLE()); // console
+                    buf.skipBytes(buf.readUnsignedShortLE() - 3); // console
                     break;
                 case 255:
                     buf.skipBytes(4); // acknowledgement
"
traccar-traccar-a722658e5a3c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TotemProtocolDecoderTest#testDecode
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-a722658e5a3c:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TotemProtocolDecoder.java b/src/main/java/org/traccar/protocol/TotemProtocolDecoder.java
index fc3dce8..6f039c3 100644
--- a/src/main/java/org/traccar/protocol/TotemProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TotemProtocolDecoder.java
@@ -176,7 +176,21 @@ public class TotemProtocolDecoder extends BaseProtocolDecoder {
             .any()
             .compile();
 
-    private static final Pattern PATTERN_OBD = new PatternBuilder()
+    private static final Pattern PATTERN_E2 = new PatternBuilder()
+            .text(""$$"")                          // header
+            .number(""dddd"")                      // length
+            .number(""xx"")                        // type
+            .number(""(d+)|"")                     // imei
+            .number(""(dd)(dd)(dd)"")              // date (yymmdd)
+            .number(""(dd)(dd)(dd),"")             // time (hhmmss)
+            .number(""(-?d+.d+),"")                // longitude
+            .number(""(-?d+.d+),"")                // latitude
+            .expression(""(.+)"")                  // rfid
+            .number(""|xx"")                       // checksum
+            .any()
+            .compile();
+
+    private static final Pattern PATTERN_E5 = new PatternBuilder()
             .text(""$$"")                          // header
             .number(""dddd"")                      // length
             .number(""xx"")                        // type
@@ -396,6 +410,15 @@ public class TotemProtocolDecoder extends BaseProtocolDecoder {
 
         int type = Integer.parseInt(sentence.substring(6, 8), 16);
 
+        switch (type) {
+            case 0xE2:
+                return decodeE2(channel, remoteAddress, sentence);
+            case 0xE5:
+                return decodeE5(channel, remoteAddress, sentence);
+            default:
+                break;
+        }
+
         Parser parser = new Parser(PATTERN4, sentence);
         if (!parser.matches()) {
             return null;
@@ -473,9 +496,34 @@ public class TotemProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
-    private Position decodeObd(Channel channel, SocketAddress remoteAddress, String sentence) {
+    private Position decodeE2(Channel channel, SocketAddress remoteAddress, String sentence) {
+
+        Parser parser = new Parser(PATTERN_E2, sentence);
+        if (!parser.matches()) {
+            return null;
+        }
+
+        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
+        if (deviceSession == null) {
+            return null;
+        }
+
+        Position position = new Position(getProtocolName());
+        position.setDeviceId(deviceSession.getDeviceId());
+
+        position.setValid(true);
+        position.setTime(parser.nextDateTime());
+        position.setLongitude(parser.nextDouble());
+        position.setLatitude(parser.nextDouble());
+
+        position.set(Position.KEY_DRIVER_UNIQUE_ID, parser.next());
+
+        return position;
+    }
+
+    private Position decodeE5(Channel channel, SocketAddress remoteAddress, String sentence) {
 
-        Parser parser = new Parser(PATTERN_OBD, sentence);
+        Parser parser = new Parser(PATTERN_E5, sentence);
         if (!parser.matches()) {
             return null;
         }
@@ -517,9 +565,7 @@ public class TotemProtocolDecoder extends BaseProtocolDecoder {
         String sentence = (String) msg;
 
         Position position;
-        if (sentence.contains(""$Cloud"")) {
-            position = decodeObd(channel, remoteAddress, sentence);
-        } else if (sentence.charAt(2) == '0') {
+        if (sentence.charAt(2) == '0') {
             position = decode4(channel, remoteAddress, sentence);
         } else if (sentence.contains(""$GPRMC"")) {
             position = decode12(channel, remoteAddress, sentence, PATTERN1);
"
traccar-traccar-392f00082faf,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MeitrackProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: expected:<true> but was:<null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-392f00082faf:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
index a7accf0..5c5ba4b 100644
--- a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
@@ -420,6 +420,12 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                     case 0x15:
                         position.set(Position.KEY_INPUT, buf.readUnsignedByte());
                         break;
+                    case 0x47:
+                        int lockState = buf.readUnsignedByte();
+                        if (lockState > 0) {
+                            position.set(Position.KEY_LOCK, lockState == 2);
+                        }
+                        break;
                     case 0x97:
                         position.set(Position.KEY_THROTTLE, buf.readUnsignedByte());
                         break;
"
traccar-traccar-8ae0436e5edb,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gl200TextProtocolDecoderTest#testDecode
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-8ae0436e5edb:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/helper/Parser.java b/src/main/java/org/traccar/helper/Parser.java
index aa39e1a..c2aea28 100644
--- a/src/main/java/org/traccar/helper/Parser.java
+++ b/src/main/java/org/traccar/helper/Parser.java
@@ -50,6 +50,17 @@ public class Parser {
     public boolean hasNext(int number) {
         for (int i = position; i < position + number; i++) {
             String value = matcher.group(i);
+            if (value == null || value.isEmpty()) {
+                position += number;
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public boolean hasNextAny(int number) {
+        for (int i = position; i < position + number; i++) {
+            String value = matcher.group(i);
             if (value != null && !value.isEmpty()) {
                 return true;
             }
diff --git a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
index 517499f..28308ab 100644
--- a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
@@ -956,7 +956,7 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
             position.set(Position.KEY_POWER, power * 0.001);
         }
 
-        if (parser.hasNext(12)) {
+        if (parser.hasNextAny(12)) {
 
             position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);
             position.set(Position.KEY_HOURS, parseHours(parser.next()));
diff --git a/src/main/java/org/traccar/protocol/Gps103ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gps103ProtocolDecoder.java
index 28efa3c..d1c35b4 100644
--- a/src/main/java/org/traccar/protocol/Gps103ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gps103ProtocolDecoder.java
@@ -225,7 +225,7 @@ public class Gps103ProtocolDecoder extends BaseProtocolDecoder {
                     getConfig(), parser.nextHexInt(0), parser.nextHexInt(0))));
         }
 
-        if (parser.hasNext(20)) {
+        if (parser.hasNextAny(20)) {
 
             String utcHours = parser.next();
             String utcMinutes = parser.next();
diff --git a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
index 8e3624c..d75da7f 100644
--- a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
@@ -221,7 +221,7 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
             }
         }
 
-        if (parser.hasNext(6)) {
+        if (parser.hasNextAny(6)) {
             position.set(Position.KEY_RPM, parser.nextInt());
             position.set(Position.KEY_ENGINE_LOAD, parser.nextInt());
             position.set(""airFlow"", parser.nextInt());
diff --git a/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java b/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
index 3d57525..b87ba2b 100644
--- a/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
@@ -101,7 +101,7 @@ public class WialonProtocolDecoder extends BaseProtocolDecoder {
             position.setTime(new Date());
         }
 
-        if (parser.hasNext(9)) {
+        if (parser.hasNextAny(9)) {
             position.setLatitude(parser.nextCoordinate());
             position.setLongitude(parser.nextCoordinate());
             position.setSpeed(UnitsConverter.knotsFromKph(parser.nextDouble(0)));
"
traccar-traccar-ec2b7b64a83a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Jt600FrameDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: buffer is null

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-ec2b7b64a83a:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Jt600FrameDecoder.java b/src/main/java/org/traccar/protocol/Jt600FrameDecoder.java
index bfefb94..f7890f8 100644
--- a/src/main/java/org/traccar/protocol/Jt600FrameDecoder.java
+++ b/src/main/java/org/traccar/protocol/Jt600FrameDecoder.java
@@ -35,7 +35,7 @@ public class Jt600FrameDecoder extends BaseFrameDecoder {
         char type = (char) buf.getByte(buf.readerIndex());
 
         if (type == '$') {
-            boolean longFormat = Jt600ProtocolDecoder.isLongFormat(buf, buf.readerIndex() + 1);
+            boolean longFormat = Jt600ProtocolDecoder.isLongFormat(buf);
             int length = buf.getUnsignedShort(buf.readerIndex() + (longFormat ? 8 : 7)) + 10;
             if (length <= buf.readableBytes()) {
                 return buf.readRetainedSlice(length);
diff --git a/src/main/java/org/traccar/protocol/Jt600ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Jt600ProtocolDecoder.java
index 9ed44f5..dc763de 100644
--- a/src/main/java/org/traccar/protocol/Jt600ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Jt600ProtocolDecoder.java
@@ -86,8 +86,8 @@ public class Jt600ProtocolDecoder extends BaseProtocolDecoder {
 
     }
 
-    static boolean isLongFormat(ByteBuf buf, int flagIndex) {
-        return buf.getUnsignedByte(flagIndex) >> 4 >= 7;
+    static boolean isLongFormat(ByteBuf buf) {
+        return buf.getUnsignedByte(buf.readerIndex() + 8) == 0;
     }
 
     static void decodeBinaryLocation(ByteBuf buf, Position position) {
@@ -123,9 +123,9 @@ public class Jt600ProtocolDecoder extends BaseProtocolDecoder {
 
         List<Position> positions = new LinkedList<>();
 
-        buf.readByte(); // header
+        boolean longFormat = isLongFormat(buf);
 
-        boolean longFormat = isLongFormat(buf, buf.readerIndex());
+        buf.readByte(); // header
 
         String id = String.valueOf(Long.parseLong(ByteBufUtil.hexDump(buf.readSlice(5))));
         DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);
"
traccar-traccar-9aef1bfcffa0,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.T55ProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: position is null

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-9aef1bfcffa0:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/T55ProtocolDecoder.java b/src/main/java/org/traccar/protocol/T55ProtocolDecoder.java
index 3be161f..4db76f6 100644
--- a/src/main/java/org/traccar/protocol/T55ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/T55ProtocolDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2012 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -150,6 +150,18 @@ public class T55ProtocolDecoder extends BaseProtocolDecoder {
             .number(""xx"")                        // checksum
             .compile();
 
+    private static final Pattern PATTERN_GPTXT = new PatternBuilder()
+            .text(""$GPTXT,"")
+            .text(""NET,"")
+            .number(""(d+),"")                     // device id
+            .expression(""([^,]+),"")              // network operator
+            .number(""(-d+),"")                    // rssi
+            .number(""(d+) "")                     // mcc
+            .number(""(d+)"")                      // mnc
+            .text(""*"")
+            .number(""xx"")                        // checksum
+            .compile();
+
     private Position position = null;
 
     private Position decodeGprmc(
@@ -328,6 +340,30 @@ public class T55ProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
+    private Position decodeGptxt(Channel channel, SocketAddress remoteAddress, String sentence) {
+
+        Parser parser = new Parser(PATTERN_GPTXT, sentence);
+        if (!parser.matches()) {
+            return null;
+        }
+
+        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
+        if (deviceSession == null) {
+            return null;
+        }
+
+        Position position = new Position(getProtocolName());
+
+        getLastLocation(position, null);
+
+        position.set(Position.KEY_OPERATOR, parser.next());
+        position.set(Position.KEY_RSSI, parser.nextInt());
+        position.set(""mcc"", parser.nextInt());
+        position.set(""mnc"", parser.nextInt());
+
+        return position;
+    }
+
     private Position decodePubx(Channel channel, SocketAddress remoteAddress, String sentence) {
 
         Parser parser = new Parser(PATTERN_PUBX, sentence);
@@ -421,6 +457,8 @@ public class T55ProtocolDecoder extends BaseProtocolDecoder {
             return decodeQze(channel, remoteAddress, sentence);
         } else if (sentence.startsWith(""$PUBX"")) {
             return decodePubx(channel, remoteAddress, sentence);
+        } else if (sentence.startsWith(""$GPTXT"")) {
+            return decodeGptxt(channel, remoteAddress, sentence);
         }
 
         return null;
"
traccar-traccar-9a1cbeb7b754,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MeitrackProtocolDecoderTest#testDecode
Type: java.lang.IndexOutOfBoundsException
Message: java.lang.IndexOutOfBoundsException: readerIndex(218) + length(254) exceeds writerIndex(447): UnpooledHeapByteBuf(ridx: 218, widx: 447, cap: 447/447)

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-9a1cbeb7b754:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
index 3acd87b..3f1f7f5 100644
--- a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
@@ -554,8 +554,15 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                         buf.skipBytes(length - 2);
                         break;
                     case 0xFEA8:
-                        buf.readUnsignedByte(); // battery status
-                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+                        if (buf.readUnsignedByte() > 0) {
+                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+                        } else {
+                            buf.readUnsignedByte();
+                        }
+                        buf.readUnsignedByte(); // battery 2 status
+                        buf.readUnsignedByte(); // battery 2 level
+                        buf.readUnsignedByte(); // battery 3 status
+                        buf.readUnsignedByte(); // battery 3 level
                         buf.readUnsignedByte(); // battery alert
                         break;
                     default:
"
traccar-traccar-dfc546a26f5b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MeitrackProtocolDecoderTest#testDecode
Type: java.lang.AssertionError
Message: java.lang.AssertionError: expected:<77> but was:<null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-dfc546a26f5b:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
index 5c5ba4b..3acd87b 100644
--- a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
@@ -553,6 +553,11 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                         buf.readUnsignedByte(); // alarm type
                         buf.skipBytes(length - 2);
                         break;
+                    case 0xFEA8:
+                        buf.readUnsignedByte(); // battery status
+                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+                        buf.readUnsignedByte(); // battery alert
+                        break;
                     default:
                         buf.skipBytes(length);
                         break;
"
traccar-traccar-3331593759a2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Latitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-3331593759a2:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index d0bbeeb..f79641b 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -847,7 +847,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                 case 0x03:
                     count = buf.readUnsignedByte();
                     for (int i = 0; i < count; i++) {
-                        int id = buf.readUnsignedShort();
+                        int id = buf.readUnsignedByte();
                         int length = buf.readUnsignedByte();
                         switch (id) {
                             case 0x1A:
"
traccar-traccar-2749e520c9ea,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <ff98ffa8007e> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-2749e520c9ea:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index d6deafe..d3336b6 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -753,6 +753,22 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
 
         position.set(Position.KEY_STATUS, status);
 
+        while (buf.readableBytes() > 2) {
+            int id = buf.readUnsignedByte();
+            int length = buf.readUnsignedByte();
+            switch (id) {
+                case 0x02:
+                    position.setAltitude(buf.readShort());
+                    break;
+                case 0x0C:
+                    position.set(""gyro"", ByteBufUtil.hexDump(buf.readSlice(6)));
+                    break;
+                default:
+                    buf.skipBytes(length);
+                    break;
+            }
+        }
+
         return position;
     }
 
"
traccar-traccar-f4d10160d951,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Minifinder2ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <12> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-f4d10160d951:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
index 0b08bad..aa43a60 100644
--- a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
@@ -277,6 +277,10 @@ public class Minifinder2ProtocolDecoder extends BaseProtocolDecoder {
                             i += 1;
                         }
                         break;
+                    case 0x37:
+                        buf.readUnsignedIntLE(); // timestamp
+                        position.set(""barkCount"", BitUtil.to(buf.readUnsignedIntLE(), 31));
+                        break;
                     case 0x40:
                         buf.readUnsignedIntLE(); // timestamp
                         int heartRate = buf.readUnsignedByte();
"
traccar-traccar-5f56a56d7721,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Tk103ProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-5f56a56d7721:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
index b343c3b..2b50e55 100644
--- a/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2012 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -15,8 +15,11 @@
  */
 package org.traccar.protocol;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.DataConverter;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
@@ -448,6 +451,63 @@ public class Tk103ProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
+    private Position decodeBms(Channel channel, SocketAddress remoteAddress, String sentence) {
+        String id = sentence.substring(1, 13);
+        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);
+        if (deviceSession == null) {
+            return null;
+        }
+
+        Position position = new Position(getProtocolName());
+        position.setDeviceId(deviceSession.getDeviceId());
+
+        getLastLocation(position, null);
+
+        ByteBuf buf = Unpooled.wrappedBuffer(
+                DataConverter.parseHex(sentence.substring(1 + 12 + 4, sentence.length() - 1)));
+
+        buf.readUnsignedByte();
+        buf.readUnsignedByte();
+        buf.readUnsignedByte(); // header
+
+        int batteryCount = buf.readUnsignedByte();
+        for (int i = 1; i <= 24; i++) {
+            int voltage = buf.readUnsignedShortLE();
+            if (i <= batteryCount) {
+                position.set(""battery"" + i, voltage * 0.001);
+            }
+        }
+
+        position.set(Position.KEY_CHARGE, buf.readUnsignedByte() == 0);
+        position.set(""current"", buf.readUnsignedShortLE() * 0.1);
+        position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01);
+        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+        position.set(""batteryOverheat"", buf.readUnsignedByte() > 0);
+        position.set(""chargeProtection"", buf.readUnsignedByte() > 0);
+        position.set(""dischargeProtection"", buf.readUnsignedByte() > 0);
+        buf.readUnsignedByte(); // drop line
+        buf.readUnsignedByte(); // balanced
+        position.set(""cycles"", buf.readUnsignedShortLE());
+        position.set(""faultAlarm"", buf.readUnsignedByte());
+
+        buf.skipBytes(6);
+
+        int temperatureCount = buf.readUnsignedByte();
+        position.set(""powerTemp"", buf.readUnsignedByte() - 40);
+        position.set(""equilibriumTemp"", buf.readUnsignedByte() - 40);
+        for (int i = 1; i <= 7; i++) {
+            int temperature = buf.readUnsignedByte() - 40;
+            if (i <= temperatureCount) {
+                position.set(""batteryTemp"" + i, temperature);
+            }
+        }
+
+        position.set(""calibrationCapacity"", buf.readUnsignedShortLE() * 0.01);
+        position.set(""dischargeCapacity"", buf.readUnsignedIntLE());
+
+        return position;
+    }
+
     @Override
     protected Object decode(
             Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {
@@ -477,6 +537,8 @@ public class Tk103ProtocolDecoder extends BaseProtocolDecoder {
             return decodeLbsWifi(channel, remoteAddress, sentence);
         } else if (sentence.contains(""BV00"")) {
             return decodeVin(channel, remoteAddress, sentence);
+        } else if (sentence.contains(""BS50"")) {
+            return decodeBms(channel, remoteAddress, sentence);
         }
 
         Parser parser = new Parser(PATTERN, sentence);
"
traccar-traccar-f8fb3f67bc0b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TzoneProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <%  ^TONGLOM$PITOON$MR.^^?;6007643120100142242=190619581026=?+             22            1            0024628  10700                     ?> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-f8fb3f67bc0b:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TzoneProtocolDecoder.java b/src/main/java/org/traccar/protocol/TzoneProtocolDecoder.java
index 8e84a67..ba9b416 100644
--- a/src/main/java/org/traccar/protocol/TzoneProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TzoneProtocolDecoder.java
@@ -204,30 +204,39 @@ public class TzoneProtocolDecoder extends BaseProtocolDecoder {
 
     }
 
-    private void decodeTags(Position position, ByteBuf buf) {
+    private void decodeTags(Position position, ByteBuf buf, int hardware) {
 
         int blockLength = buf.readUnsignedShort();
         int blockEnd = buf.readerIndex() + blockLength;
 
         if (blockLength > 0) {
 
-            buf.readUnsignedByte(); // tag type
+            int type = buf.readUnsignedByte();
 
-            int count = buf.readUnsignedByte();
-            int tagLength = buf.readUnsignedByte();
+            if (hardware != 0x153 || type >= 2) {
 
-            for (int i = 1; i <= count; i++) {
-                int tagEnd = buf.readerIndex() + tagLength;
+                int count = buf.readUnsignedByte();
+                int tagLength = buf.readUnsignedByte();
+
+                for (int i = 1; i <= count; i++) {
+                    int tagEnd = buf.readerIndex() + tagLength;
+
+                    buf.readUnsignedByte(); // status
+                    buf.readUnsignedShortLE(); // battery voltage
 
-                buf.readUnsignedByte(); // status
-                buf.readUnsignedShortLE(); // battery voltage
+                    position.set(Position.PREFIX_TEMP + i, (buf.readShortLE() & 0x3fff) * 0.1);
+
+                    buf.readUnsignedByte(); // humidity
+                    buf.readUnsignedByte(); // rssi
+
+                    buf.readerIndex(tagEnd);
+                }
 
-                position.set(Position.PREFIX_TEMP + i, (buf.readShortLE() & 0x3fff) * 0.1);
+            } else if (type == 1) {
 
-                buf.readUnsignedByte(); // humidity
-                buf.readUnsignedByte(); // rssi
+                position.set(""driverLicense"", buf.readCharSequence(
+                        blockEnd - buf.readerIndex(), StandardCharsets.UTF_8).toString());
 
-                buf.readerIndex(tagEnd);
             }
 
         }
@@ -364,9 +373,9 @@ public class TzoneProtocolDecoder extends BaseProtocolDecoder {
 
         }
 
-        if (hardware == 0x406) {
+        if (hardware == 0x153 || hardware == 0x406) {
 
-            decodeTags(position, buf);
+            decodeTags(position, buf, hardware);
 
         }
 
"
traccar-traccar-ee3cbd4aba2e,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <[-104,-88,126]> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-ee3cbd4aba2e:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index d3336b6..22c39c2 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -761,7 +761,19 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     position.setAltitude(buf.readShort());
                     break;
                 case 0x0C:
-                    position.set(""gyro"", ByteBufUtil.hexDump(buf.readSlice(6)));
+                    int x = buf.readUnsignedShort();
+                    if (x > 0x8000) {
+                        x -= 0x10000;
+                    }
+                    int y = buf.readUnsignedShort();
+                    if (y > 0x8000) {
+                        y -= 0x10000;
+                    }
+                    int z = buf.readUnsignedShort();
+                    if (z > 0x8000) {
+                        z -= 0x10000;
+                    }
+                    position.set(""tilt"", String.format(""[%d,%d,%d]"", x, y, z));
                     break;
                 default:
                     buf.skipBytes(length);
"
traccar-traccar-7c2f9e56ba5f,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WialonProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <1.0> but was: <1;E7C9>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-7c2f9e56ba5f:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java b/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
index ffa4472..4d1b34d 100644
--- a/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WialonProtocolDecoder.java
@@ -63,8 +63,9 @@ public class WialonProtocolDecoder extends BaseProtocolDecoder {
             .number(""(?:NA|(d+));"")              // outputs
             .expression(""(?:NA|([^;]*));"")       // adc
             .expression(""(?:NA|([^;]*));"")       // ibutton
-            .expression(""(?:NA|(.*))"")           // params
+            .expression(""(?:NA|([^;]*))"")        // params
             .groupEnd(""?"")
+            .any()
             .compile();
 
     private void sendResponse(Channel channel, SocketAddress remoteAddress, String type, Integer number) {
"
traccar-traccar-d4efbfa2a7d9,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <DRIVING LICENSE$TEST$MR.> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d4efbfa2a7d9:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index ddc3192..7227c55 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -457,6 +457,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
             int subtype = buf.readUnsignedByte();
             int length = buf.readUnsignedByte();
             int endIndex = buf.readerIndex() + length;
+            String stringValue;
             switch (subtype) {
                 case 0x01:
                     position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);
@@ -474,9 +475,9 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());
                     break;
                 case 0x33:
-                    String sentence = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
-                    if (sentence.startsWith(""*M00"")) {
-                        String lockStatus = sentence.substring(8, 8 + 7);
+                    stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
+                    if (stringValue.startsWith(""*M00"")) {
+                        String lockStatus = stringValue.substring(8, 8 + 7);
                         position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);
                     }
                     break;
@@ -501,8 +502,8 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     break;
                 case 0x94:
                     if (length > 0) {
-                        position.set(
-                                Position.KEY_VIN, buf.readCharSequence(length, StandardCharsets.US_ASCII).toString());
+                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
+                        position.set(Position.KEY_VIN, stringValue);
                     }
                     break;
                 case 0xA7:
@@ -512,6 +513,14 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                 case 0xAC:
                     position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
                     break;
+                case 0xBC:
+                    stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
+                    position.set(""driver"", stringValue.trim());
+                    break;
+                case 0xBD:
+                    stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
+                    position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);
+                    break;
                 case 0xD0:
                     long userStatus = buf.readUnsignedInt();
                     if (BitUtil.check(userStatus, 3)) {
@@ -598,8 +607,8 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     }
                     break;
                 case 0xED:
-                    String license = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim();
-                    position.set(""driverLicense"", license);
+                    stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();
+                    position.set(""driverLicense"", stringValue.trim());
                     break;
                 case 0xEE:
                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());
"
traccar-traccar-c68e92043cb5,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuaShengProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: buffer is null ==> expected: not <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-c68e92043cb5:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocol.java b/src/main/java/org/traccar/protocol/HuaShengProtocol.java
index 4a0ebe5..1f8bafc 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocol.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocol.java
@@ -29,6 +29,7 @@ public class HuaShengProtocol extends BaseProtocol {
     public HuaShengProtocol(Config config) {
         setSupportedDataCommands(
                 Command.TYPE_POSITION_PERIODIC,
+                Command.TYPE_OUTPUT_CONTROL,
                 Command.TYPE_ALARM_ARM,
                 Command.TYPE_ALARM_DISARM,
                 Command.TYPE_SET_SPEED_LIMIT);
diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
index 993e369..2d952c7 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
@@ -50,6 +50,8 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
     public static final int MSG_HSO_RSP = 0x0003;
     public static final int MSG_SET_REQ = 0xAA04;
     public static final int MSG_SET_RSP = 0xFF05;
+    public static final int MSG_CTRL_REQ = 0xAA16;
+    public static final int MSG_CTRL_RSP = 0xFF17;
 
     private void sendResponse(Channel channel, int type, int index, ByteBuf content) {
         if (channel != null) {
diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocolEncoder.java b/src/main/java/org/traccar/protocol/HuaShengProtocolEncoder.java
index 636196e..dc34f7b 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocolEncoder.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocolEncoder.java
@@ -27,13 +27,13 @@ public class HuaShengProtocolEncoder extends BaseProtocolEncoder {
         super(protocol);
     }
 
-    private ByteBuf encodeContent(ByteBuf content) {
+    private ByteBuf encodeContent(int type, ByteBuf content) {
 
         ByteBuf buf = Unpooled.buffer();
         buf.writeByte(0xC0);
         buf.writeShort(0x0000); // flag and version
         buf.writeShort(12 + content.readableBytes());
-        buf.writeShort(HuaShengProtocolDecoder.MSG_SET_REQ);
+        buf.writeShort(type);
         buf.writeShort(0); // checksum
         buf.writeInt(1); // index
         buf.writeBytes(content);
@@ -52,17 +52,31 @@ public class HuaShengProtocolEncoder extends BaseProtocolEncoder {
                 content.writeShort(0x0002);
                 content.writeShort(6); // length
                 content.writeShort(command.getInteger(Command.KEY_FREQUENCY));
-                return encodeContent(content);
+                return encodeContent(HuaShengProtocolDecoder.MSG_SET_REQ, content);
+            case Command.TYPE_OUTPUT_CONTROL:
+                /*
+0x01: Lock the relay1; //relay on
+0x02: Unlock the relay1; //relay off
+0x03: Lock the relay2; //relay2 on
+0x04: Unlock the relay2; //relay2 off
+0x05: Lock the relay3; //relay3 on
+0x06: Unlock the relay3; //realy3 off
+                 */
+                content.writeByte(
+                        (command.getInteger(Command.KEY_INDEX) - 1) * 2
+                        + (2 - command.getInteger(Command.KEY_DATA)));
+                return encodeContent(HuaShengProtocolDecoder.MSG_CTRL_REQ, content);
             case Command.TYPE_ALARM_ARM:
             case Command.TYPE_ALARM_DISARM:
                 content.writeShort(0x0001);
                 content.writeShort(5); // length
                 content.writeByte(command.getType().equals(Command.TYPE_ALARM_ARM) ? 1 : 0);
+                return encodeContent(HuaShengProtocolDecoder.MSG_SET_REQ, content);
             case Command.TYPE_SET_SPEED_LIMIT:
                 content.writeShort(0x0004);
                 content.writeShort(6); // length
                 content.writeShort(command.getInteger(Command.KEY_DATA));
-                return encodeContent(content);
+                return encodeContent(HuaShengProtocolDecoder.MSG_SET_REQ, content);
             default:
                 return null;
         }
"
traccar-traccar-5c26f25b3b0a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MeitrackProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <88> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-5c26f25b3b0a:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
index 3f1f7f5..0f0d220 100644
--- a/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MeitrackProtocolDecoder.java
@@ -554,15 +554,14 @@ public class MeitrackProtocolDecoder extends BaseProtocolDecoder {
                         buf.skipBytes(length - 2);
                         break;
                     case 0xFEA8:
-                        if (buf.readUnsignedByte() > 0) {
-                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
-                        } else {
-                            buf.readUnsignedByte();
+                        for (int k = 1; k <= 3; k++) {
+                            if (buf.readUnsignedByte() > 0) {
+                                String key = k == 1 ? Position.KEY_BATTERY_LEVEL : ""battery"" + k + ""Level"";
+                                position.set(key, buf.readUnsignedByte());
+                            } else {
+                                buf.readUnsignedByte();
+                            }
                         }
-                        buf.readUnsignedByte(); // battery 2 status
-                        buf.readUnsignedByte(); // battery 2 level
-                        buf.readUnsignedByte(); // battery 3 status
-                        buf.readUnsignedByte(); // battery 3 level
                         buf.readUnsignedByte(); // battery alert
                         break;
                     default:
"
traccar-traccar-5da3b8fcb480,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <45> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-5da3b8fcb480:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index f132991..1aebba4 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -538,6 +538,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);
                     break;
                 case 0xD4:
+                case 0xE1:
                     position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
                     break;
                 case 0xD5:
"
traccar-traccar-4ece72558c80,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TeltonikaProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <12749884> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-4ece72558c80:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
index ead6578..4968ed0 100644
--- a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
@@ -610,8 +610,12 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
                 int length = buf.readInt() - 4;
                 getLastLocation(position, new Date(buf.readUnsignedInt() * 1000));
                 if (isPrintable(buf, length)) {
-                    position.set(Position.KEY_RESULT,
-                            buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim());
+                    String data = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim();
+                    if (data.startsWith(""GTSL"")) {
+                        position.set(Position.KEY_DRIVER_UNIQUE_ID, data.split(""\\|"")[4]);
+                    } else {
+                        position.set(Position.KEY_RESULT, data);
+                    }
                 } else {
                     position.set(Position.KEY_RESULT,
                             ByteBufUtil.hexDump(buf.readSlice(length)));
"
traccar-traccar-c024d09744de,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Minifinder2ProtocolEncoderTest#testEncodeNano()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <ab00160059d2010004143068747470733a2f2f6578616d706c652e636f6d> but was: <ab00150018750100143068747470733a2f2f6578616d706c652e636f6d>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-c024d09744de:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
index 37e86e2..f660f2e 100644
--- a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
@@ -48,6 +48,8 @@ public class Minifinder2ProtocolDecoder extends BaseProtocolDecoder {
     public static final int MSG_DATA = 0x01;
     public static final int MSG_CONFIGURATION = 0x02;
     public static final int MSG_SERVICES = 0x03;
+    public static final int MSG_SYSTEM_CONTROL = 0x04;
+    public static final int MSG_FIRMWARE = 0x7E;
     public static final int MSG_RESPONSE = 0x7F;
 
     private String decodeAlarm(long code) {
diff --git a/src/main/java/org/traccar/protocol/Minifinder2ProtocolEncoder.java b/src/main/java/org/traccar/protocol/Minifinder2ProtocolEncoder.java
index ce7de6d..fab3c3a 100644
--- a/src/main/java/org/traccar/protocol/Minifinder2ProtocolEncoder.java
+++ b/src/main/java/org/traccar/protocol/Minifinder2ProtocolEncoder.java
@@ -53,6 +53,7 @@ public class Minifinder2ProtocolEncoder extends BaseProtocolEncoder {
             ByteBuf content = Unpooled.buffer();
             if (command.getType().equals(Command.TYPE_FIRMWARE_UPDATE)) {
                 String url = command.getString(Command.KEY_DATA);
+                content.writeByte(Minifinder2ProtocolDecoder.MSG_SYSTEM_CONTROL);
                 content.writeByte(1 + url.length());
                 content.writeByte(0x30); // type
                 content.writeCharSequence(url, StandardCharsets.US_ASCII);
"
traccar-traccar-d797671b2ce6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: year > 1999 ==> expected: <true> but was: <false>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d797671b2ce6:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index fcbb550..05e2fb8 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -913,6 +913,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     }
                     getLastLocation(position, time);
                     decodeCoordinates(position, buf);
+                    position.setTime(time);
                     break;
                 case 0x02:
                     count = buf.readUnsignedByte();
@@ -925,6 +926,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     }
                     getLastLocation(position, time);
                     decodeCoordinates(position, buf);
+                    position.setTime(time);
                     break;
                 case 0x03:
                     count = buf.readUnsignedByte();
@@ -956,6 +958,7 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     }
                     getLastLocation(position, time);
                     decodeCoordinates(position, buf);
+                    position.setTime(time);
                     break;
                 case 0x0B:
                     if (buf.readUnsignedByte() > 0) {
"
traccar-traccar-1d31ebe88f26,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Tk103ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: position is null ==> expected: not <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-1d31ebe88f26:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
index 2b50e55..6c926da 100644
--- a/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Tk103ProtocolDecoder.java
@@ -463,47 +463,90 @@ public class Tk103ProtocolDecoder extends BaseProtocolDecoder {
 
         getLastLocation(position, null);
 
-        ByteBuf buf = Unpooled.wrappedBuffer(
-                DataConverter.parseHex(sentence.substring(1 + 12 + 4, sentence.length() - 1)));
-
-        buf.readUnsignedByte();
-        buf.readUnsignedByte();
-        buf.readUnsignedByte(); // header
-
-        int batteryCount = buf.readUnsignedByte();
-        for (int i = 1; i <= 24; i++) {
-            int voltage = buf.readUnsignedShortLE();
-            if (i <= batteryCount) {
-                position.set(""battery"" + i, voltage * 0.001);
+        String payload = sentence.substring(1 + 12 + 4, sentence.length() - 1);
+
+        if (sentence.startsWith(""BS50"", 1 + 12)) {
+
+            ByteBuf buf = Unpooled.wrappedBuffer(DataConverter.parseHex(payload));
+
+            buf.readUnsignedByte();
+            buf.readUnsignedByte();
+            buf.readUnsignedByte(); // header
+
+            int batteryCount = buf.readUnsignedByte();
+            for (int i = 1; i <= 24; i++) {
+                int voltage = buf.readUnsignedShortLE();
+                if (i <= batteryCount) {
+                    position.set(""battery"" + i, voltage * 0.001);
+                }
             }
-        }
 
-        position.set(Position.KEY_CHARGE, buf.readUnsignedByte() == 0);
-        position.set(""current"", buf.readUnsignedShortLE() * 0.1);
-        position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01);
-        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
-        position.set(""batteryOverheat"", buf.readUnsignedByte() > 0);
-        position.set(""chargeProtection"", buf.readUnsignedByte() > 0);
-        position.set(""dischargeProtection"", buf.readUnsignedByte() > 0);
-        buf.readUnsignedByte(); // drop line
-        buf.readUnsignedByte(); // balanced
-        position.set(""cycles"", buf.readUnsignedShortLE());
-        position.set(""faultAlarm"", buf.readUnsignedByte());
-
-        buf.skipBytes(6);
-
-        int temperatureCount = buf.readUnsignedByte();
-        position.set(""powerTemp"", buf.readUnsignedByte() - 40);
-        position.set(""equilibriumTemp"", buf.readUnsignedByte() - 40);
-        for (int i = 1; i <= 7; i++) {
-            int temperature = buf.readUnsignedByte() - 40;
-            if (i <= temperatureCount) {
-                position.set(""batteryTemp"" + i, temperature);
+            position.set(Position.KEY_CHARGE, buf.readUnsignedByte() == 0);
+            position.set(""current"", buf.readUnsignedShortLE() * 0.1);
+            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01);
+            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+            position.set(""batteryOverheat"", buf.readUnsignedByte() > 0);
+            position.set(""chargeProtection"", buf.readUnsignedByte() > 0);
+            position.set(""dischargeProtection"", buf.readUnsignedByte() > 0);
+            buf.readUnsignedByte(); // drop line
+            buf.readUnsignedByte(); // balanced
+            position.set(""cycles"", buf.readUnsignedShortLE());
+            position.set(""faultAlarm"", buf.readUnsignedByte());
+
+            buf.skipBytes(6);
+
+            int temperatureCount = buf.readUnsignedByte();
+            position.set(""powerTemp"", buf.readUnsignedByte() - 40);
+            position.set(""equilibriumTemp"", buf.readUnsignedByte() - 40);
+            for (int i = 1; i <= 7; i++) {
+                int temperature = buf.readUnsignedByte() - 40;
+                if (i <= temperatureCount) {
+                    position.set(""batteryTemp"" + i, temperature);
+                }
             }
-        }
 
-        position.set(""calibrationCapacity"", buf.readUnsignedShortLE() * 0.01);
-        position.set(""dischargeCapacity"", buf.readUnsignedIntLE());
+            position.set(""calibrationCapacity"", buf.readUnsignedShortLE() * 0.01);
+            position.set(""dischargeCapacity"", buf.readUnsignedIntLE());
+
+        } else {
+
+            String[] values = payload.split("","");
+            for (String value : values) {
+                String[] pair = value.split("":"");
+                int key = Integer.parseInt(pair[0], 16);
+                ByteBuf buf = Unpooled.wrappedBuffer(DataConverter.parseHex(pair[1]));
+                switch (key) {
+                    case 0x90:
+                        position.set(""cumulativeVoltage"", buf.readUnsignedShortLE() * 0.1);
+                        position.set(""gatherVoltage"", buf.readUnsignedShortLE() * 0.1);
+                        position.set(""current"", (buf.readUnsignedShortLE() - 30000) * 0.1);
+                        position.set(""soc"", buf.readUnsignedShortLE() * 0.1);
+                        break;
+                    case 0x91:
+                        position.set(""maxCellVoltage"", buf.readUnsignedShortLE() * 0.001);
+                        position.set(""maxCellVoltageCount"", buf.readUnsignedByte());
+                        position.set(""minCellVoltage"", buf.readUnsignedShortLE() * 0.001);
+                        position.set(""minCellVoltageCount"", buf.readUnsignedByte());
+                        break;
+                    case 0x92:
+                        position.set(""maxTemp"", buf.readUnsignedByte() - 40);
+                        position.set(""maxTempCount"", buf.readUnsignedByte());
+                        position.set(""minTemp"", buf.readUnsignedByte() - 40);
+                        position.set(""minTempCount"", buf.readUnsignedByte());
+                        break;
+                    case 0x96:
+                        buf.readUnsignedByte(); // frame
+                        while (buf.isReadable()) {
+                            position.set(""cellTemp"" + buf.readerIndex(), buf.readUnsignedByte() - 40);
+                        }
+                        break;
+                    default:
+                        break;
+                }
+
+            }
+
+        }
 
         return position;
     }
@@ -537,7 +580,7 @@ public class Tk103ProtocolDecoder extends BaseProtocolDecoder {
             return decodeLbsWifi(channel, remoteAddress, sentence);
         } else if (sentence.contains(""BV00"")) {
             return decodeVin(channel, remoteAddress, sentence);
-        } else if (sentence.contains(""BS50"")) {
+        } else if (sentence.contains(""BS50"") || sentence.contains(""BS51"")) {
             return decodeBms(channel, remoteAddress, sentence);
         }
 
"
traccar-traccar-f92bde208800,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.AtrackProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-f92bde208800:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
index 3406417..aa19e9e 100644
--- a/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
@@ -429,6 +429,191 @@ public class AtrackProtocolDecoder extends BaseProtocolDecoder {
                 case ""MP"":
                     buf.readUnsignedByte(); // manifold absolute pressure
                     break;
+                case ""EO"":
+                    position.set(Position.KEY_ODOMETER, UnitsConverter.metersFromMiles(buf.readUnsignedInt()));
+                    break;
+                case ""EH"":
+                    position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 360000);
+                    break;
+                case ""ZO1"":
+                    buf.readUnsignedByte(); // brake stroke status
+                    break;
+                case ""ZO2"":
+                    buf.readUnsignedByte(); // warning indicator status
+                    break;
+                case ""ZO3"":
+                    buf.readUnsignedByte(); // abs control status
+                    break;
+                case ""ZO4"":
+                    position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 0.4);
+                    break;
+                case ""ZO5"":
+                    buf.readUnsignedByte(); // parking brake status
+                    break;
+                case ""ZO6"":
+                    position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte() * 0.805);
+                    break;
+                case ""ZO7"":
+                    buf.readUnsignedByte(); // cruise control status
+                    break;
+                case ""ZO8"":
+                    buf.readUnsignedByte(); // accelector pedal position
+                    break;
+                case ""ZO9"":
+                    position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 0.5);
+                    break;
+                case ""ZO10"":
+                    position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte() * 0.5);
+                    break;
+                case ""ZO11"":
+                    buf.readUnsignedByte(); // engine oil pressure
+                    break;
+                case ""ZO12"":
+                    buf.readUnsignedByte(); // boost pressure
+                    break;
+                case ""ZO13"":
+                    buf.readUnsignedByte(); // intake temperature
+                    break;
+                case ""ZO14"":
+                    position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte());
+                    break;
+                case ""ZO15"":
+                    buf.readUnsignedByte(); // brake application pressure
+                    break;
+                case ""ZO16"":
+                    buf.readUnsignedByte(); // brake primary pressure
+                    break;
+                case ""ZO17"":
+                    buf.readUnsignedByte(); // brake secondary pressure
+                    break;
+                case ""ZH1"":
+                    buf.readUnsignedShort(); // cargo weight
+                    break;
+                case ""ZH2"":
+                    position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 16.428 / 3600);
+                    break;
+                case ""ZH3"":
+                    position.set(Position.KEY_RPM, buf.readUnsignedShort() * 0.25);
+                    break;
+                case ""ZL1"":
+                    buf.readUnsignedInt(); // fuel used (natural gas)
+                    break;
+                case ""ZL2"":
+                    position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 161);
+                    break;
+                case ""ZL3"":
+                    buf.readUnsignedInt(); // vehicle hours
+                    break;
+                case ""ZL4"":
+                    position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 5 * 36000);
+                    break;
+                case ""ZS1"":
+                    position.set(Position.KEY_VIN, readString(buf));
+                    break;
+                case ""JO1"":
+                    buf.readUnsignedByte(); // pedals
+                    break;
+                case ""JO2"":
+                    buf.readUnsignedByte(); // power takeoff device
+                    break;
+                case ""JO3"":
+                    buf.readUnsignedByte(); // accelector pedal position
+                    break;
+                case ""JO4"":
+                    position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte());
+                    break;
+                case ""JO5"":
+                    position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte() * 0.4);
+                    break;
+                case ""JO6"":
+                    buf.readUnsignedByte(); // fms vehicle interface
+                    break;
+                case ""JO7"":
+                    buf.readUnsignedByte(); // driver 2
+                    break;
+                case ""JO8"":
+                    buf.readUnsignedByte(); // driver 1
+                    break;
+                case ""JO9"":
+                    buf.readUnsignedByte(); // drivers
+                    break;
+                case ""JO10"":
+                    buf.readUnsignedByte(); // system information
+                    break;
+                case ""JO11"":
+                    position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);
+                    break;
+                case ""JO12"":
+                    buf.readUnsignedByte(); // pto engaged
+                    break;
+                case ""JH1"":
+                    position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() / 256.0);
+                    break;
+                case ""JH2"":
+                    position.set(Position.KEY_RPM, buf.readUnsignedShort() * 0.125);
+                    break;
+                case ""JH3"":
+                case ""JH4"":
+                case ""JH5"":
+                case ""JH6"":
+                case ""JH7"":
+                    int index = Integer.parseInt(key.substring(2)) - 2;
+                    position.set(""axleWeight"" + index, buf.readUnsignedShort() * 0.5);
+                    break;
+                case ""JH8"":
+                    position.set(Position.KEY_ODOMETER_SERVICE, buf.readUnsignedShort() * 5);
+                    break;
+                case ""JH9"":
+                    buf.readUnsignedShort(); // tachograph speed
+                    break;
+                case ""JH10"":
+                    buf.readUnsignedShort(); // ambient air temperature
+                    break;
+                case ""JH11"":
+                    position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.05);
+                    break;
+                case ""JH12"":
+                    buf.readUnsignedShort(); // fuel economy
+                    break;
+                case ""JL1"":
+                    position.set(Position.KEY_FUEL_USED, buf.readUnsignedInt() * 0.5);
+                    break;
+                case ""JL2"":
+                    position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 5 * 36000);
+                    break;
+                case ""JL3"":
+                    position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);
+                    break;
+                case ""JL4"":
+                    position.set(Position.KEY_FUEL_USED, buf.readUnsignedInt() * 0.001);
+                    break;
+                case ""JS1"":
+                    position.set(Position.KEY_VIN, readString(buf));
+                    break;
+                case ""JS2"":
+                    readString(buf); // fms version supported
+                    break;
+                case ""JS3"":
+                    position.set(""driver1"", readString(buf));
+                    break;
+                case ""JS4"":
+                    position.set(""driver2"", readString(buf));
+                    break;
+                case ""JN1"":
+                    buf.readUnsignedInt(); // cruise control distance
+                    break;
+                case ""JN2"":
+                    buf.readUnsignedInt(); // excessive idling time
+                    break;
+                case ""JN3"":
+                    buf.readUnsignedInt(); // excessive idling fuel
+                    break;
+                case ""JN4"":
+                    buf.readUnsignedInt(); // pto time
+                    break;
+                case ""JN5"":
+                    buf.readUnsignedInt(); // pto fuel
+                    break;
                 default:
                     break;
             }
"
traccar-traccar-0f8dd92a6b1b,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: position is null ==> expected: not <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-0f8dd92a6b1b:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 02a6291..7013533 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -1028,6 +1028,29 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);
                 return position;
 
+            } else if (subType == 0x04) {
+
+                CharSequence content = buf.readCharSequence(buf.readableBytes() - 4 - 2, StandardCharsets.US_ASCII);
+                String[] values = content.toString().split("";"");
+                for (String value : values) {
+                    String[] pair = value.split(""="");
+                    switch (pair[0]) {
+                        case ""ALM1"":
+                        case ""ALM2"":
+                        case ""ALM3"":
+                            position.set(""alarm"" + pair[0].charAt(3) + ""Status"", Integer.parseInt(pair[1], 16));
+                        case ""STA1"":
+                            position.set(""otherStatus"", Integer.parseInt(pair[1], 16));
+                            break;
+                        case ""DYD"":
+                            position.set(""engineStatus"", Integer.parseInt(pair[1], 16));
+                            break;
+                        default:
+                            break;
+                    }
+                }
+                return position;
+
             } else if (subType == 0x05) {
 
                 if (buf.readableBytes() >= 6 + 1 + 6) {
"
traccar-traccar-e73f36db83b9,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gl200TextProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <153> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-e73f36db83b9:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
index c7713bd..0135e78 100644
--- a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
@@ -978,7 +978,7 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
             index += 1; // device type
 
             if (BitUtil.check(mask, 0)) {
-                index += 1; // digital fuel sensor data
+                position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(data[index++], 16));
             }
 
             if (BitUtil.check(mask, 1)) {
"
traccar-traccar-3dad196b882c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuaShengProtocolDecoderTest#testDecode()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: minimumReadableBytes : -4 (expected: >= 0)

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-3dad196b882c:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
index 2d952c7..2fb7c6e 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
@@ -236,6 +236,7 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
         while (buf.readableBytes() > 4) {
             int subtype = buf.readUnsignedShort();
             int length = buf.readUnsignedShort() - 4;
+            int endIndex = buf.readerIndex() + length;
             switch (subtype) {
                 case 0x0001:
                     int coolantTemperature = buf.readUnsignedByte() - 40;
@@ -253,6 +254,9 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
                     position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte() * 0.4);
                     buf.readUnsignedInt(); // trip id
+                    if (buf.readerIndex() < endIndex) {
+                        position.set(""adBlueLevel"", buf.readUnsignedByte() * 0.4);
+                    }
                     break;
                 case 0x0005:
                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());
@@ -295,6 +299,7 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
                     buf.skipBytes(length);
                     break;
             }
+            buf.readerIndex(endIndex);
         }
 
         if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
"
traccar-traccar-ae1205dfdded,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <4> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-ae1205dfdded:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index 05e2fb8..ed71861 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -333,10 +333,6 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     buf.readUnsignedByte(); // power level
                     position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
                     break;
-                case 0x60:
-                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());
-                    buf.skipBytes(length - 2);
-                    break;
                 case 0x61:
                     position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
                     break;
@@ -488,6 +484,10 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                         position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);
                     }
                     break;
+                case 0x60:
+                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());
+                    buf.skipBytes(length - 2);
+                    break;
                 case 0x80:
                     buf.readUnsignedByte(); // content
                     endIndex = buf.writerIndex() - 2;
"
traccar-traccar-553527d9fbe6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <3.95> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-553527d9fbe6:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index e6980dc..4beee76 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -488,6 +488,9 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_EVENT, buf.readUnsignedShort());
                     buf.skipBytes(length - 2);
                     break;
+                case 0x69:
+                    position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);
+                    break;
                 case 0x80:
                     buf.readUnsignedByte(); // content
                     endIndex = buf.writerIndex() - 2;
"
traccar-traccar-adbe25e9daa1,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Latitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-adbe25e9daa1:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/api/MediaFilter.java b/src/main/java/org/traccar/api/MediaFilter.java
index ab75bdc..e655618 100644
--- a/src/main/java/org/traccar/api/MediaFilter.java
+++ b/src/main/java/org/traccar/api/MediaFilter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018 - 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2018 - 2023 Anton Tananaev (anton@traccar.org)
  * Copyright 2018 Andrey Kunitsyn (andrey@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
@@ -32,7 +32,6 @@ import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.servlet.Filter;
 import javax.servlet.FilterChain;
-import javax.servlet.FilterConfig;
 import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
@@ -58,10 +57,6 @@ public class MediaFilter implements Filter {
     }
 
     @Override
-    public void init(FilterConfig filterConfig) throws ServletException {
-    }
-
-    @Override
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
             throws IOException, ServletException {
 
@@ -99,8 +94,4 @@ public class MediaFilter implements Filter {
         }
     }
 
-    @Override
-    public void destroy() {
-    }
-
 }
diff --git a/src/main/java/org/traccar/model/ExtendedModel.java b/src/main/java/org/traccar/model/ExtendedModel.java
index 7a61eda..6a4f502 100644
--- a/src/main/java/org/traccar/model/ExtendedModel.java
+++ b/src/main/java/org/traccar/model/ExtendedModel.java
@@ -89,14 +89,18 @@ public class ExtendedModel extends BaseModel {
         }
     }
 
-    public String getString(String key) {
+    public String getString(String key, String defaultValue) {
         if (attributes.containsKey(key)) {
             return attributes.get(key).toString();
         } else {
-            return null;
+            return defaultValue;
         }
     }
 
+    public String getString(String key) {
+        return getString(key, null);
+    }
+
     public double getDouble(String key) {
         if (attributes.containsKey(key)) {
             Object value = attributes.get(key);
diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index 4beee76..ee5ab19 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -919,14 +919,19 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     position.setTime(time);
                     break;
                 case 0x02:
-                    count = buf.readUnsignedByte();
+                    List<String> codes = new LinkedList<>();
+                    count = buf.readUnsignedShort();
                     for (int i = 0; i < count; i++) {
                         buf.readUnsignedInt(); // system id
                         int codeCount = buf.readUnsignedShort();
                         for (int j = 0; j < codeCount; j++) {
-                            buf.skipBytes(16); // code
+                            buf.readUnsignedInt(); // dtc
+                            buf.readUnsignedInt(); // status
+                            codes.add(buf.readCharSequence(
+                                    buf.readUnsignedShort(), StandardCharsets.US_ASCII).toString().trim());
                         }
                     }
+                    position.set(Position.KEY_DTCS, String.join("" "", codes));
                     getLastLocation(position, time);
                     decodeCoordinates(position, buf);
                     position.setTime(time);
diff --git a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
index fc18424..2f378f3 100644
--- a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
@@ -232,6 +232,7 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
         register(27, null, (p, b) -> p.set(""bleTemp3"", b.readShort() * 0.01));
         register(28, null, (p, b) -> p.set(""bleTemp4"", b.readShort() * 0.01));
         register(30, fmbXXX, (p, b) -> p.set(""faultCount"", b.readUnsignedByte()));
+        register(32, fmbXXX, (p, b) -> p.set(Position.KEY_COOLANT_TEMP, b.readByte()));
         register(66, null, (p, b) -> p.set(Position.KEY_POWER, b.readUnsignedShort() * 0.001));
         register(67, null, (p, b) -> p.set(Position.KEY_BATTERY, b.readUnsignedShort() * 0.001));
         register(68, fmbXXX, (p, b) -> p.set(""batteryCurrent"", b.readUnsignedShort() * 0.001));
@@ -247,7 +248,6 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
         });
         register(80, fmbXXX, (p, b) -> p.set(""dataMode"", b.readUnsignedByte()));
         register(90, null, (p, b) -> p.set(Position.KEY_DOOR, b.readUnsignedShort()));
-        register(115, fmbXXX, (p, b) -> p.set(Position.KEY_COOLANT_TEMP, b.readShort() * 0.1));
         register(179, null, (p, b) -> p.set(Position.PREFIX_OUT + 1, b.readUnsignedByte() > 0));
         register(180, null, (p, b) -> p.set(Position.PREFIX_OUT + 2, b.readUnsignedByte() > 0));
         register(181, null, (p, b) -> p.set(Position.KEY_PDOP, b.readUnsignedShort() * 0.1));
diff --git a/src/main/java/org/traccar/web/CharResponseWrapper.java b/src/main/java/org/traccar/web/CharResponseWrapper.java
new file mode 100644
index 0000000..477fe79
--- a/src/main/java/org/traccar/web/CharResponseWrapper.java
+++ b/src/main/java/org/traccar/web/CharResponseWrapper.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.web;
+
+import javax.servlet.ServletOutputStream;
+import javax.servlet.WriteListener;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpServletResponseWrapper;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+public class CharResponseWrapper extends HttpServletResponseWrapper {
+
+    private final ByteArrayOutputStream capture;
+    private ServletOutputStream output;
+
+    public CharResponseWrapper(HttpServletResponse response) {
+        super(response);
+        capture = new ByteArrayOutputStream(response.getBufferSize());
+    }
+
+    @Override
+    public ServletOutputStream getOutputStream() {
+        if (output == null) {
+            output = new ServletOutputStream() {
+                @Override
+                public boolean isReady() {
+                    return true;
+                }
+
+                @Override
+                public void setWriteListener(WriteListener writeListener) {
+                }
+
+                @Override
+                public void write(int b) {
+                    capture.write(b);
+                }
+
+                @Override
+                public void flush() throws IOException {
+                    capture.flush();
+                }
+
+                @Override
+                public void close() throws IOException {
+                    capture.close();
+                }
+            };
+        }
+        return output;
+    }
+
+    @Override
+    public void flushBuffer() throws IOException {
+        super.flushBuffer();
+        if (output != null) {
+            output.flush();
+        }
+    }
+
+    public byte[] getCapture() throws IOException {
+        if (output != null) {
+            output.close();
+        }
+        return capture.toByteArray();
+    }
+
+}
diff --git a/src/main/java/org/traccar/web/ModernDefaultServlet.java b/src/main/java/org/traccar/web/ModernDefaultServlet.java
new file mode 100644
index 0000000..bae089d
--- a/src/main/java/org/traccar/web/ModernDefaultServlet.java
+++ b/src/main/java/org/traccar/web/ModernDefaultServlet.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.web;
+
+import org.eclipse.jetty.servlet.DefaultServlet;
+import org.eclipse.jetty.util.resource.Resource;
+
+public class ModernDefaultServlet extends DefaultServlet {
+
+    @Override
+    public Resource getResource(String pathInContext) {
+        return super.getResource(pathInContext.indexOf('.') < 0 ? ""/"" : pathInContext);
+    }
+
+    @Override
+    public String getWelcomeFile(String pathInContext) {
+        return super.getWelcomeFile(""/"");
+    }
+
+}
diff --git a/src/main/java/org/traccar/web/OverrideFilter.java b/src/main/java/org/traccar/web/OverrideFilter.java
new file mode 100644
index 0000000..708632b
--- a/src/main/java/org/traccar/web/OverrideFilter.java
+++ b/src/main/java/org/traccar/web/OverrideFilter.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2023 Anton Tananaev (anton@traccar.org)
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.traccar.web;
+
+import com.google.inject.Provider;
+import org.traccar.api.security.PermissionsService;
+import org.traccar.model.Server;
+import org.traccar.storage.StorageException;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import javax.servlet.Filter;
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
+
+@Singleton
+public class OverrideFilter implements Filter {
+
+    private final Provider<PermissionsService> permissionsServiceProvider;
+
+    @Inject
+    public OverrideFilter(Provider<PermissionsService> permissionsServiceProvider) {
+        this.permissionsServiceProvider = permissionsServiceProvider;
+    }
+
+    @Override
+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
+            throws IOException, ServletException {
+
+        CharResponseWrapper wrappedResponse = new CharResponseWrapper((HttpServletResponse) response);
+
+        chain.doFilter(request, wrappedResponse);
+
+        byte[] bytes = wrappedResponse.getCapture();
+        if (wrappedResponse.getContentType().contains(""text/html"")
+                || ((HttpServletRequest) request).getPathInfo().endsWith(""manifest.json"")) {
+
+            Server server;
+            try {
+                server = permissionsServiceProvider.get().getServer();
+            } catch (StorageException e) {
+                throw new RuntimeException(e);
+            }
+
+            String title = server.getString(""title"", ""Traccar"");
+            String description = server.getString(""description"", ""Traccar GPS Tracking System"");
+            String colorPrimary = server.getString(""colorPrimary"", ""#1a237e"");
+
+            String alteredContent = new String(wrappedResponse.getCapture())
+                    .replace(""${title}"", title)
+                    .replace(""${description}"", description)
+                    .replace(""${colorPrimary}"", colorPrimary);
+
+            response.setContentLength(alteredContent.length());
+            response.getOutputStream().write(alteredContent.getBytes());
+
+        } else {
+            response.getOutputStream().write(bytes);
+        }
+    }
+
+}
diff --git a/src/main/java/org/traccar/web/WebModule.java b/src/main/java/org/traccar/web/WebModule.java
index 0722c5d..a32a6f4 100644
--- a/src/main/java/org/traccar/web/WebModule.java
+++ b/src/main/java/org/traccar/web/WebModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2022 Anton Tananaev (anton@traccar.org)
+ * Copyright 2022 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@ public class WebModule extends ServletModule {
 
     @Override
     protected void configureServlets() {
+        filter(""/*"").through(OverrideFilter.class);
         filter(""/api/*"").through(ThrottlingFilter.class);
         filter(""/api/media/*"").through(MediaFilter.class);
         serve(""/api/socket"").with(AsyncSocketServlet.class);
diff --git a/src/main/java/org/traccar/web/WebServer.java b/src/main/java/org/traccar/web/WebServer.java
index 79d19cc..ce12201 100644
--- a/src/main/java/org/traccar/web/WebServer.java
+++ b/src/main/java/org/traccar/web/WebServer.java
@@ -62,9 +62,6 @@ import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.net.InetSocketAddress;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.EnumSet;
 
 public class WebServer implements LifecycleObject {
@@ -103,14 +100,8 @@ public class WebServer implements LifecycleObject {
             @Override
             protected void handleErrorPage(
                     HttpServletRequest request, Writer writer, int code, String message) throws IOException {
-                Path index = Paths.get(config.getString(Keys.WEB_PATH), ""index.html"");
-                if (code == HttpStatus.NOT_FOUND_404
-                        && !request.getPathInfo().startsWith(""/api/"") && Files.exists(index)) {
-                    writer.write(Files.readString(index));
-                } else {
-                    writer.write(""<!DOCTYPE><html><head><title>Error</title></head><html><body>""
-                            + code + "" - "" + HttpStatus.getMessage(code) + ""</body></html>"");
-                }
+                writer.write(""<!DOCTYPE><html><head><title>Error</title></head><html><body>""
+                        + code + "" - "" + HttpStatus.getMessage(code) + ""</body></html>"");
             }
         });
 
@@ -150,7 +141,7 @@ public class WebServer implements LifecycleObject {
     }
 
     private void initWebApp(ServletContextHandler servletHandler) {
-        ServletHolder servletHolder = new ServletHolder(DefaultServlet.class);
+        ServletHolder servletHolder = new ServletHolder(ModernDefaultServlet.class);
         servletHolder.setInitParameter(""resourceBase"", new File(config.getString(Keys.WEB_PATH)).getAbsolutePath());
         servletHolder.setInitParameter(""dirAllowed"", ""false"");
         if (config.getBoolean(Keys.WEB_DEBUG)) {
"
traccar-traccar-d244b4bc4999,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TopinProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <78780c4131333533333333333333330d0a> but was: <78780541747275650d0a>

Test: org.traccar.protocol.PretraceProtocolEncoderTest#testEncodeCustom()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <(123456789012345D21012^44)> but was: <(123456789012345true^26)>

Test: org.traccar.protocol.Jt600ProtocolEncoderTest#testSetTimezone()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <(S09,1,240)> but was: <(S09,1,0)>

Test: org.traccar.protocol.T800xProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <232381001e000101234567890123450152454c41592c303030302c4f6e23> but was: <2323810014000101234567890123450174727565>

Test: org.traccar.protocol.WatchProtocolEncoderTest#testEncode()
Type: java.lang.RuntimeException
Message: java.lang.RuntimeException: org.apache.commons.codec.DecoderException: Illegal hexadecimal character t at index 0

Test: org.traccar.protocol.Minifinder2ProtocolEncoderTest#testEncodeNano()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <ab00160059d2010004143068747470733a2f2f6578616d706c652e636f6d> but was: <ab0007006a7b010004053074727565>

Test: org.traccar.protocol.MeiligaoProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <4040001412345678901234413234383030ad0d0a> but was: <404000121234567890123441323044450d0a>

Test: org.traccar.protocol.GalileoProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <01200003313233343536373839303132333435040000e000000000e1067374617475731f64> but was: <011e0003313233343536373839303132333435040000e000000000e10474727565ebcd>

Test: org.traccar.handler.ComputedAttributesTest#testComputedAttributes()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <success> but was: <true>

Test: org.traccar.protocol.BceProtocolEncoderTest#testEncode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""true""

Test: org.traccar.protocol.Tk103ProtocolEncoderTest#testEncodeSetConnectionAlternative()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <[begin]sms2,*setip*1*2*3*4*5555*,[end]> but was: <[begin]sms2,*setip*true*5555*,[end]>

Test: org.traccar.protocol.Xrb28ProtocolEncoderTest#testEncodeCustom()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <ÿÿ*SCOS,OM,123456789012345,S7,0,3,0,0,20,25#
> but was: <ÿÿ*SCOS,OM,123456789012345,true#
>

Test: org.traccar.protocol.UlbotechProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <2a545330312c554e4f3b313339313233343536373823> but was: <2a545330312c7472756523>

Test: org.traccar.protocol.CityeasyProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <5353001100080001680000000b60820d0a> but was: <5353001100080000000000000b9f3a0d0a>

Test: org.traccar.protocol.RuptelaProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <000b6c20536574696f20322c31eb3e> but was: <00056c74727565719d>

Test: org.traccar.protocol.TeltonikaProtocolEncoderTest#testEncode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <00000000000000160c01050000000e7365746469676f75742031310d0a010000e258> but was: <000000000000000e0c010500000006747275650d0a010000da79>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d244b4bc4999:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/model/ExtendedModel.java b/src/main/java/org/traccar/model/ExtendedModel.java
index 0a0923b..d5cd094 100644
--- a/src/main/java/org/traccar/model/ExtendedModel.java
+++ b/src/main/java/org/traccar/model/ExtendedModel.java
@@ -91,7 +91,7 @@ public class ExtendedModel extends BaseModel {
 
     public String getString(String key, String defaultValue) {
         if (attributes.containsKey(key)) {
-            Object value = attributes.containsKey(key);
+            Object value = attributes.get(key);
             return value != null ? value.toString() : null;
         } else {
             return defaultValue;
"
traccar-traccar-8de9a36abef8,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.GoSafeProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: """"

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-8de9a36abef8:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/GoSafeProtocolDecoder.java b/src/main/java/org/traccar/protocol/GoSafeProtocolDecoder.java
index 77649a0..f17ea0e 100644
--- a/src/main/java/org/traccar/protocol/GoSafeProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/GoSafeProtocolDecoder.java
@@ -93,14 +93,14 @@ public class GoSafeProtocolDecoder extends BaseProtocolDecoder {
                     position.setSpeed(UnitsConverter.knotsFromKph(Integer.parseInt(values[index - 1])));
                 }
                 position.setCourse(Integer.parseInt(values[index++]));
-                if (index < values.length) {
-                    position.setAltitude(Integer.parseInt(values[index++]));
+                if (index < values.length && !values[index++].isEmpty()) {
+                    position.setAltitude(Integer.parseInt(values[index - 1]));
                 }
-                if (index < values.length) {
-                    position.set(Position.KEY_HDOP, Double.parseDouble(values[index++]));
+                if (index < values.length && !values[index++].isEmpty()) {
+                    position.set(Position.KEY_HDOP, Double.parseDouble(values[index - 1]));
                 }
-                if (index < values.length) {
-                    position.set(Position.KEY_VDOP, Double.parseDouble(values[index++]));
+                if (index < values.length && !values[index++].isEmpty()) {
+                    position.set(Position.KEY_VDOP, Double.parseDouble(values[index - 1]));
                 }
                 break;
             case ""GSM"":
"
traccar-traccar-fdbd269b9b99,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.FreematicsProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""53.000000""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-fdbd269b9b99:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/FreematicsProtocolDecoder.java b/src/main/java/org/traccar/protocol/FreematicsProtocolDecoder.java
index 4e5200f..4d8e7e7 100644
--- a/src/main/java/org/traccar/protocol/FreematicsProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/FreematicsProtocolDecoder.java
@@ -153,7 +153,7 @@ public class FreematicsProtocolDecoder extends BaseProtocolDecoder {
                         position.set(Position.KEY_RSSI, Integer.parseInt(value));
                         break;
                     case 0x82:
-                        position.set(Position.KEY_DEVICE_TEMP, Integer.parseInt(value) * 0.1);
+                        position.set(Position.KEY_DEVICE_TEMP, Double.parseDouble(value) * 0.1);
                         break;
                     case 0x104:
                         position.set(Position.KEY_ENGINE_LOAD, Integer.parseInt(value));
"
traccar-traccar-f1de2533c352,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchFrameDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <5b33472a3838303930303234322a303133442a55442c3132303632332c3134303032302c412c34382e3934393237332c4e2c20342e333738333036302c452c31382e35362c34332e382c302e302c31322c3130302c37362c3232363132302c302c30303030303030302c322c3235352c3230342c382c333131302c35353032352c3134362c333133302c34393239372c3132342c352c42616e67696e67576966692c33343a61313a65643a65313a39313a34662c2d37312c42415220576946692c33363a61323a65313a65643a61313a64652c2d37322c4e6574776f726b576966692c32363a64653a61313a65643a65313a61302c2d37332c46696265722c33363a61313a65643a65313a39313a34662c2d37352c5b4c475f57616c6c2d4d6f756e7420412f435d653732352c36363a61313a65643a65313a65373a32352c2d38322c31352e305d> but was: <5b33472a3838303930303234322a303133442a55442c3132303632332c3134303032302c412c34382e3934393237332c4e2c20342e333738333036302c452c31382e35362c34332e382c302e302c31322c3130302c37362c3232363132302c302c30303030303030302c322c3235352c3230342c382c333131302c35353032352c3134362c333133302c34393239372c3132342c352c42616e67696e67576966692c33343a61313a65643a65313a39313a34662c2d37312c42415220576946692c33363a61323a65313a65643a61313a64652c2d37322c4e6574776f726b576966692c32363a64653a61313a65643a65313a61302c2d37332c46696265722c33363a61313a65643a65313a39313a34662c2d37352c5b4c475f57616c6c2d4d6f756e7420412f435d>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-f1de2533c352:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WatchFrameDecoder.java b/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
index f99bd52..ec67aa3 100644
--- a/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 - 2018 Anton Tananaev (anton@traccar.org)
+ * Copyright 2017 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -27,7 +27,14 @@ public class WatchFrameDecoder extends BaseFrameDecoder {
     protected Object decode(
             ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {
 
-        int endIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ']') + 1;
+        int endIndex = -1;
+        for (int i = buf.writerIndex() - 1; i >= buf.readerIndex(); i--) {
+            if (buf.getByte(i) == ']') {
+                endIndex = i + 1;
+                break;
+            }
+        }
+
         if (endIndex > 0) {
             ByteBuf frame = Unpooled.buffer();
             while (buf.readerIndex() < endIndex) {
"
traccar-traccar-94fbc93f8b0a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.AtrackProtocolDecoderTest#testDecode()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Longitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-94fbc93f8b0a:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
index aa19e9e..8896dcf 100644
--- a/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/AtrackProtocolDecoder.java
@@ -614,6 +614,23 @@ public class AtrackProtocolDecoder extends BaseProtocolDecoder {
                 case ""JN5"":
                     buf.readUnsignedInt(); // pto fuel
                     break;
+                case ""IN0"":
+                    position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);
+                    break;
+                case ""IN1"":
+                case ""IN2"":
+                case ""IN3"":
+                    position.set(Position.PREFIX_IN + key.charAt(2), buf.readUnsignedByte() > 0);
+                    break;
+                case ""HA"":
+                    position.set(Position.KEY_ALARM, buf.readUnsignedByte() > 0 ? Position.ALARM_ACCELERATION : null);
+                    break;
+                case ""HB"":
+                    position.set(Position.KEY_ALARM, buf.readUnsignedByte() > 0 ? Position.ALARM_BRAKING : null);
+                    break;
+                case ""HC"":
+                    position.set(Position.KEY_ALARM, buf.readUnsignedByte() > 0 ? Position.ALARM_CORNERING : null);
+                    break;
                 default:
                     break;
             }
"
traccar-traccar-03650fff8064,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.GalileoFrameDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <UnpooledHeapByteBuf(ridx: 0, widx: 66, cap: 66/66)> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-03650fff8064:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/GalileoFrameDecoder.java b/src/main/java/org/traccar/protocol/GalileoFrameDecoder.java
index c23d26c..d90e482 100644
--- a/src/main/java/org/traccar/protocol/GalileoFrameDecoder.java
+++ b/src/main/java/org/traccar/protocol/GalileoFrameDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 - 2018 Anton Tananaev (anton@traccar.org)
+ * Copyright 2013 - 2023 Anton Tananaev (anton@traccar.org)
  *
  * Licensed under the Apache License, Version 2.0 (the ""License"");
  * you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@ import org.traccar.BaseFrameDecoder;
 
 public class GalileoFrameDecoder extends BaseFrameDecoder {
 
-    private static final int MESSAGE_MINIMUM_LENGTH = 5;
+    private static final int MESSAGE_MINIMUM_LENGTH = 6;
 
     @Override
     protected Object decode(
@@ -32,9 +32,15 @@ public class GalileoFrameDecoder extends BaseFrameDecoder {
             return null;
         }
 
-        int length = buf.getUnsignedShortLE(buf.readerIndex() + 1) & 0x7fff;
-        if (buf.readableBytes() >= (length + MESSAGE_MINIMUM_LENGTH)) {
-            return buf.readRetainedSlice(length + MESSAGE_MINIMUM_LENGTH);
+        int length;
+        if (buf.getByte(buf.readerIndex()) == 0x01 && buf.getUnsignedMedium(buf.readerIndex() + 3) == 0x01001c) {
+            length = 3 + buf.getUnsignedShort(buf.readerIndex() + 1);
+        } else {
+            length = 5 + (buf.getUnsignedShortLE(buf.readerIndex() + 1) & 0x7fff);
+        }
+
+        if (buf.readableBytes() >= length) {
+            return buf.readRetainedSlice(length);
         }
 
         return null;
"
traccar-traccar-4a64ef748e20,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <90> but was: <30>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-4a64ef748e20:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index 3adfa7d..beb1ec4 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -484,6 +484,10 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                         position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);
                     }
                     break;
+                case 0x56:
+                    position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 10);
+                    buf.readUnsignedByte(); // reserved
+                    break;
                 case 0x60:
                     position.set(Position.KEY_EVENT, buf.readUnsignedShort());
                     buf.skipBytes(length - 2);
@@ -692,6 +696,8 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                 case 0xFE:
                     if (length == 1) {
                         position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+                    } else if (length == 2) {
+                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);
                     } else {
                         int mark = buf.readUnsignedByte();
                         if (mark == 0x7C) {
"
traccar-traccar-1b8993293646,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.FifotrackProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <13> but was: <0>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-1b8993293646:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/FifotrackProtocolDecoder.java b/src/main/java/org/traccar/protocol/FifotrackProtocolDecoder.java
index 14b33b6..c30398d 100644
--- a/src/main/java/org/traccar/protocol/FifotrackProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/FifotrackProtocolDecoder.java
@@ -235,8 +235,8 @@ public class FifotrackProtocolDecoder extends BaseProtocolDecoder {
 
             position.setValid(parser.next().equals(""A""));
             position.setFixTime(position.getDeviceTime());
-            position.set(Position.KEY_SATELLITES, parser.nextInt());
             position.setSpeed(UnitsConverter.knotsFromKph(parser.nextInt()));
+            position.set(Position.KEY_SATELLITES, parser.nextInt());
             position.setLatitude(parser.nextDouble());
             position.setLongitude(parser.nextDouble());
 
"
traccar-traccar-3b6900a95342,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Minifinder2ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: list is null ==> expected: not <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-3b6900a95342:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
index f8b0c34..cd8d8e0 100644
--- a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
@@ -151,7 +151,7 @@ public class Minifinder2ProtocolDecoder extends BaseProtocolDecoder {
             sendResponse(channel, remoteAddress, index, type, buf);
         }
 
-        if (type == MSG_DATA) {
+        if (type == MSG_DATA || type == MSG_SERVICES) {
 
             List<Position> positions = new LinkedList<>();
             Set<Integer> keys = new HashSet<>();
"
traccar-traccar-bc99846b0c88,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gl200TextProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-bc99846b0c88:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
index 0135e78..bcff1c5 100644
--- a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
@@ -15,7 +15,9 @@
  */
 package org.traccar.protocol;
 
+import io.netty.buffer.Unpooled;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.DataConverter;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
@@ -368,6 +370,21 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
             .text(""$"").optional()
             .compile();
 
+    private static final Pattern PATTERN_DTT = new PatternBuilder()
+            .text(""+RESP:GTDTT,"")
+            .number(""(?:[0-9A-Z]{2}xxxx)?,"")     // protocol version
+            .number(""(d{15}|x{14}),"")            // imei
+            .expression(""[^,]*,,,"")              // device name
+            .number(""d,"")                        // data type
+            .number(""d+,"")                       // data length
+            .number(""(x+),"")                     // data
+            .number(""(dddd)(dd)(dd)"")            // date (yyyymmdd)
+            .number(""(dd)(dd)(dd)"").optional(2)  // time (hhmmss)
+            .text("","")
+            .number(""(xxxx)"")                    // count number
+            .text(""$"").optional()
+            .compile();
+
     private static final Pattern PATTERN = new PatternBuilder()
             .text(""+"").expression(""(?:RESP|BUFF):GT...,"")
             .number(""(?:[0-9A-Z]{2}xxxx)?,"")     // protocol version
@@ -1165,6 +1182,34 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
+    private Object decodeDtt(Channel channel, SocketAddress remoteAddress, String sentence) {
+        Parser parser = new Parser(PATTERN_DTT, sentence);
+        Position position = initPosition(parser, channel, remoteAddress);
+        if (position == null) {
+            return null;
+        }
+
+        getLastLocation(position, null);
+
+        /*
+        Ecuatrack
+COMB,0,94.0,-1.0,,,HDC
+         */
+
+        String data = Unpooled.wrappedBuffer(DataConverter.parseHex(parser.next()))
+                .toString(StandardCharsets.US_ASCII);
+        if (data.contains(""COMB"")) {
+            String[] values = data.split("","");
+            position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(values[2]));
+        } else {
+            position.set(Position.KEY_RESULT, data);
+        }
+
+        decodeDeviceTime(position, parser);
+
+        return position;
+    }
+
     private Object decodeOther(Channel channel, SocketAddress remoteAddress, String sentence, String type) {
         Parser parser = new Parser(PATTERN, sentence);
         Position position = initPosition(parser, channel, remoteAddress);
@@ -1359,6 +1404,9 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
                 case ""DAR"":
                     result = decodeDar(channel, remoteAddress, sentence);
                     break;
+                case ""DTT"":
+                    result = decodeDtt(channel, remoteAddress, sentence);
+                    break;
                 default:
                     result = decodeOther(channel, remoteAddress, sentence, type);
                     break;
"
traccar-traccar-d4c204914f90,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <0.0> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d4c204914f90:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 7013533..38c2219 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -828,6 +828,11 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 }
             }
 
+            if (type == MSG_STATUS && variant == Variant.VXT01) {
+                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
+                position.set(Position.KEY_RSSI, buf.readUnsignedByte());
+            }
+
             if (type == MSG_GPS_LBS_1) {
                 if (variant == Variant.GT06E_CARD) {
                     position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
@@ -1408,6 +1413,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             variant = Variant.VXT01;
         } else if (header == 0x7878 && type == MSG_GPS_LBS_STATUS_1 && length == 0x24) {
             variant = Variant.VXT01;
+        } else if (header == 0x7878 && type == MSG_STATUS && length == 0x0a) {
+            variant = Variant.VXT01;
         } else if (header == 0x7878 && type == MSG_LBS_MULTIPLE_3 && length == 0x31) {
             variant = Variant.WANWAY_S20;
         } else if (header == 0x7878 && type == MSG_LBS_MULTIPLE_3 && length == 0x2e) {
"
traccar-traccar-779486a30483,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.LaipacProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: value too low ==> expected: <true> but was: <false>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-779486a30483:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/LaipacProtocolDecoder.java b/src/main/java/org/traccar/protocol/LaipacProtocolDecoder.java
index f0753cb..de039a2 100644
--- a/src/main/java/org/traccar/protocol/LaipacProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/LaipacProtocolDecoder.java
@@ -231,6 +231,9 @@ public class LaipacProtocolDecoder extends BaseProtocolDecoder {
         if (device != null) {
             deviceModel = device.getModel();
         }
+        if (deviceModel == null) {
+            deviceModel = """";
+        }
 
         Position position = new Position(getProtocolName());
 
@@ -261,6 +264,8 @@ public class LaipacProtocolDecoder extends BaseProtocolDecoder {
 
         if (""AVL110"".equals(deviceModel) || ""AVL120"".equals(deviceModel)) {
             position.set(Position.PREFIX_ADC + 2, parser.nextDouble() * 0.001);
+        } else {
+            parser.next();
         }
 
         Integer lac = parser.nextHexInt();
"
traccar-traccar-8b4d3ee0b964,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.MiniFinderProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-8b4d3ee0b964:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/MiniFinderProtocolDecoder.java b/src/main/java/org/traccar/protocol/MiniFinderProtocolDecoder.java
index f2e5eb9..1fdb1ec 100644
--- a/src/main/java/org/traccar/protocol/MiniFinderProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/MiniFinderProtocolDecoder.java
@@ -143,7 +143,7 @@ public class MiniFinderProtocolDecoder extends BaseProtocolDecoder {
         }
 
         DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);
-        if (deviceSession == null || !sentence.matches(""![35A-D],.*"")) {
+        if (deviceSession == null || !sentence.matches(""![345A-D],.*"")) {
             return null;
         }
 
@@ -161,6 +161,20 @@ public class MiniFinderProtocolDecoder extends BaseProtocolDecoder {
 
             return position;
 
+        } else if (type.equals(""4"")) {
+
+            String[] values = sentence.split("","");
+
+            getLastLocation(position, null);
+
+            for (int i = 1; i <= 3; i++) {
+                if (!values[i + 1].isEmpty()) {
+                    position.set(""phone"" + i, values[i + 1]);
+                }
+            }
+
+            return position;
+
         } else if (type.equals(""5"")) {
 
             String[] values = sentence.split("","");
"
traccar-traccar-a8a06ffd494f,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gl200TextProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <3.065> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-a8a06ffd494f:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
index e33093d..bfd0a4c 100644
--- a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
@@ -1154,6 +1154,104 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
         return position;
     }
 
+    private static final Pattern PATTERN_BAA = new PatternBuilder()
+            .text(""+RESP:GTBAA,"")
+            .number(""(?:[0-9A-Z]{2}xxxx)?,"")     // protocol version
+            .number(""(d{15}|x{14}),"")            // imei
+            .expression(""[^,]*,"")                // device name
+            .number(""x+,"")                       // index
+            .number(""d,"")                        // accessory type
+            .number(""d,"")                        // accessory model
+            .number(""x+,"")                       // alarm type
+            .number(""(x{4}),"")                   // append mask
+            .expression(""((?:[^,]+,){0,6})"")     // accessory optionals
+            .expression(PATTERN_LOCATION.pattern())
+            .any()
+            .number(""(dddd)(dd)(dd)"")            // date (yyyymmdd)
+            .number(""(dd)(dd)(dd)"").optional(2)  // time (hhmmss)
+            .text("","")
+            .number(""(xxxx)"")                    // count number
+            .text(""$"").optional()
+            .compile();
+
+    private Object decodeBaa(Channel channel, SocketAddress remoteAddress, String sentence) {
+        Parser parser = new Parser(PATTERN_BAA, sentence);
+        Position position = initPosition(parser, channel, remoteAddress);
+        if (position == null) {
+            return null;
+        }
+
+        int mask = parser.nextHexInt();
+        String[] values = parser.next().split("","");
+        int index = 0;
+        if (BitUtil.check(mask, 0)) {
+            position.set(""accessoryName"", values[index++]);
+        }
+        if (BitUtil.check(mask, 1)) {
+            position.set(""accessoryMac"", values[index++]);
+        }
+        if (BitUtil.check(mask, 2)) {
+            position.set(""accessoryStatus"", Integer.parseInt(values[index++]));
+        }
+        if (BitUtil.check(mask, 3)) {
+            position.set(""accessoryVoltage"", Integer.parseInt(values[index++]) * 0.001);
+        }
+        if (BitUtil.check(mask, 4)) {
+            position.set(""accessoryTemp"", Integer.parseInt(values[index++]));
+        }
+        if (BitUtil.check(mask, 5)) {
+            position.set(""accessoryHumidity"", Integer.parseInt(values[index]));
+        }
+
+        decodeLocation(position, parser);
+
+        decodeDeviceTime(position, parser);
+
+        return position;
+    }
+
+    private static final Pattern PATTERN_BID = new PatternBuilder()
+            .text(""+RESP:GTBID,"")
+            .number(""(?:[0-9A-Z]{2}xxxx)?,"")     // protocol version
+            .number(""(d{15}|x{14}),"")            // imei
+            .expression(""[^,]*,"")                // device name
+            .number(""d,"")                        // count
+            .number(""d,"")                        // accessory model
+            .number(""(x{4}),"")                   // append mask
+            .expression(""((?:[^,]+,){0,2})"")     // accessory optionals
+            .expression(PATTERN_LOCATION.pattern())
+            .any()
+            .number(""(dddd)(dd)(dd)"")            // date (yyyymmdd)
+            .number(""(dd)(dd)(dd)"").optional(2)  // time (hhmmss)
+            .text("","")
+            .number(""(xxxx)"")                    // count number
+            .text(""$"").optional()
+            .compile();
+
+    private Object decodeBid(Channel channel, SocketAddress remoteAddress, String sentence) {
+        Parser parser = new Parser(PATTERN_BID, sentence);
+        Position position = initPosition(parser, channel, remoteAddress);
+        if (position == null) {
+            return null;
+        }
+
+        int mask = parser.nextHexInt();
+        String[] values = parser.next().split("","");
+        int index = 0;
+        if (BitUtil.check(mask, 1)) {
+            position.set(""accessoryMac"", values[index++]);
+        }
+        if (BitUtil.check(mask, 3)) {
+            position.set(""accessoryVoltage"", Integer.parseInt(values[index]) * 0.001);
+        }
+
+        decodeLocation(position, parser);
+
+        decodeDeviceTime(position, parser);
+
+        return position;
+    }
+
     private static final Pattern PATTERN = new PatternBuilder()
             .text(""+"").expression(""(?:RESP|BUFF):GT...,"")
             .number(""(?:[0-9A-Z]{2}xxxx)?,"")     // protocol version
@@ -1402,6 +1500,12 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
                 case ""DTT"":
                     result = decodeDtt(channel, remoteAddress, sentence);
                     break;
+                case ""BAA"":
+                    result = decodeBaa(channel, remoteAddress, sentence);
+                    break;
+                case ""BID"":
+                    result = decodeBid(channel, remoteAddress, sentence);
+                    break;
                 default:
                     result = decodeOther(channel, remoteAddress, sentence, type);
                     break;
"
traccar-traccar-52799453e0ee,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.StartekProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-52799453e0ee:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
index d08bb92..9c749c8 100644
--- a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
@@ -72,12 +72,10 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
             .number(""(x+)"")                      // battery
             .expression(""([^,]+)?"")              // adc
             .groupBegin()
-            .text("","")
-            .number(""d,"")                        // extended
-            .expression(""([^,]+)?"")              // fuel
+            .number("",d+"")                       // extended
+            .expression("",([^,]+)?"")             // fuel
             .groupBegin()
-            .text("","")
-            .expression(""([^,]+)?"")              // temperature
+            .expression("",([^,]+)?"")             // temperature
             .groupBegin()
             .text("","")
             .groupBegin()
@@ -91,9 +89,11 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
             .number(""(d+)?|"")                    // instant fuel
             .number(""(d+)[%L]"").optional()       // fuel level
             .groupEnd(""?"")
+            .number("",(d+)"").optional()          // hours
             .groupEnd(""?"")
             .groupEnd(""?"")
             .groupEnd(""?"")
+            .any()
             .compile();
 
     private String decodeAlarm(int value) {
@@ -224,7 +224,7 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
             }
         }
 
-        if (parser.hasNextAny(6)) {
+        if (parser.hasNextAny(9)) {
             position.set(Position.KEY_RPM, parser.nextInt());
             position.set(Position.KEY_ENGINE_LOAD, parser.nextInt());
             position.set(""airFlow"", parser.nextInt());
@@ -242,6 +242,10 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
             position.set(Position.KEY_FUEL_LEVEL, parser.nextInt());
         }
 
+        if (parser.hasNext()) {
+            position.set(Position.KEY_HOURS, parser.nextInt() * 1000L);
+        }
+
         return position;
     }
 
"
traccar-traccar-5e18cb586d34,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gl200TextProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: empty String

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-5e18cb586d34:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
index bfd0a4c..911af8d 100644
--- a/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gl200TextProtocolDecoder.java
@@ -400,7 +400,7 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
         DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, values[index++]);
         position.setDeviceId(deviceSession.getDeviceId());
 
-        index += 1; // device name
+        String deviceName = values[index++];
         index += 1; // report type
         index += 1; // canbus state
         long reportMask = Long.parseLong(values[index++], 16);
@@ -442,11 +442,11 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
         if (BitUtil.check(reportMask, 11) && !values[index++].isEmpty()) {
             position.set(Position.KEY_HOURS, UnitsConverter.msFromHours(Double.parseDouble(values[index - 1])));
         }
-        if (BitUtil.check(reportMask, 12)) {
-            position.set(Position.KEY_DRIVING_TIME, Double.parseDouble(values[index++]));
+        if (BitUtil.check(reportMask, 12) && !values[index++].isEmpty()) {
+            position.set(Position.KEY_DRIVING_TIME, Double.parseDouble(values[index - 1]));
         }
-        if (BitUtil.check(reportMask, 13)) {
-            position.set(""idleHours"", Double.parseDouble(values[index++]));
+        if (BitUtil.check(reportMask, 13) && !values[index++].isEmpty()) {
+            position.set(""idleHours"", Double.parseDouble(values[index - 1]));
         }
         if (BitUtil.check(reportMask, 14) && !values[index++].isEmpty()) {
             position.set(""idleFuelConsumption"", Double.parseDouble(values[index - 1]));
@@ -472,8 +472,19 @@ public class Gl200TextProtocolDecoder extends BaseProtocolDecoder {
         if (BitUtil.check(reportMask, 21) && !values[index++].isEmpty()) {
             position.set(""engineOverspeed"", Double.parseDouble(values[index - 1]));
         }
-        if (BitUtil.check(reportMask, 29)) {
-            reportMaskExt = Long.parseLong(values[index++], 16);
+        if (""GV350M"".equals(deviceName)) {
+            if (BitUtil.check(reportMask, 22)) {
+                index += 1; // impulse distance
+            }
+            if (BitUtil.check(reportMask, 23)) {
+                index += 1; // gross vehicle weight
+            }
+            if (BitUtil.check(reportMask, 24)) {
+                index += 1; // catalyst liquid level
+            }
+        }
+        if (BitUtil.check(reportMask, 29) && !values[index++].isEmpty()) {
+            reportMaskExt = Long.parseLong(values[index - 1], 16);
         }
         if (BitUtil.check(reportMaskExt, 0) && !values[index++].isEmpty()) {
             position.set(""adBlueLevel"", Integer.parseInt(values[index - 1]));
"
traccar-traccar-d2ce5af34782,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <sos> but was: <vibration>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d2ce5af34782:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 38c2219..5db06fc 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -806,7 +806,11 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             }
 
             if (hasLbs(type) && buf.readableBytes() > 6) {
-                decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM && type != MSG_LBS_STATUS);
+                boolean hasLength = hasStatus(type)
+                        && type != MSG_LBS_STATUS
+                        && type != MSG_LBS_ALARM
+                        && (type != MSG_GPS_LBS_STATUS_1 || variant != Variant.VXT01);
+                decodeLbs(position, buf, type, hasLength);
             }
 
             if (hasStatus(type)) {
"
traccar-traccar-b3c6e22fc19c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <sos> but was: <geofenceEnter>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-b3c6e22fc19c:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 5db06fc..383d4cb 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -828,7 +828,10 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 } else {
                     position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 100 / 6);
                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());
-                    position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));
+                    short alarmExtension = buf.readUnsignedByte();
+                    if (variant != Variant.VXT01) {
+                        position.set(Position.KEY_ALARM, decodeAlarm(alarmExtension));
+                    }
                 }
             }
 
"
traccar-traccar-105873ab5256,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Minifinder2ProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-105873ab5256:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
index 85589b0..6289bd2 100644
--- a/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Minifinder2ProtocolDecoder.java
@@ -324,6 +324,23 @@ public class Minifinder2ProtocolDecoder extends BaseProtocolDecoder {
 
             return positions;
 
+        } else if (type == MSG_RESPONSE) {
+
+            DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);
+            if (deviceSession == null) {
+                return null;
+            }
+
+            Position position = new Position(getProtocolName());
+            position.setDeviceId(deviceSession.getDeviceId());
+
+            getLastLocation(position, null);
+
+            buf.readUnsignedByte(); // length
+            position.set(Position.KEY_RESULT, String.valueOf(buf.readUnsignedByte()));
+
+            return position;
+
         }
 
         return null;
"
traccar-traccar-007b4007e063,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TopinProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: not <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-007b4007e063:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TopinProtocolDecoder.java b/src/main/java/org/traccar/protocol/TopinProtocolDecoder.java
index a1d5481..b5dd3c4 100644
--- a/src/main/java/org/traccar/protocol/TopinProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TopinProtocolDecoder.java
@@ -48,7 +48,11 @@ public class TopinProtocolDecoder extends BaseProtocolDecoder {
     public static final int MSG_GPS = 0x10;
     public static final int MSG_GPS_OFFLINE = 0x11;
     public static final int MSG_STATUS = 0x13;
+    public static final int MSG_SLEEP = 0x14;
+    public static final int MSG_FACTORY_RESET = 0x15;
     public static final int MSG_WIFI_OFFLINE = 0x17;
+    public static final int MSG_LBS_WIFI = 0x18;
+    public static final int MSG_LBS_WIFI_OFFLINE = 0x19;
     public static final int MSG_TIME_UPDATE = 0x30;
     public static final int MSG_SOS_NUMBER = 0x41;
     public static final int MSG_WIFI = 0x69;
@@ -216,7 +220,8 @@ public class TopinProtocolDecoder extends BaseProtocolDecoder {
 
             return position;
 
-        } else if (type == MSG_WIFI || type == MSG_WIFI_OFFLINE) {
+        } else if (type == MSG_WIFI || type == MSG_WIFI_OFFLINE
+                || type == MSG_LBS_WIFI || type == MSG_LBS_WIFI_OFFLINE) {
 
             Position position = new Position(getProtocolName());
             position.setDeviceId(deviceSession.getDeviceId());
"
traccar-traccar-7325030436e5,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-7325030436e5:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/helper/BufferUtil.java b/src/main/java/org/traccar/helper/BufferUtil.java
index d1025f5..12c31ba 100644
--- a/src/main/java/org/traccar/helper/BufferUtil.java
+++ b/src/main/java/org/traccar/helper/BufferUtil.java
@@ -71,4 +71,16 @@ public final class BufferUtil {
         }
     }
 
+    public static boolean isPrintable(ByteBuf buf, int length) {
+        boolean printable = true;
+        for (int i = 0; i < length; i++) {
+            byte b = buf.getByte(buf.readerIndex() + i);
+            if (b < 32 && b != '\r' && b != '\n') {
+                printable = false;
+                break;
+            }
+        }
+        return printable;
+    }
+
 }
diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 383d4cb..e1bc2b5 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -20,6 +20,7 @@ import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.BufferUtil;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
 import org.traccar.Protocol;
@@ -1382,19 +1383,13 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             getLastLocation(position, null);
 
             buf.readUnsignedByte(); // external device type code
-            int length = buf.readableBytes() - 9; // line break + checksum + index + checksum + footer
 
-            if (length <= 0) {
-                return null;
-            } else if (length < 8) {
-                position.set(
-                        Position.PREFIX_TEMP + 1,
-                        Double.parseDouble(buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString()));
+            ByteBuf data = buf.readSlice(buf.readableBytes() - 6); // index + checksum + footer
+            if (BufferUtil.isPrintable(data, data.readableBytes())) {
+                String value = data.readCharSequence(data.readableBytes(), StandardCharsets.US_ASCII).toString();
+                position.set(Position.KEY_RESULT, value.trim());
             } else {
-                buf.readUnsignedByte(); // card type
-                position.set(
-                        Position.KEY_DRIVER_UNIQUE_ID,
-                        buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString());
+                position.set(Position.KEY_RESULT, ByteBufUtil.hexDump(data));
             }
 
             return position;
diff --git a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
index c8e0005..e888642 100644
--- a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
@@ -20,6 +20,7 @@ import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import org.traccar.BaseProtocolDecoder;
+import org.traccar.helper.BufferUtil;
 import org.traccar.model.Device;
 import org.traccar.session.DeviceSession;
 import org.traccar.NetworkMessage;
@@ -112,18 +113,6 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
         }
     }
 
-    private boolean isPrintable(ByteBuf buf, int length) {
-        boolean printable = true;
-        for (int i = 0; i < length; i++) {
-            byte b = buf.getByte(buf.readerIndex() + i);
-            if (b < 32 && b != '\r' && b != '\n') {
-                printable = false;
-                break;
-            }
-        }
-        return printable;
-    }
-
     private void decodeSerial(
             Channel channel, SocketAddress remoteAddress, DeviceSession deviceSession, Position position, ByteBuf buf) {
 
@@ -169,7 +158,7 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
             position.set(Position.KEY_TYPE, type);
 
             int length = buf.readInt();
-            if (isPrintable(buf, length)) {
+            if (BufferUtil.isPrintable(buf, length)) {
                 String data = buf.readSlice(length).toString(StandardCharsets.US_ASCII).trim();
                 if (data.startsWith(""UUUUww"") && data.endsWith(""SSS"")) {
                     String[] values = data.substring(6, data.length() - 4).split("";"");
@@ -636,7 +625,7 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
                 buf.readUnsignedByte(); // type
                 int length = buf.readInt() - 4;
                 getLastLocation(position, new Date(buf.readUnsignedInt() * 1000));
-                if (isPrintable(buf, length)) {
+                if (BufferUtil.isPrintable(buf, length)) {
                     String data = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim();
                     if (data.startsWith(""GTSL"")) {
                         position.set(Position.KEY_DRIVER_UNIQUE_ID, data.split(""\\|"")[4]);
"
traccar-traccar-3642b9520863,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuaShengProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""137191681""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-3642b9520863:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
index 2fb7c6e..1ad27be 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
@@ -284,7 +284,7 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
                         String[] values = cell.split(""@"");
                         network.addCellTower(CellTower.from(
                                 Integer.parseInt(values[0]), Integer.parseInt(values[1]),
-                                Integer.parseInt(values[2], 16), Integer.parseInt(values[3], 16)));
+                                Integer.parseInt(values[2], 16), Long.parseLong(values[3], 16)));
                     }
                     break;
                 case 0x0021:
"
traccar-traccar-5a1a8d9192ee,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.T622IridiumProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: time ==> expected: <2023-07-18 02:10:08.000> but was: <2023-07-18 10:10:08.000>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-5a1a8d9192ee:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/T622IridiumProtocolDecoder.java b/src/main/java/org/traccar/protocol/T622IridiumProtocolDecoder.java
index 27b7baf..9e64ec9 100644
--- a/src/main/java/org/traccar/protocol/T622IridiumProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/T622IridiumProtocolDecoder.java
@@ -94,7 +94,7 @@ public class T622IridiumProtocolDecoder extends BaseProtocolDecoder {
                     position.setLongitude(buf.readIntLE() / 1000000.0);
                     break;
                 case 0x04:
-                    position.setTime(new Date((buf.readUnsignedIntLE() + 946713600) * 1000));
+                    position.setTime(new Date((buf.readUnsignedIntLE() + 946684800) * 1000));
                     break;
                 case 0x05:
                     position.setValid(buf.readUnsignedByte() > 0);
"
traccar-traccar-6631d7c4b352,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchFrameDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <5b33472a393730353134313734302a303030392a4c4b2c302c302c35335d> but was: <5b33472a393730353134313734302a303030392a4c4b2c302c302c35335d5b33472a393730353134313734302a303035412a55442c3139303732332c3139303730372c412c33362e3831353130392c4e2c31302e313739323331322c452c382e32342c3132372e392c32312e302c352c3130302c35332c302c302c30303030303030302c302c302c35382e305d5b33472a393730353134313734302a303030332a544b515d5b33472a393730353134313734302a303030392a4c4b2c302c302c35335d>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-6631d7c4b352:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WatchFrameDecoder.java b/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
index ec67aa3..9dfae87 100644
--- a/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchFrameDecoder.java
@@ -27,9 +27,21 @@ public class WatchFrameDecoder extends BaseFrameDecoder {
     protected Object decode(
             ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {
 
+        int brackets = 0;
         int endIndex = -1;
-        for (int i = buf.writerIndex() - 1; i >= buf.readerIndex(); i--) {
-            if (buf.getByte(i) == ']') {
+        for (int i = buf.readerIndex(); i < buf.writerIndex(); i++) {
+            byte b = buf.getByte(i);
+            switch (b) {
+                case '[':
+                    brackets += 1;
+                    break;
+                case ']':
+                    brackets -= 1;
+                    break;
+                default:
+                    break;
+            }
+            if (brackets == 0 && i > buf.readerIndex()) {
                 endIndex = i + 1;
                 break;
             }
"
traccar-traccar-6e5481ebb185,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <false> but was: <true>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-6e5481ebb185:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index f7cdd39..d6d9884 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -345,7 +345,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             mnc = buf.readUnsignedByte();
         }
         int lac;
-        if (type == MSG_LBS_ALARM) {
+        if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {
             lac = buf.readInt();
         } else {
             lac = buf.readUnsignedShort();
"
traccar-traccar-413d9a49c41a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuaShengProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <1.3212E7> but was: <0>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-413d9a49c41a:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
index 1ad27be..7d634b0 100644
--- a/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuaShengProtocolDecoder.java
@@ -229,7 +229,7 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
         position.setCourse(buf.readUnsignedShort());
         position.setAltitude(buf.readUnsignedShort());
 
-        position.set(Position.KEY_ODOMETER, buf.readUnsignedShort() * 1000);
+        buf.readUnsignedShort(); // odometer speed
 
         Network network = new Network();
 
@@ -264,8 +264,11 @@ public class HuaShengProtocolDecoder extends BaseProtocolDecoder {
                     buf.readUnsignedInt(); // run time
                     break;
                 case 0x0009:
-                    position.set(
-                            Position.KEY_VIN, buf.readCharSequence(length, StandardCharsets.US_ASCII).toString());
+                    position.set(Position.KEY_VIN, buf.readCharSequence(length, StandardCharsets.US_ASCII).toString());
+                    break;
+                case 0x0010:
+                    position.set(Position.KEY_ODOMETER, Double.parseDouble(
+                            buf.readCharSequence(length, StandardCharsets.US_ASCII).toString()) * 1000);
                     break;
                 case 0x0011:
                     position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 0.05);
"
traccar-traccar-1a1126d2d392,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.SuntechProtocolDecoderTest#testDecode()
Type: java.text.ParseException
Message: java.text.ParseException: Unparseable date: """"

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-1a1126d2d392:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/SuntechProtocolDecoder.java b/src/main/java/org/traccar/protocol/SuntechProtocolDecoder.java
index 047a182..86a8bf6 100644
--- a/src/main/java/org/traccar/protocol/SuntechProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/SuntechProtocolDecoder.java
@@ -271,18 +271,26 @@ public class SuntechProtocolDecoder extends BaseProtocolDecoder {
             index += 1; // collaborative network
         }
 
-        DateFormat dateFormat = new SimpleDateFormat(""yyyyMMddHH:mm:ss"");
-        dateFormat.setTimeZone(TimeZone.getTimeZone(""UTC""));
-        position.setTime(dateFormat.parse(values[index++] + values[index++]));
+        if (values[index].isEmpty()) {
 
-        position.setLatitude(Double.parseDouble(values[index++]));
-        position.setLongitude(Double.parseDouble(values[index++]));
-        position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(values[index++])));
-        position.setCourse(Double.parseDouble(values[index++]));
+            getLastLocation(position, null);
 
-        position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index++]));
+        } else {
 
-        position.setValid(values[index++].equals(""1""));
+            DateFormat dateFormat = new SimpleDateFormat(""yyyyMMddHH:mm:ss"");
+            dateFormat.setTimeZone(TimeZone.getTimeZone(""UTC""));
+            position.setTime(dateFormat.parse(values[index++] + values[index++]));
+
+            position.setLatitude(Double.parseDouble(values[index++]));
+            position.setLongitude(Double.parseDouble(values[index++]));
+            position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(values[index++])));
+            position.setCourse(Double.parseDouble(values[index++]));
+
+            position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index++]));
+
+            position.setValid(values[index++].equals(""1""));
+
+        }
 
         return position;
     }
"
traccar-traccar-d4db066c6e02,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.WatchProtocolDecoderTest#testDecode()
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d4db066c6e02:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
index 40d56b1..b586f4e 100644
--- a/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/WatchProtocolDecoder.java
@@ -51,7 +51,7 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
             .number(""(dd)(dd)(dd),"")             // time (hhmmss)
             .expression(""([AV]),"")               // validity
             .number("" *(-?d+.d+),"")              // latitude
-            .expression(""([NS]),"")
+            .expression(""([NS])?,"")
             .number("" *(-?d+.d+),"")              // longitude
             .expression(""([EW])?,"")
             .number(""(d+.?d*),"")                 // speed
@@ -285,7 +285,8 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                 || type.equalsIgnoreCase(""BLOOD"")
                 || type.equalsIgnoreCase(""BPHRT"")
                 || type.equalsIgnoreCase(""TEMP"")
-                || type.equalsIgnoreCase(""btemp2"")) {
+                || type.equalsIgnoreCase(""btemp2"")
+                || type.equalsIgnoreCase(""oxygen"")) {
 
             if (buf.isReadable()) {
 
@@ -303,6 +304,8 @@ public class WatchProtocolDecoder extends BaseProtocolDecoder {
                     if (Integer.parseInt(values[valueIndex++]) > 0) {
                         position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));
                     }
+                } else if (type.equalsIgnoreCase(""oxygen"")) {
+                    position.set(""bloodOxygen"", Integer.parseInt(values[++valueIndex]));
                 } else {
                     if (type.equalsIgnoreCase(""BPHRT"") || type.equalsIgnoreCase(""BLOOD"")) {
                         position.set(""pressureHigh"", values[valueIndex++]);
"
traccar-traccar-230f629c3dce,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.RuptelaProtocolDecoderTest#testDecode()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Longitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-230f629c3dce:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/RuptelaProtocolDecoder.java b/src/main/java/org/traccar/protocol/RuptelaProtocolDecoder.java
index 2122d50..649de7c 100644
--- a/src/main/java/org/traccar/protocol/RuptelaProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/RuptelaProtocolDecoder.java
@@ -248,17 +248,21 @@ public class RuptelaProtocolDecoder extends BaseProtocolDecoder {
 
                 buf.readUnsignedByte(); // priority (reserved)
 
-                position.setValid(true);
-                position.setLongitude(buf.readInt() / 10000000.0);
-                position.setLatitude(buf.readInt() / 10000000.0);
-                position.setAltitude(buf.readUnsignedShort() / 10.0);
-                position.setCourse(buf.readUnsignedShort() / 100.0);
-
-                position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());
-
-                position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));
-
-                position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);
+                int longitude = buf.readInt();
+                int latitude = buf.readInt();
+                if (longitude > Integer.MIN_VALUE && latitude > Integer.MIN_VALUE) {
+                    position.setValid(true);
+                    position.setLongitude(longitude / 10000000.0);
+                    position.setLatitude(latitude / 10000000.0);
+                    position.setAltitude(buf.readUnsignedShort() / 10.0);
+                    position.setCourse(buf.readUnsignedShort() / 100.0);
+                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());
+                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));
+                    position.set(Position.KEY_HDOP, buf.readUnsignedByte() / 10.0);
+                } else {
+                    buf.skipBytes(8);
+                    getLastLocation(position, null);
+                }
 
                 if (type == MSG_EXTENDED_RECORDS) {
                     position.set(Position.KEY_EVENT, buf.readUnsignedShort());
"
traccar-traccar-95fdfd770130,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <null> but was: <0.0>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-95fdfd770130:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index d6d9884..4762fc8 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -836,11 +836,6 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 }
             }
 
-            if (type == MSG_STATUS && variant == Variant.VXT01) {
-                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);
-                position.set(Position.KEY_RSSI, buf.readUnsignedByte());
-            }
-
             if (type == MSG_GPS_LBS_1) {
                 if (variant == Variant.GT06E_CARD) {
                     position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
@@ -1421,8 +1416,6 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             variant = Variant.VXT01;
         } else if (header == 0x7878 && type == MSG_GPS_LBS_STATUS_1 && length == 0x24) {
             variant = Variant.VXT01;
-        } else if (header == 0x7878 && type == MSG_STATUS && length == 0x0a) {
-            variant = Variant.VXT01;
         } else if (header == 0x7878 && type == MSG_LBS_MULTIPLE_3 && length == 0x31) {
             variant = Variant.WANWAY_S20;
         } else if (header == 0x7878 && type == MSG_LBS_MULTIPLE_3 && length == 0x2e) {
"
traccar-traccar-d979ab718ff0,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Latitude out of range

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-d979ab718ff0:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 4762fc8..53c812b 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -121,6 +121,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
         STANDARD,
         OBD6,
         WETRUST,
+        JC400,
     }
 
     private Variant variant;
@@ -269,12 +270,12 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
     }
 
     public static boolean decodeGps(Position position, ByteBuf buf, boolean hasLength, TimeZone timezone) {
-        return decodeGps(position, buf, hasLength, true, true, timezone);
+        return decodeGps(position, buf, hasLength, true, true, false, timezone);
     }
 
     public static boolean decodeGps(
             Position position, ByteBuf buf, boolean hasLength, boolean hasSatellites,
-            boolean hasSpeed, TimeZone timezone) {
+            boolean hasSpeed, boolean longSpeed, TimeZone timezone) {
 
         DateBuilder dateBuilder = new DateBuilder(timezone)
                 .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
@@ -293,7 +294,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
         double longitude = buf.readUnsignedInt() / 60.0 / 30000.0;
 
         if (hasSpeed) {
-            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));
+            position.setSpeed(UnitsConverter.knotsFromKph(
+                    longSpeed ? buf.readUnsignedShort() : buf.readUnsignedByte()));
         }
 
         int flags = buf.readUnsignedShort();
@@ -928,24 +930,44 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
 
             boolean extendedAlarm = dataLength > 7;
             if (extendedAlarm) {
-                decodeGps(position, buf, false, false, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));
+                if (variant == Variant.JC400) {
+                    buf.readUnsignedShort(); // marker
+                    buf.readUnsignedByte(); // version
+                }
+                decodeGps(
+                        position, buf, false,
+                        variant == Variant.JC400, variant == Variant.JC400, variant == Variant.JC400,
+                        deviceSession.get(DeviceSession.KEY_TIMEZONE));
             } else {
                 DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))
                         .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
                         .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());
                 getLastLocation(position, dateBuilder.getDate());
             }
-            short alarmType = buf.readUnsignedByte();
-            switch (alarmType) {
+            if (variant == Variant.JC400) {
+                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);
+            }
+            short event = buf.readUnsignedByte();
+            position.set(Position.KEY_EVENT, event);
+            switch (event) {
                 case 0x01:
                     position.set(Position.KEY_ALARM, extendedAlarm ? Position.ALARM_SOS : Position.ALARM_GENERAL);
                     break;
+                case 0x0E:
+                    position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER);
+                    break;
+                case 0x76:
+                    position.set(Position.KEY_ALARM, Position.ALARM_TEMPERATURE);
+                    break;
                 case 0x80:
                     position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);
                     break;
                 case 0x87:
                     position.set(Position.KEY_ALARM, Position.ALARM_OVERSPEED);
                     break;
+                case 0x88:
+                    position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT);
+                    break;
                 case 0x90:
                     position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION);
                     break;
@@ -959,7 +981,6 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT);
                     break;
                 default:
-                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);
                     break;
             }
 
@@ -1432,6 +1453,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             variant = Variant.OBD6;
         } else if (header == 0x7878 && type == MSG_GPS_LBS_1 && length == 0x29) {
             variant = Variant.WETRUST;
+        } else if (header == 0x7878 && type == MSG_ALARM && buf.getUnsignedShort(buf.readerIndex() + 4) == 0xffff) {
+            variant = Variant.JC400;
         } else {
             variant = Variant.STANDARD;
         }
"
traccar-traccar-4a5b8d79b560,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.StarcomProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <true> but was: <false>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-4a5b8d79b560:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/StarcomProtocolDecoder.java b/src/main/java/org/traccar/protocol/StarcomProtocolDecoder.java
index e758a8b..36d6693 100644
--- a/src/main/java/org/traccar/protocol/StarcomProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/StarcomProtocolDecoder.java
@@ -76,6 +76,7 @@ public class StarcomProtocolDecoder extends BaseProtocolDecoder {
                     position.set(Position.KEY_EVENT, Integer.parseInt(value));
                     break;
                 case ""mileage"":
+                case ""odometer"":
                     position.set(Position.KEY_ODOMETER, (long) (Double.parseDouble(value) * 1000));
                     break;
                 case ""satellites"":
"
traccar-traccar-ed3950fbdccf,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.GatorProtocolEncoderTest#testEncodePeriodicPositionRetrievalIntervalSet()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <242434000b5800383a00050005781d0d> but was: <242434000c5800383a0005000500781a0d>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-ed3950fbdccf:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/GatorProtocolEncoder.java b/src/main/java/org/traccar/protocol/GatorProtocolEncoder.java
index 4a3e21d..895c68a 100644
--- a/src/main/java/org/traccar/protocol/GatorProtocolEncoder.java
+++ b/src/main/java/org/traccar/protocol/GatorProtocolEncoder.java
@@ -91,7 +91,7 @@ public class GatorProtocolEncoder extends BaseProtocolEncoder {
                 String[] data = command.getString(Command.KEY_FREQUENCY).split("";"");
                 content.writeShort(Integer.valueOf(data[0]));
                 content.writeShort(Integer.valueOf(data[1]));
-                content.writeShort(Integer.valueOf(data[2]));
+                content.writeByte(Integer.valueOf(data[2]));
                 return encodeContent(command.getDeviceId(), GatorProtocolDecoder.MSG_POSITION_PERIODIC, content);
             default:
                 return null;
"
traccar-traccar-cadcd2676adb,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.KhdProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <100> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-cadcd2676adb:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/KhdProtocolDecoder.java b/src/main/java/org/traccar/protocol/KhdProtocolDecoder.java
index d7c236c..dd2e1db 100644
--- a/src/main/java/org/traccar/protocol/KhdProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/KhdProtocolDecoder.java
@@ -205,6 +205,9 @@ public class KhdProtocolDecoder extends BaseProtocolDecoder {
                                 }
                             }
                             break;
+                        case 0x20:
+                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());
+                            break;
                         case 0x23:
                             Network network = new Network();
                             int count = buf.readUnsignedByte();
"
traccar-traccar-7ce4fb9a628f,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.StartekProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""2286304571""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-7ce4fb9a628f:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
index 9c749c8..5cfbb36 100644
--- a/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/StartekProtocolDecoder.java
@@ -178,7 +178,7 @@ public class StartekProtocolDecoder extends BaseProtocolDecoder {
         position.setCourse(parser.nextInt());
         position.setAltitude(parser.nextInt());
 
-        position.set(Position.KEY_ODOMETER, parser.nextInt());
+        position.set(Position.KEY_ODOMETER, parser.nextLong());
 
         position.setNetwork(new Network(CellTower.from(
                 parser.nextInt(), parser.nextInt(), parser.nextHexInt(), parser.nextHexInt(), parser.nextInt())));
"
traccar-traccar-a9c311855a49,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.PuiProtocolDecoderTest#testDecode()
Type: java.text.ParseException
Message: java.text.ParseException: Unparseable date: ""2023-06-01T03:09:51.362Z""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-a9c311855a49:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/PuiProtocolDecoder.java b/src/main/java/org/traccar/protocol/PuiProtocolDecoder.java
index a80af65..f10ff3f 100644
--- a/src/main/java/org/traccar/protocol/PuiProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/PuiProtocolDecoder.java
@@ -51,7 +51,7 @@ public class PuiProtocolDecoder extends BaseMqttProtocolDecoder {
 
                 position.setValid(true);
 
-                DateFormat dateFormat = new SimpleDateFormat(""yyyyMMdd'T'HHmmss.SSS'Z'"");
+                DateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"");
                 position.setTime(dateFormat.parse(json.getString(""ts"")));
 
                 JsonObject location = json.getJsonObject(""location"");
"
traccar-traccar-8638bc8ab98f,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.HuabaoProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <9001738> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-8638bc8ab98f:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
index beb1ec4..6e83733 100644
--- a/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/HuabaoProtocolDecoder.java
@@ -489,8 +489,22 @@ public class HuabaoProtocolDecoder extends BaseProtocolDecoder {
                     buf.readUnsignedByte(); // reserved
                     break;
                 case 0x60:
-                    position.set(Position.KEY_EVENT, buf.readUnsignedShort());
-                    buf.skipBytes(length - 2);
+                    int event = buf.readUnsignedShort();
+                    position.set(Position.KEY_EVENT, event);
+                    if (event >= 0x0061 && event <= 0x0066) {
+                        buf.skipBytes(6); // lock id
+                        stringValue = buf.readCharSequence(8, StandardCharsets.US_ASCII).toString();
+                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);
+                    }
+                    break;
+                case 0x63:
+                    for (int i = 1; i <= length / 11; i++) {
+                        position.set(""lock"" + i + ""Id"", ByteBufUtil.hexDump(buf.readSlice(6)));
+                        position.set(""lock"" + i + ""Battery"", buf.readUnsignedShort() * 0.001);
+                        position.set(""lock"" + i + ""Seal"", buf.readUnsignedByte() == 0x31);
+                        buf.readUnsignedByte(); // physical state
+                        buf.readUnsignedByte(); // rssi
+                    }
                     break;
                 case 0x69:
                     position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);
"
traccar-traccar-6f59f756a7d3,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.T800xProtocolDecoderTest#testDecode()
Type: java.lang.NumberFormatException
Message: java.lang.NumberFormatException: For input string: ""005b""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-6f59f756a7d3:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/T800xProtocolDecoder.java b/src/main/java/org/traccar/protocol/T800xProtocolDecoder.java
index 4ddea73..a1093fc 100644
--- a/src/main/java/org/traccar/protocol/T800xProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/T800xProtocolDecoder.java
@@ -391,7 +391,7 @@ public class T800xProtocolDecoder extends BaseProtocolDecoder {
                 for (int i = 1; i <= adcCount; i++) {
                     String value = ByteBufUtil.hexDump(buf.readSlice(2));
                     if (!value.equals(""ffff"")) {
-                        position.set(Position.PREFIX_ADC + i, Integer.parseInt(value) * 0.01);
+                        position.set(Position.PREFIX_ADC + i, Integer.parseInt(value, 16) * 0.01);
                     }
                 }
             }
"
traccar-traccar-65f54c200cf0,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.TeltonikaProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <3030> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-65f54c200cf0:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
index e888642..16c1dd2 100644
--- a/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/TeltonikaProtocolDecoder.java
@@ -588,6 +588,34 @@ public class TeltonikaProtocolDecoder extends BaseProtocolDecoder {
                         }
                         index += 1;
                     }
+                } else if (id == 10829 || id == 10831) {
+                    ByteBuf data = buf.readSlice(length);
+                    data.readUnsignedByte(); // header
+                    for (int i = 1; data.isReadable(); i++) {
+                        ByteBuf beacon = data.readSlice(data.readUnsignedByte());
+                        while (beacon.isReadable()) {
+                            int parameterId = beacon.readUnsignedByte();
+                            int parameterLength = beacon.readUnsignedByte();
+                            switch (parameterId) {
+                                case 0:
+                                    position.set(""tag"" + i + ""Rssi"", (int) beacon.readByte());
+                                    break;
+                                case 1:
+                                    String beaconId = ByteBufUtil.hexDump(beacon.readSlice(parameterLength));
+                                    position.set(""tag"" + i + ""Id"", beaconId);
+                                    break;
+                                case 13:
+                                    position.set(""tag"" + i + ""LowBattery"", beacon.readUnsignedByte());
+                                    break;
+                                case 14:
+                                    position.set(""tag"" + i + ""Battery"", beacon.readUnsignedShort());
+                                    break;
+                                default:
+                                    beacon.skipBytes(parameterLength);
+                                    break;
+                            }
+                        }
+                    }
                 } else {
                     position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));
                 }
"
traccar-traccar-45a0d3b8673a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <53.76> but was: <null>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-45a0d3b8673a:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index 161d04d..e9bdaf1 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -124,6 +124,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
         WETRUST,
         JC400,
         SL4X,
+        SEEWORLD,
     }
 
     private Variant variant;
@@ -901,6 +902,20 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                 }
             }
 
+            if (type == MSG_GPS_LBS_2 && variant == Variant.SEEWORLD) {
+                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);
+                buf.readUnsignedByte(); // reporting mode
+                buf.readUnsignedByte(); // supplementary transmission
+                position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());
+                buf.readUnsignedInt(); // travel time
+                int temperature = buf.readUnsignedShort();
+                if (BitUtil.check(temperature, 15)) {
+                    temperature = -BitUtil.to(temperature, 15);
+                }
+                position.set(Position.PREFIX_TEMP + 1, temperature * 0.01);
+                position.set(""humidity"", buf.readUnsignedShort() * 0.01);
+            }
+
             if ((type == MSG_GPS_LBS_2 || type == MSG_GPS_LBS_3 || type == MSG_GPS_LBS_4)
                     && buf.readableBytes() >= 3 + 6) {
                 position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);
@@ -1468,6 +1483,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             variant = Variant.JC400;
         } else if (header == 0x7878 && type == MSG_LBS_3 && length == 0x37) {
             variant = Variant.SL4X;
+        } else if (header == 0x7878 && type == MSG_GPS_LBS_2 && length == 0x2f) {
+            variant = Variant.SEEWORLD;
         } else {
             variant = Variant.STANDARD;
         }
"
traccar-traccar-fa2a61f6487c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <0.32> but was: <0.0>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-fa2a61f6487c:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index e9bdaf1..f676e73 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -358,7 +358,7 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
         long cid;
         if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {
             cid = buf.readLong();
-        } else if (type == MSG_GPS_LBS_6) {
+        } else if (type == MSG_GPS_LBS_6 || variant == Variant.SEEWORLD) {
             cid = buf.readUnsignedInt();
         } else {
             cid = buf.readUnsignedMedium();
@@ -1485,6 +1485,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
             variant = Variant.SL4X;
         } else if (header == 0x7878 && type == MSG_GPS_LBS_2 && length == 0x2f) {
             variant = Variant.SEEWORLD;
+        } else if (header == 0x7878 && type == MSG_GPS_LBS_STATUS_1 && length == 0x26) {
+            variant = Variant.SEEWORLD;
         } else {
             variant = Variant.STANDARD;
         }
"
traccar-traccar-37ed394724c0,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.traccar.protocol.Gt06ProtocolDecoderTest#testDecode()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <93> but was: <1550>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.traccar-traccar-37ed394724c0:msbench-0.0.1,"diff --git a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
index f676e73..cf7cd12 100644
--- a/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
+++ b/src/main/java/org/traccar/protocol/Gt06ProtocolDecoder.java
@@ -841,7 +841,8 @@ public class Gt06ProtocolDecoder extends BaseProtocolDecoder {
                     buf.readUnsignedByte(); // working mode
                     position.set(Position.KEY_POWER, buf.readUnsignedShort() / 100.0);
                 } else {
-                    position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 100 / 6);
+                    int battery = buf.readUnsignedByte();
+                    position.set(Position.KEY_BATTERY_LEVEL, battery <= 6 ? battery * 100 / 6 : battery);
                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());
                     short alarmExtension = buf.readUnsignedByte();
                     if (variant != Variant.VXT01) {
"
vmzakharov-dataframe-ec-12af99192d24,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: io.github.vmzakharov.ecdataframe.dsl.PrettyPrintingTest#nestedQuotes
Type: org.junit.ComparisonFailure
Message: expected:<(""foo"" in (""qux"", ['ba""r'], ""baz"", ""wal'do""))> but was:<(""foo"" in (""qux"", [""ba""r""], ""baz"", ""wal'do""))>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.vmzakharov-dataframe-ec-12af99192d24:msbench-0.0.1,"diff --git a/src/main/java/io/github/vmzakharov/ecdataframe/dsl/value/StringValue.java b/src/main/java/io/github/vmzakharov/ecdataframe/dsl/value/StringValue.java
index c2ee8fc..8ff1213 100644
--- a/src/main/java/io/github/vmzakharov/ecdataframe/dsl/value/StringValue.java
+++ b/src/main/java/io/github/vmzakharov/ecdataframe/dsl/value/StringValue.java
@@ -30,7 +30,7 @@ extends AbstractValue
     @Override
     public String asStringLiteral()
     {
-        return '""' + this.value + '""';
+        return this.value.indexOf('\""') == -1 ? '""' + this.value + '""' : '\'' + this.value + '\'';
     }
 
     @Override
"
vmzakharov-dataframe-ec-e9eb4dbe0e70,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: io.github.vmzakharov.ecdataframe.dataframe.DfColumnCompareTest#compareWithNullValues
Type: java.lang.AssertionError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.vmzakharov-dataframe-ec-e9eb4dbe0e70:msbench-0.0.1,"diff --git a/src/main/java/io/github/vmzakharov/ecdataframe/dataframe/compare/ComparisonResult.java b/src/main/java/io/github/vmzakharov/ecdataframe/dataframe/compare/ComparisonResult.java
index 9558912..af740c8 100644
--- a/src/main/java/io/github/vmzakharov/ecdataframe/dataframe/compare/ComparisonResult.java
+++ b/src/main/java/io/github/vmzakharov/ecdataframe/dataframe/compare/ComparisonResult.java
@@ -48,12 +48,12 @@ abstract public class ComparisonResult
 
     public boolean leftIsNull()
     {
-        return this.nullSide == LEFT_NULL;
+        return this.nullSide == LEFT_NULL || this.nullSide == BOTH_NULLS;
     }
 
     public boolean rightIsNull()
     {
-        return this.nullSide == RIGHT_NULL;
+        return this.nullSide == RIGHT_NULL || this.nullSide == BOTH_NULLS;
     }
 
     public boolean noNulls()
@@ -66,7 +66,7 @@ abstract public class ComparisonResult
         return this.nullSide;
     }
 
-    public void nullSide(NullSide newNullSide)
+    private void nullSide(NullSide newNullSide)
     {
         this.nullSide = newNullSide;
     }
"
w3c-epubcheck-0759a82ae407,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: EPUB 3 — Publication Resources#Verify OPUS audio is allowed
Type: java.lang.AssertionError
Message: Unexpected error
Expected: is an empty iterable
     but: [<ERROR RSC-032: Fallback must be provided for foreign resources, but found none for resource ""EPUB/audio.opus"" of type ""audio/ogg ; codecs=opus"". | in EPUB/content_001.xhtml(12,11)>]

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.w3c-epubcheck-0759a82ae407:msbench-0.0.1,"diff --git a/src/main/java/com/adobe/epubcheck/opf/OPFChecker30.java b/src/main/java/com/adobe/epubcheck/opf/OPFChecker30.java
index 9fc2495..0338efa 100644
--- a/src/main/java/com/adobe/epubcheck/opf/OPFChecker30.java
+++ b/src/main/java/com/adobe/epubcheck/opf/OPFChecker30.java
@@ -565,7 +565,7 @@ public class OPFChecker30 extends OPFChecker
 
   public static boolean isBlessedAudioType(String type)
   {
-    return type.equals(""audio/mpeg"") || type.equals(""audio/mp4"") || type.equals(""audio/opus"");
+    return type.equals(""audio/mpeg"") || type.equals(""audio/mp4"") || type.matches(""audio/ogg\\s*;\\s*codecs=opus"");
   }
 
   public static boolean isVideoType(String type)
diff --git a/src/main/java/com/adobe/epubcheck/ops/OPSHandler30.java b/src/main/java/com/adobe/epubcheck/ops/OPSHandler30.java
index 290a042..7e48144 100644
--- a/src/main/java/com/adobe/epubcheck/ops/OPSHandler30.java
+++ b/src/main/java/com/adobe/epubcheck/ops/OPSHandler30.java
@@ -644,6 +644,14 @@ public class OPSHandler30 extends OPSHandler
       // remove any params from the given MIME type string
       mimetype = MIMEType.removeParams(mimetype);
 
+      // hack: remove the codecs parameter in the resource type for OPUS audio
+      // so that the equality check works
+      // TODO remove this when we implement proper MIME type parsing
+      if (resourceMimetype != null && resourceMimetype.matches(""audio/ogg\\s*;\\s*codecs=opus""))
+      {
+        resourceMimetype = ""audio/ogg"";
+      }
+
       // report any MIME type mismatch as a warning
       if (resourceMimetype != null && !resourceMimetype.equals(mimetype))
       {
"
w3c-epubcheck-7804c78a53f2,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: EPUBCheck - JSON Report tests#cross-HTML references
Type: java.lang.AssertionError
Message: 
Expected: is json with json path ""$..['items'][?]['referencedItems'][0]"" evaluated to <[EPUB/content_001.xhtml]>
     but: json path ""$..['items'][?]['referencedItems'][0]"" was evaluated to <[]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.w3c-epubcheck-7804c78a53f2:msbench-0.0.1,"diff --git a/src/main/java/org/w3c/epubcheck/core/references/ResourceReferencesChecker.java b/src/main/java/org/w3c/epubcheck/core/references/ResourceReferencesChecker.java
index 21074cb..2f1dd08 100755
--- a/src/main/java/org/w3c/epubcheck/core/references/ResourceReferencesChecker.java
+++ b/src/main/java/org/w3c/epubcheck/core/references/ResourceReferencesChecker.java
@@ -43,6 +43,7 @@ import com.adobe.epubcheck.opf.OPFChecker;
 import com.adobe.epubcheck.opf.OPFChecker30;
 import com.adobe.epubcheck.opf.ValidationContext;
 import com.adobe.epubcheck.util.EPUBVersion;
+import com.adobe.epubcheck.util.FeatureEnum;
 import com.google.common.base.Preconditions;
 
 import io.mola.galimatias.URL;
@@ -108,6 +109,9 @@ public class ResourceReferencesChecker
 
   private void checkReference(Reference reference)
   {
+    // Report the reference
+    report.info(reference.location.getPath(), FeatureEnum.RESOURCE, container.relativize(reference.url));
+    
     // Retrieve the target resource
     Optional<Resource> targetResource = resourceRegistry.getResource(reference.targetResource);
     try
"
w3c-epubcheck-49aacb238c3e,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.adobe.epubcheck.tools.CommandLineTest#versionDisplayTest1
Type: java.lang.AssertionError
Message: Return code expected:<0> but was:<1>

Test: com.adobe.epubcheck.tools.CommandLineTest#versionDisplayTest2
Type: java.lang.AssertionError
Message: Return code expected:<0> but was:<1>

Test: com.adobe.epubcheck.tools.CommandLineTest#helpMessageTest1
Type: java.lang.AssertionError
Message: Return code expected:<0> but was:<1>

Test: com.adobe.epubcheck.tools.CommandLineTest#helpMessageTest2
Type: java.lang.AssertionError
Message: Return code expected:<0> but was:<1>

Test: com.adobe.epubcheck.tools.CommandLineTest#helpMessageTest3
Type: java.lang.AssertionError
Message: Return code expected:<0> but was:<1>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.w3c-epubcheck-49aacb238c3e:msbench-0.0.1,"diff --git a/src/main/java/com/adobe/epubcheck/tool/EpubChecker.java b/src/main/java/com/adobe/epubcheck/tool/EpubChecker.java
index d92493c..bd38ac8 100644
--- a/src/main/java/com/adobe/epubcheck/tool/EpubChecker.java
+++ b/src/main/java/com/adobe/epubcheck/tool/EpubChecker.java
@@ -92,6 +92,7 @@ public class EpubChecker
   File listChecksOut;
   File customMessageFile;
   boolean listChecks = false;
+  boolean displayHelpOrVersion = false;
   boolean useCustomMessageFile = false;
   boolean failOnWarnings = false;
   private Messages messages = Messages.getInstance();
@@ -138,6 +139,10 @@ public class EpubChecker
           dumpMessageDictionary(report);
           return 0;
         }
+        if (displayHelpOrVersion)
+        {
+          return 0;
+        }
         if (useCustomMessageFile)
         {
           report.setCustomMessageFile(customMessageFile.getAbsolutePath());
@@ -487,7 +492,7 @@ public class EpubChecker
     setCustomMessageFileFromEnvironment();
 
     Pattern argPattern = Pattern.compile(""--?(.*)"");
-
+    
     for (int i = 0; i < args.length; i++)
     {
       Matcher argMatch = argPattern.matcher(args[i]);
@@ -738,9 +743,11 @@ public class EpubChecker
           case ""?"":
           case ""help"":
               displayHelp(); // display help message
+              displayHelpOrVersion = true;
             break;
           case ""version"":
             displayVersion();
+            displayHelpOrVersion = true;
             break;
           default:
               System.err.println(String.format(messages.get(""unrecognized_argument""), args[i]));
@@ -789,7 +796,7 @@ public class EpubChecker
 
     if (path == null)
     {
-      if (listChecks)
+      if (listChecks || displayHelpOrVersion)
       {
         return true;
       }
"
wmixvideo-nfe-67518e14db7e,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.fincatto.documentofiscal.mdfe3.classes.nota.MDFProcessadoTest#deveGerarXMLDeAcordoComOPadraoEstabelecido
Type: org.junit.ComparisonFailure
Message: expected:<...ra>888888</tara><cap[KG>130</capKG><capM3>230</capM3><tpCar>02</tpCar><UF>ES</UF><prop><CPF>99999999999</CPF><RNTRC>55555555</RNTRC><xNome>NONONONO NONONONO</xNome><IE>77777777</IE><UF>ES</UF><tpProp>1</tpProp></prop]></veicReboque></rod...> but was:<...ra>888888</tara><cap[M3>230</capM3><prop><CPF>99999999999</CPF><RNTRC>55555555</RNTRC><xNome>NONONONO NONONONO</xNome><IE>77777777</IE><UF>ES</UF><tpProp>1</tpProp></prop><tpCar>02</tpCar><UF>ES</UF><capKG>130</capKG]></veicReboque></rod...>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.wmixvideo-nfe-67518e14db7e:msbench-0.0.1,"diff --git a/src/main/java/com/fincatto/documentofiscal/mdfe3/classes/nota/MDFInfoModalRodoviarioVeiculoReboque.java b/src/main/java/com/fincatto/documentofiscal/mdfe3/classes/nota/MDFInfoModalRodoviarioVeiculoReboque.java
index c198a2c..6101f88 100644
--- a/src/main/java/com/fincatto/documentofiscal/mdfe3/classes/nota/MDFInfoModalRodoviarioVeiculoReboque.java
+++ b/src/main/java/com/fincatto/documentofiscal/mdfe3/classes/nota/MDFInfoModalRodoviarioVeiculoReboque.java
@@ -1,35 +1,73 @@
 package com.fincatto.documentofiscal.mdfe3.classes.nota;
 
+import com.fincatto.documentofiscal.DFBase;
+import com.fincatto.documentofiscal.DFUnidadeFederativa;
+import com.fincatto.documentofiscal.mdfe3.classes.def.MDFTipoCarroceria;
 import org.simpleframework.xml.Element;
 
 import com.fincatto.documentofiscal.validadores.DFStringValidador;
 
-public class MDFInfoModalRodoviarioVeiculoReboque extends MDFInfoModalRodoviarioVeiculo {
+public class MDFInfoModalRodoviarioVeiculoReboque extends DFBase {
     private static final long serialVersionUID = -2787982058485353668L;
+    @Element(name = ""cInt"", required = false)
+    protected String codigoInterno;
+
+    @Element(name = ""placa"")
+    protected String placa;
+
+    @Element(name = ""RENAVAM"", required = false)
+    protected String renavam;
+
+    @Element(name = ""tara"")
+    protected String tara;
+
     @Element(name = ""capKG"")
     private String capacidadeKG;
 
-    @Override
+    @Element(name = ""capM3"", required = false)
+    protected String capacidadeM3;
+
+    /**
+     * Tipo de carroceria
+     */
+    @Element(name = ""tpCar"")
+    protected MDFTipoCarroceria tipoCarroceria;
+
+    @Element(name = ""UF"")
+    protected String unidadeFederativa;
+
+    @Element(name = ""prop"", required = false)
+    protected MDFInfoModalRodoviarioVeiculoProp proprietario;
+
     public void setCodigoInterno(final String codigoInterno) {
-        super.codigoInterno = DFStringValidador.validador(codigoInterno, ""Codigo interno Veiculo Reboque"", 10, false, false);
+        this.codigoInterno = DFStringValidador.validador(codigoInterno, ""Codigo interno Veiculo Reboque"", 10, false, false);
+    }
+
+    public String getPlaca() {
+        return this.placa;
     }
 
-    @Override
     public void setPlaca(final String placa) {
         DFStringValidador.placaDeVeiculo(placa, ""Placa do reboque"");
         this.placa = placa;
     }
 
-    @Override
+    public String getRenavam() {
+        return this.renavam;
+    }
+
     public void setRenavam(final String renavam) {
         this.renavam = DFStringValidador.validaIntervalo(renavam, 9, 11, ""Renavam do reboque"");
     }
 
-    @Override
     public void setTara(final String tara) {
         this.tara = DFStringValidador.capacidadeNDigitos(tara, ""Tara em reboque"", 5);
     }
 
+    public String getTara() {
+        return this.tara;
+    }
+
     public String getCapacidadeKG() {
         return this.capacidadeKG;
     }
@@ -38,14 +76,40 @@ public class MDFInfoModalRodoviarioVeiculoReboque extends MDFInfoModalRodoviario
         this.capacidadeKG = DFStringValidador.capacidadeNDigitos(capacidadeKG, ""Capacidade em KG reboque"", 5);
     }
 
-    @Override
     public String getCapacidadeM3() {
         return this.capacidadeM3;
     }
 
-    @Override
     public void setCapacidadeM3(final String capacidadeM3) {
         this.capacidadeM3 = DFStringValidador.capacidadeNDigitos(capacidadeM3, ""Capacidade em M3 reboque"", 2);
     }
 
+    public void setProprietario(final MDFInfoModalRodoviarioVeiculoProp proprietario) {
+        this.proprietario = proprietario;
+    }
+
+    public MDFInfoModalRodoviarioVeiculoProp getProprietario() {
+        return this.proprietario;
+    }
+
+    public MDFTipoCarroceria getTipoCarroceria() {
+        return this.tipoCarroceria;
+    }
+
+    public void setTipoCarroceria(final MDFTipoCarroceria tipoCarroceria) {
+        this.tipoCarroceria = tipoCarroceria;
+    }
+
+    public String getUnidadeFederativa() {
+        return this.unidadeFederativa;
+    }
+
+    public void setUnidadeFederativa(final String unidadeFederativa) {
+        this.unidadeFederativa = unidadeFederativa;
+    }
+
+    public void setUnidadeFederativa(final DFUnidadeFederativa unidadeFederativa) {
+        this.unidadeFederativa = unidadeFederativa.getCodigo();
+    }
+
 }
"
authme-configme-7bf10c513479,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[1]
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <ch.jalu.configme.exception.ConfigMeException> but was: <java.lang.ArrayIndexOutOfBoundsException>

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[2]
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <ch.jalu.configme.exception.ConfigMeException> but was: <java.lang.ArrayIndexOutOfBoundsException>

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[3]
Type: org.opentest4j.AssertionFailedError
Message: Expected ch.jalu.configme.exception.ConfigMeException to be thrown, but nothing was thrown.

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[4]
Type: org.opentest4j.AssertionFailedError
Message: Expected ch.jalu.configme.exception.ConfigMeException to be thrown, but nothing was thrown.

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[5]
Type: org.opentest4j.AssertionFailedError
Message: Expected ch.jalu.configme.exception.ConfigMeException to be thrown, but nothing was thrown.

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForMalformedPropertyPath(String)[6]
Type: org.opentest4j.AssertionFailedError
Message: Expected ch.jalu.configme.exception.ConfigMeException to be thrown, but nothing was thrown.

Test: ch.jalu.configme.configurationdata.PropertyListBuilderTest#shouldThrowForRootPathAndOtherProperty
Type: org.opentest4j.AssertionFailedError
Message: Expected ch.jalu.configme.exception.ConfigMeException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.authme-configme-7bf10c513479:msbench-0.0.1,"diff --git a/src/main/java/ch/jalu/configme/configurationdata/PropertyListBuilder.java b/src/main/java/ch/jalu/configme/configurationdata/PropertyListBuilder.java
index ea010a0..44ad63b 100644
--- a/src/main/java/ch/jalu/configme/configurationdata/PropertyListBuilder.java
+++ b/src/main/java/ch/jalu/configme/configurationdata/PropertyListBuilder.java
@@ -11,7 +11,7 @@ import java.util.Map;
 
 /**
  * Builds a list of known properties in an ordered and grouped manner.
- *
+ * <p>
  * It guarantees that the added entries:
  * <ul>
  *   <li>are grouped by path, e.g. all ""DataSource.mysql"" properties are together, and ""DataSource.mysql"" properties
@@ -24,7 +24,7 @@ import java.util.Map;
  */
 public class PropertyListBuilder {
 
-    private @NotNull Map<String, Object> rootEntries = new LinkedHashMap<>();
+    private final @NotNull Map<String, Object> rootEntries = new LinkedHashMap<>();
 
     /**
      * Adds the property to the list builder.
@@ -32,17 +32,16 @@ public class PropertyListBuilder {
      * @param property the property to add
      */
     public void add(@NotNull Property<?> property) {
-        String[] paths = property.getPath().split(""\\."");
-        Map<String, Object> map = rootEntries;
-        for (int i = 0; i < paths.length - 1; ++i) {
-            map = getChildMap(map, paths[i]);
-        }
+        String[] pathElements = property.getPath().split(""\\."", -1);
+        Map<String, Object> mapForProperty = getMapBeforeLastElement(pathElements);
 
-        final String end = paths[paths.length - 1];
-        if (map.containsKey(end)) {
+        final String lastElement = pathElements[pathElements.length - 1];
+        if (mapForProperty.containsKey(lastElement)) {
             throw new ConfigMeException(""Path at '"" + property.getPath() + ""' already exists"");
+        } else if (pathElements.length > 1 && lastElement.equals("""")) {
+            throwExceptionForMalformedPath(property.getPath());
         }
-        map.put(end, property);
+        mapForProperty.put(lastElement, property);
     }
 
     /**
@@ -54,9 +53,36 @@ public class PropertyListBuilder {
     public @NotNull List<Property<?>> create() {
         List<Property<?>> result = new ArrayList<>();
         collectEntries(rootEntries, result);
+        if (result.size() > 1 && rootEntries.containsKey("""")) {
+            throw new ConfigMeException(""A property at the root path (\""\"") cannot be defined alongside ""
+                + ""other properties as the paths would conflict"");
+        }
         return result;
     }
 
+    /**
+     * Returns the nested map for the given path parts in which a property can be saved (for the last element
+     * in the path parts). Throws an exception if the path is malformed.
+     *
+     * @param pathParts the path elements (i.e. the property path split by ""."")
+     * @return the map to store the property in
+     */
+    protected @NotNull Map<String, Object> getMapBeforeLastElement(String @NotNull [] pathParts) {
+        Map<String, Object> map = rootEntries;
+        for (int i = 0; i < pathParts.length - 1; ++i) {
+            map = getChildMap(map, pathParts[i]);
+            if (pathParts[i].equals("""")) {
+                throwExceptionForMalformedPath(String.join(""."", pathParts));
+            }
+        }
+        return map;
+    }
+
+    protected void throwExceptionForMalformedPath(@NotNull String path) {
+        throw new ConfigMeException(""The path at '"" + path + ""' is malformed: dots may not be at the beginning or end ""
+            + ""of a path, and dots may not appear multiple times successively."");
+    }
+
     protected final @NotNull Map<String, Object> getRootEntries() {
         return rootEntries;
     }
"
authme-configme-aa91a6b315ec,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: ch.jalu.configme.configurationdata.CommentsConfigurationTest#shouldOverrideExistingComment
Type: org.opentest4j.AssertionFailedError
Message: Expected java.lang.IllegalStateException to be thrown, but nothing was thrown.

Test: ch.jalu.configme.configurationdata.CommentsConfigurationTest#shouldThrowForExistingPath
Type: org.opentest4j.AssertionFailedError
Message: Expected java.lang.IllegalStateException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.authme-configme-aa91a6b315ec:msbench-0.0.1,"diff --git a/src/main/java/ch/jalu/configme/configurationdata/CommentsConfiguration.java b/src/main/java/ch/jalu/configme/configurationdata/CommentsConfiguration.java
index 225e0c4..0f050ce 100644
--- a/src/main/java/ch/jalu/configme/configurationdata/CommentsConfiguration.java
+++ b/src/main/java/ch/jalu/configme/configurationdata/CommentsConfiguration.java
@@ -41,7 +41,11 @@ public class CommentsConfiguration {
      * @param commentLines the comment lines to set for the path
      */
     public void setComment(@NotNull String path, @NotNull String... commentLines) {
-        comments.put(path, Collections.unmodifiableList(Arrays.asList(commentLines)));
+        List<String> replaced = comments.put(path, Collections.unmodifiableList(Arrays.asList(commentLines)));
+        
+        if (replaced != null) {
+            throw new IllegalStateException(""Comment lines already exists for the path '"" + path + ""'"");
+        }
     }
 
     /**
"
bindambc-whatsapp-business-java-api-362caf5eb33c,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.whatsapp.api.impl.WhatsappBusinessCloudApiTest#testSendTemplateTextMessage
Type: org.opentest4j.AssertionFailedError
Message: expected: <{""messaging_product"":""whatsapp"",""recipient_type"":""individual"",""to"":""a_phone_number_to_test"",""type"":""template"",""template"":{""components"":[{""type"":""BODY"",""parameters"":[{""type"":""text"",""text"":""18754269072""}]}],""name"":""number_confirmation"",""language"":{""code"":""pt_BR""}}}> but was: <{""messaging_product"":""whatsapp"",""recipient_type"":""individual"",""to"":""a_phone_number_to_test"",""type"":""template"",""template"":{""components"":[{""type"":""BODY"",""parameters"":[{""type"":""text"",""text"":""18754269072""}]}],""name"":""number_confirmation"",""language"":{}}}>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.bindambc-whatsapp-business-java-api-362caf5eb33c:msbench-0.0.1,"diff --git a/src/main/java/com/whatsapp/api/domain/messages/Language.java b/src/main/java/com/whatsapp/api/domain/messages/Language.java
index 817f020..52c88d5 100644
--- a/src/main/java/com/whatsapp/api/domain/messages/Language.java
+++ b/src/main/java/com/whatsapp/api/domain/messages/Language.java
@@ -1,28 +1,12 @@
 package com.whatsapp.api.domain.messages;
 
 import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.whatsapp.api.domain.templates.type.LanguageType;
 
 /**
- * The type Language.
+ * @param code Language code. See {@link LanguageType}
  */
 @JsonInclude(JsonInclude.Include.NON_NULL)
-public record Language(LanguageType code) {
-    /**
-     * Instantiates a new Language.
-     *
-     * @param code the code
-     */
-    public Language {
-    }
-
-    /**
-     * Gets code.
-     *
-     * @return the code
-     */
-    @Override
-    public LanguageType code() {
-        return code;
-    }
+public record Language(@JsonProperty(""code"") LanguageType code) {
 }
"
bindambc-whatsapp-business-java-api-fd321cb63437,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.whatsapp.api.impl.WhatsappBusinessManagementApiTest#testRetrieveMessageTemplate1
Type: java.lang.AssertionError
Message: data[1].components[3].buttons[0]
Expected: type
     but none found
 ; data[1].components[3].buttons[1]
Expected: type
     but none found
 ; data[2].components[3].buttons[0]
Expected: type
     but none found
 ; data[2].components[3].buttons[1]
Expected: type
     but none found
 ; data[2].components[3].buttons[2]
Expected: type
     but none found
 ; data[5].components[3].buttons[0]
Expected: type
     but none found


Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.bindambc-whatsapp-business-java-api-fd321cb63437:msbench-0.0.1,"diff --git a/src/main/java/com/whatsapp/api/domain/templates/QuickReplyButton.java b/src/main/java/com/whatsapp/api/domain/templates/QuickReplyButton.java
index f7a21a9..4ad1003 100644
--- a/src/main/java/com/whatsapp/api/domain/templates/QuickReplyButton.java
+++ b/src/main/java/com/whatsapp/api/domain/templates/QuickReplyButton.java
@@ -12,7 +12,7 @@ public class QuickReplyButton extends Button {
      * Instantiates a new Quick reply button.
      */
     protected QuickReplyButton() {
-
+        super(ButtonType.QUICK_REPLY);
     }
 
     /**
diff --git a/src/main/java/com/whatsapp/api/domain/templates/UrlButton.java b/src/main/java/com/whatsapp/api/domain/templates/UrlButton.java
index c8fa0ac..402e75a 100644
--- a/src/main/java/com/whatsapp/api/domain/templates/UrlButton.java
+++ b/src/main/java/com/whatsapp/api/domain/templates/UrlButton.java
@@ -21,6 +21,7 @@ public class UrlButton extends Button {
      * Instantiates a new Url button.
      */
     protected UrlButton() {
+        super(ButtonType.URL);
     }
 
     /**
"
enigmatis-graphql-java-annotations-183752ce8b9a,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: graphql.annotations.GraphQLDirectivesViaClassDefinitionTest#queryNameWithFalse_directivesProvidedToRegistry_wiringIsActivated
Type: graphql.annotations.processor.exceptions.GraphQLAnnotationsException
Message: graphql.annotations.processor.exceptions.GraphQLAnnotationsException: Could not parse argument value to argument type

Test: graphql.annotations.GraphQLDirectivesViaClassDefinitionTest#queryNameWithNoArgs_directivesProvidedToRegistry_wiringIsActivated
Type: graphql.annotations.processor.exceptions.GraphQLAnnotationsException
Message: graphql.annotations.processor.exceptions.GraphQLAnnotationsException: Could not parse argument value to argument type

Test: graphql.annotations.GraphQLDirectivesViaClassDefinitionTest#queryName_chainedDirectives_wiringIsActivatedInCorrectOrder
Type: graphql.annotations.processor.exceptions.GraphQLAnnotationsException
Message: graphql.annotations.processor.exceptions.GraphQLAnnotationsException: Could not parse argument value to argument type

Test: graphql.annotations.GraphQLDirectivesViaClassDefinitionTest#queryName_directivesProvidedToRegistry_wiringIsActivated
Type: graphql.annotations.processor.exceptions.GraphQLAnnotationsException
Message: graphql.annotations.processor.exceptions.GraphQLAnnotationsException: Could not parse argument value to argument type

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.enigmatis-graphql-java-annotations-183752ce8b9a:msbench-0.0.1,"diff --git a/src/main/java/graphql/annotations/processor/retrievers/fieldBuilders/DirectivesBuilder.java b/src/main/java/graphql/annotations/processor/retrievers/fieldBuilders/DirectivesBuilder.java
index 0082f5f..6fe9965 100644
--- a/src/main/java/graphql/annotations/processor/retrievers/fieldBuilders/DirectivesBuilder.java
+++ b/src/main/java/graphql/annotations/processor/retrievers/fieldBuilders/DirectivesBuilder.java
@@ -14,6 +14,7 @@
  */
 package graphql.annotations.processor.retrievers.fieldBuilders;
 
+import graphql.Scalars;
 import graphql.annotations.annotationTypes.directives.activation.GraphQLDirectives;
 import graphql.annotations.processor.ProcessingElementsContainer;
 import graphql.annotations.processor.exceptions.GraphQLAnnotationsException;
@@ -26,11 +27,14 @@ import graphql.schema.GraphQLType;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;
+import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 
+import static graphql.Assert.assertShouldNeverHappen;
+import static graphql.scalar.CoercingUtil.isNumberIsh;
 import static graphql.schema.GraphQLDirective.newDirective;
 
 
@@ -134,7 +138,22 @@ public class DirectivesBuilder implements Builder<GraphQLDirective[]> {
                     Object argumentValue = methods[finalI].invoke(annotation);
                     Object value;
                     if (graphQLArgument.getType() instanceof GraphQLScalarType) {
-                        value = ((GraphQLScalarType) graphQLArgument.getType()).getCoercing().parseValue(argumentValue);
+//                        value = ((GraphQLScalarType) graphQLArgument.getType()).getCoercing().parseValue(argumentValue);
+
+                        try {
+                            GraphQLScalarType argumentType = (GraphQLScalarType) graphQLArgument.getType();
+                            if ( argumentType.equals( Scalars.GraphQLBoolean ) )
+                            {
+                                value = castToBoolean( argumentValue );
+                            }
+                            else
+                            {
+                                value = argumentType.getCoercing().parseValue( argumentValue );
+                            }
+                            builder.value( value );
+                        } catch (Exception e) {
+                            throw new GraphQLAnnotationsException(COULD_NOT_PARSE_ARGUMENT_VALUE_TO_ARGUMENT_TYPE, e);
+                        }
                     }
                     else{
                         value = argumentValue;
@@ -159,8 +178,17 @@ public class DirectivesBuilder implements Builder<GraphQLDirective[]> {
             if (graphQLArgument.getType() instanceof GraphQLScalarType) {
 
                 try {
-                    Object value = ((GraphQLScalarType) graphQLArgument.getType()).getCoercing().parseValue(argumentValue);
-                    builder.value(value);
+                    Object value;
+                    GraphQLScalarType argumentType = (GraphQLScalarType) graphQLArgument.getType();
+                    if ( argumentType.equals( Scalars.GraphQLBoolean ) )
+                    {
+                        value = castToBoolean( argumentValue );
+                    }
+                    else
+                    {
+                        value = argumentType.getCoercing().parseValue( argumentValue );
+                    }
+                    builder.value( value );
                 } catch (Exception e) {
                     throw new GraphQLAnnotationsException(COULD_NOT_PARSE_ARGUMENT_VALUE_TO_ARGUMENT_TYPE, e);
                 }
@@ -169,4 +197,43 @@ public class DirectivesBuilder implements Builder<GraphQLDirective[]> {
             }
         }));
     }
+
+    private Boolean castToBoolean( Object input )
+    {
+        if ( input instanceof Boolean )
+        {
+            return (Boolean) input;
+        }
+        else if ( input instanceof String )
+        {
+            String lStr = ( (String) input ).toLowerCase();
+            if ( lStr.equals( ""true"" ) )
+            {
+                return true;
+            }
+            if ( lStr.equals( ""false"" ) )
+            {
+                return false;
+            }
+            return null;
+        }
+        else if ( isNumberIsh( input ) )
+        {
+            BigDecimal value;
+            try
+            {
+                value = new BigDecimal( input.toString() );
+            }
+            catch ( NumberFormatException e )
+            {
+                // this should never happen because String is handled above
+                return assertShouldNeverHappen();
+            }
+            return value.compareTo( BigDecimal.ZERO ) != 0;
+        }
+        else
+        {
+            return null;
+        }
+    }
 }
"
ezylang-evalex-7c39c5478a39,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.ezylang.evalex.parser.ShuntingYardExceptionsTest#testTooManyOperands{String}[9]
Type: java.lang.AssertionError
Message: 
Expecting actual throwable to be an instance of:
  com.ezylang.evalex.parser.ParseException
but was:
  java.lang.OutOfMemoryError: Java heap space


Test: com.ezylang.evalex.parser.ShuntingYardExceptionsTest#testTooManyOperands{String}[10]
Type: java.lang.AssertionError
Message: 
Expecting actual throwable to be an instance of:
  com.ezylang.evalex.parser.ParseException
but was:
  java.lang.OutOfMemoryError: Java heap space


Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.ezylang-evalex-7c39c5478a39:msbench-0.0.1,"diff --git a/src/main/java/com/ezylang/evalex/parser/Tokenizer.java b/src/main/java/com/ezylang/evalex/parser/Tokenizer.java
index abb2085..08d2979 100644
--- a/src/main/java/com/ezylang/evalex/parser/Tokenizer.java
+++ b/src/main/java/com/ezylang/evalex/parser/Tokenizer.java
@@ -351,33 +351,54 @@ public class Tokenizer {
   }
 
   private Token parseNumberLiteral() throws ParseException {
-    int tokenStartIndex = currentColumnIndex;
-    StringBuilder tokenValue = new StringBuilder();
     int nextChar = peekNextChar();
     if (currentChar == '0' && (nextChar == 'x' || nextChar == 'X')) {
-      // hexadecimal number, consume ""0x""
+      return parseHexNumberLiteral();
+    } else {
+      return parseDecimalNumberLiteral();
+    }
+  }
+
+  private Token parseDecimalNumberLiteral() throws ParseException {
+    int tokenStartIndex = currentColumnIndex;
+    StringBuilder tokenValue = new StringBuilder();
+
+    int lastChar = -1;
+    boolean scientificNotation = false;
+    while (currentChar != -1 && isAtNumberChar()) {
+      if (currentChar == 'e' || currentChar == 'E') {
+        scientificNotation = true;
+      }
       tokenValue.append((char) currentChar);
+      lastChar = currentChar;
       consumeChar();
+    }
+    // illegal scientific format literal
+    if (scientificNotation
+        && (lastChar == 'e'
+            || lastChar == 'E'
+            || lastChar == '+'
+            || lastChar == '-'
+            || lastChar == '.')) {
+      throw new ParseException(
+          new Token(tokenStartIndex, tokenValue.toString(), TokenType.NUMBER_LITERAL),
+          ""Illegal scientific format"");
+    }
+    return new Token(tokenStartIndex, tokenValue.toString(), TokenType.NUMBER_LITERAL);
+  }
+
+  private Token parseHexNumberLiteral() {
+    int tokenStartIndex = currentColumnIndex;
+    StringBuilder tokenValue = new StringBuilder();
+
+    // hexadecimal number, consume ""0x""
+    tokenValue.append((char) currentChar);
+    consumeChar();
+    tokenValue.append((char) currentChar);
+    consumeChar();
+    while (currentChar != -1 && isAtHexChar()) {
       tokenValue.append((char) currentChar);
       consumeChar();
-      while (currentChar != -1 && isAtHexChar()) {
-        tokenValue.append((char) currentChar);
-        consumeChar();
-      }
-    } else {
-      // decimal number
-      int lastChar = -1;
-      while (currentChar != -1 && isAtNumberChar()) {
-        tokenValue.append((char) currentChar);
-        lastChar = currentChar;
-        consumeChar();
-      }
-      // illegal scientific format literal
-      if (lastChar == 'e' || lastChar == 'E' || lastChar == '+' || lastChar == '-') {
-        throw new ParseException(
-            new Token(tokenStartIndex, tokenValue.toString(), TokenType.NUMBER_LITERAL),
-            ""Illegal scientific format"");
-      }
     }
     return new Token(tokenStartIndex, tokenValue.toString(), TokenType.NUMBER_LITERAL);
   }
@@ -485,7 +506,7 @@ public class Tokenizer {
   private boolean isAtNumberChar() {
     int previousChar = peekPreviousChar();
 
-    if (previousChar == 'e' || previousChar == 'E') {
+    if ((previousChar == 'e' || previousChar == 'E') && currentChar != '.') {
       return Character.isDigit(currentChar) || currentChar == '+' || currentChar == '-';
     }
 
"
fishercoder1534-leetcode-2110c6b023b7,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.fishercoder._235Test#test3
Type: java.lang.AssertionError
Message: java.lang.AssertionError: expected:<TreeNode{val=0, left=TreeNode{val=-1000000000, left=null, right=null}, right=TreeNode{val=1000000000, left=null, right=null}}> but was:<TreeNode{val=-1000000000, left=null, right=null}>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.fishercoder1534-leetcode-2110c6b023b7:msbench-0.0.1,"diff --git a/src/main/java/com/fishercoder/solutions/_235.java b/src/main/java/com/fishercoder/solutions/_235.java
index 97b70d3..d470efd 100644
--- a/src/main/java/com/fishercoder/solutions/_235.java
+++ b/src/main/java/com/fishercoder/solutions/_235.java
@@ -9,10 +9,9 @@ public class _235 {
             if (root == null || p == root || q == root) {
                 return root;
             }
-            if ((root.val - p.val) * (root.val - q.val) > 0) {
-                if (root.val - p.val > 0) {
-                    return lowestCommonAncestor(root.left, p, q);
-                }
+            if (root.val > p.val && root.val > q.val) {
+                return lowestCommonAncestor(root.left, p, q);
+            } else if (root.val < p.val && root.val < q.val) {
                 return lowestCommonAncestor(root.right, p, q);
             }
             return root;
"
gosimplellc-nbvcxz-ee8d5c62f4fb,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: me.gosimple.nbvcxz.NbvcxzTest#testEstimate
Type: java.lang.AssertionError
Message: shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password expected:<360.5676147181065> but was:<132.95506049872384>

Test: me.gosimple.nbvcxz.NbvcxzTest#testEstimateConcurrently
Type: java.lang.AssertionError
Message: shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password_shortened_password expected:<360.5676147181065> but was:<132.95506049872384>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.gosimplellc-nbvcxz-ee8d5c62f4fb:msbench-0.0.1,"diff --git a/src/main/java/me/gosimple/nbvcxz/matching/DictionaryMatcher.java b/src/main/java/me/gosimple/nbvcxz/matching/DictionaryMatcher.java
index fab3689..17daaaa 100644
--- a/src/main/java/me/gosimple/nbvcxz/matching/DictionaryMatcher.java
+++ b/src/main/java/me/gosimple/nbvcxz/matching/DictionaryMatcher.java
@@ -298,27 +298,29 @@ public final class DictionaryMatcher implements PasswordMatcher
                     }
 
                     // Only do unleet if it's different than the regular lower.
-                    final List<String> unleet_list = translateLeet(configuration, lower_part);
-                    for (final String unleet_part : unleet_list)
+                    if (dictionary.getMaxLength() > split_password.length())
                     {
-                        final Integer unleet_rank = dictionary.getDictonary().get(unleet_part);
-                        if (unleet_rank != null)
+                        final List<String> unleet_list = translateLeet(configuration, lower_part);
+                        for (final String unleet_part : unleet_list)
                         {
-                            final List<Character[]> subs = getLeetSub(lower_part, unleet_part);
-                            matches.add(new DictionaryMatch(split_password, configuration, start, end - 1, unleet_part, unleet_rank, subs, dictionary.isExclusion(), false, dictionary.getDictionaryName(), 0));
-                            continue;
-                        }
-
-                        // Only do reversed if it's different than unleet.
-                        final String reversed_unleet_part = new StringBuilder(unleet_part).reverse().toString();
-                        {
-                            final Integer reversed_unleet_rank = dictionary.getDictonary().get(reversed_unleet_part);
-                            if (reversed_unleet_rank != null)
+                            final Integer unleet_rank = dictionary.getDictonary().get(unleet_part);
+                            if (unleet_rank != null)
                             {
-                                final List<Character[]> subs = getLeetSub(reversed_part, reversed_unleet_part);
-                                matches.add(new DictionaryMatch(split_password, configuration, start, end - 1, reversed_unleet_part, reversed_unleet_rank, subs, dictionary.isExclusion(), true, dictionary.getDictionaryName(), 0));
+                                final List<Character[]> subs = getLeetSub(lower_part, unleet_part);
+                                matches.add(new DictionaryMatch(split_password, configuration, start, end - 1, unleet_part, unleet_rank, subs, dictionary.isExclusion(), false, dictionary.getDictionaryName(), 0));
                                 continue;
                             }
+
+                            // Only do reversed if it's different than unleet.
+                            final String reversed_unleet_part = new StringBuilder(unleet_part).reverse().toString();
+                            {
+                                final Integer reversed_unleet_rank = dictionary.getDictonary().get(reversed_unleet_part);
+                                if (reversed_unleet_rank != null)
+                                {
+                                    final List<Character[]> subs = getLeetSub(reversed_part, reversed_unleet_part);
+                                    matches.add(new DictionaryMatch(split_password, configuration, start, end - 1, reversed_unleet_part, reversed_unleet_rank, subs, dictionary.isExclusion(), true, dictionary.getDictionaryName(), 0));
+                                }
+                            }
                         }
                     }
 
diff --git a/src/main/java/me/gosimple/nbvcxz/resources/ConfigurationBuilder.java b/src/main/java/me/gosimple/nbvcxz/resources/ConfigurationBuilder.java
index 4fd9616..c76eea0 100644
--- a/src/main/java/me/gosimple/nbvcxz/resources/ConfigurationBuilder.java
+++ b/src/main/java/me/gosimple/nbvcxz/resources/ConfigurationBuilder.java
@@ -204,11 +204,12 @@ public class ConfigurationBuilder
     }
 
     /**
-     * @return The default value for max length is 72.
+     * @return The default value for max length is 256.
+     * This should match the exact length your algorithm is limited to (72 for most bcrypt implementations).
      */
     public static int getDefaultMaxLength()
     {
-        return 72;
+        return 256;
     }
 
     /**
@@ -349,6 +350,10 @@ public class ConfigurationBuilder
      * Information will be available in the Result if the password was longer
      * than maxLength.
      *
+     * This should match the exact length your algorithm is limited to (72 for most bcrypt implementations).
+     * If you arbitrarily limit the input for passwords, ensure the passed in value is either already truncated to
+     * the correct length, or this value is set to the same length you will truncate to.
+     *
      * @param maxLength Value for maxLength (should be a positive value)
      * @return Builder
      */
diff --git a/src/main/java/me/gosimple/nbvcxz/resources/Dictionary.java b/src/main/java/me/gosimple/nbvcxz/resources/Dictionary.java
index c84b6bf..2e44f04 100644
--- a/src/main/java/me/gosimple/nbvcxz/resources/Dictionary.java
+++ b/src/main/java/me/gosimple/nbvcxz/resources/Dictionary.java
@@ -17,6 +17,7 @@ public class Dictionary
     private final ArrayList<String> sorted_dictionary;
     private final Map<Integer, Integer> sorted_dictionary_length_lookup;
     private final boolean exclusion;
+    private final int max_length;
 
 
     /**
@@ -57,7 +58,7 @@ public class Dictionary
                 sorted_dictionary_length_lookup.put(key.length(), i);
             }
         }
-
+        int i_max_length = 0;
         for (int i = 0; i < sorted_dictionary_length_lookup.size(); i++)
         {
             if (!sorted_dictionary_length_lookup.containsKey(i))
@@ -69,7 +70,9 @@ public class Dictionary
                 }
                 sorted_dictionary_length_lookup.put(i, sorted_dictionary_length_lookup.get(next_key));
             }
+            i_max_length = i;
         }
+        max_length = i_max_length;
     }
 
     /**
@@ -123,4 +126,12 @@ public class Dictionary
     {
         return this.dictionary_name;
     }
+
+    /**
+     * The longest length of an entry we should check with this dictionary
+     * @return the longest value this dictionary contains
+     */
+    public int getMaxLength() {
+        return max_length;
+    }
 }
"
ibm-jsonata4java-1485a41ccf50,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.api.jsonata4java.test.expressions.OpOrderByTest#testOrderedNumeric
Type: java.lang.AssertionError
Message: expected:<[{""id"":1,""content"":""1""},{""id"":2,""content"":""1""},{""id"":2,""content"":""2""}]> but was:<[{""id"":2,""content"":""1""},{""id"":1,""content"":""1""},{""id"":2,""content"":""2""}]>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.ibm-jsonata4java-1485a41ccf50:msbench-0.0.1,"diff --git a/src/main/java/com/api/jsonata4java/expressions/OrderByOperator.java b/src/main/java/com/api/jsonata4java/expressions/OrderByOperator.java
index e8f199a..829eaf0 100644
--- a/src/main/java/com/api/jsonata4java/expressions/OrderByOperator.java
+++ b/src/main/java/com/api/jsonata4java/expressions/OrderByOperator.java
@@ -13,6 +13,8 @@ import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.TextNode;
+import com.fasterxml.jackson.databind.node.NumericNode;
+import com.fasterxml.jackson.databind.node.BooleanNode;
 
 public class OrderByOperator {
 
@@ -35,14 +37,29 @@ public class OrderByOperator {
                 for (final OrderByField sortField : sortFields) {
                     JsonNode n1 = o1.get(sortField.name);
                     JsonNode n2 = o2.get(sortField.name);
-                    if (n1 != null && n1 instanceof TextNode
-                        && n2 != null && n2 instanceof TextNode) {
-                        final int comp = ((TextNode) n1).asText().compareTo(((TextNode) n2).asText());
-                        if (comp != 0) {
-                            return sortField.order == OrderByOrder.DESC ? comp * (-1) : comp;
+                    if (n1 != null && n2 != null) {
+                        if (n1 instanceof TextNode && n2 instanceof TextNode) {
+                            final int comp = ((TextNode) n1).asText().compareTo(((TextNode) n2).asText());
+                            if (comp != 0) {
+                                return sortField.order == OrderByOrder.DESC ? comp * -1 : comp;
+                            }
                         }
-                    }
-                }
+                        if (n1 instanceof NumericNode && n2 instanceof NumericNode) {
+                            final int comp = (int) Double.compare(((NumericNode) n1).asDouble(), ((NumericNode) n2).asDouble());
+                            if (comp != 0) {
+                                return sortField.order == OrderByOrder.DESC ? comp * -1 : comp;
+                            }
+
+                        }
+                        if (n1 instanceof BooleanNode && n2 instanceof BooleanNode) {
+                            final int comp = Boolean.compare(((BooleanNode) n1).asBoolean(), ((BooleanNode) n2).asBoolean());
+                            if (comp != 0) {
+                                return sortField.order == OrderByOrder.DESC ? comp * -1 : comp;
+                            }
+
+                         }
+                     }
+				}
                 return 0;
             }
         });
"
lmax-exchange-simple-dsl-7d81cd9e2951,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.lmax.simpledsl.internal.DslParamsParserTest#shouldBeAbleToExtractMultipleValuesForOneParameterUsingTheACustomSeparatorAndIgnoreRegex()
Type: java.lang.IllegalArgumentException
Message: java.lang.IllegalArgumentException: Missing value for parameter: b

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.lmax-exchange-simple-dsl-7d81cd9e2951:msbench-0.0.1,"diff --git a/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java b/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
index 45fdbb9..b9af1f9 100644
--- a/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
+++ b/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
@@ -29,6 +29,7 @@ import java.util.Deque;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 /**
  * Parser for transforming a specification of {@link DslArg DslArgs} and a set of provided {@link String} values into
@@ -215,7 +216,7 @@ public class DslParamsParser
         {
             if (arg.isAllowMultipleValues())
             {
-                final String[] vals = value.split(arg.getMultipleValueSeparator());
+                final String[] vals = value.split(Pattern.quote(arg.getMultipleValueSeparator()));
                 for (final String singleValue : vals)
                 {
                     addSingleValue(arg, singleValue.trim(), values);
"
lmax-exchange-simple-dsl-81182e58bd80,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.lmax.simpledsl.internal.DslParamsParserTest#shouldBeAbleToSpecifyMultipleValuesForParamInGroupUsingTheDefaultSeparator()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <2> but was: <1>

Test: com.lmax.simpledsl.internal.DslParamsParserTest#shouldBeAbleToSpecifyMultipleValuesForParamInGroupUsingACustomSeparator()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <2> but was: <1>

Test: com.lmax.simpledsl.internal.DslParamsParserTest#shouldMatchAllowedValuesCaseInsensitivelyAndReturnValuesUsingTheCaseProvidedInTheDSLWithinRepeatingGroups()
Type: org.opentest4j.AssertionFailedError
Message: org.opentest4j.AssertionFailedError: expected: <A> but was: <a>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.lmax-exchange-simple-dsl-81182e58bd80:msbench-0.0.1,"diff --git a/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java b/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
index f8a2631..45fdbb9 100644
--- a/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
+++ b/src/main/java/com/lmax/simpledsl/internal/DslParamsParser.java
@@ -312,8 +312,7 @@ public class DslParamsParser
                     break;
                 }
 
-                checkValidValue(arg, argument.value);
-                argValues.add(argument.value);
+                SimpleArgumentProcessor.addValue(arg, argument.value, argValues);
                 arguments.pollFirst();
             }
 
"
moderocky-byteskript-1dce2997df7f,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.byteskript.skript.test.SyntaxTreeTest#testRecompile
Type: java.lang.AssertionError
Message: ""  --test  MemberDictionary():  EffectImportType(ExprType(java/util/Objects))  EffectImportFunction(StringLiteral(""equals""), ExprType(java/util/Objects))  EffectUseLibrary(unsafe)  MemberFunction(a, b):  EntryTriggerSection():   EffectPrint(ExprAdd(ExprVariable(a), ExprVariable(b)))   EffectLoopTimesSection(IntegerLiteral(5)):    EffectPrint(StringLiteral(""hello""))  MemberFunctionNoArgs():  EntryReturn(string)  EntryTriggerSection():   EffectPrint(StringLiteral(""hello""))  EventLoad():  EntryTriggerSection():   EffectPrint(StringLiteral(""Foo""))""

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.moderocky-byteskript-1dce2997df7f:msbench-0.0.1,"diff --git a/src/main/java/org/byteskript/skript/compiler/DebugSkriptCompiler.java b/src/main/java/org/byteskript/skript/compiler/DebugSkriptCompiler.java
index fec865f..2864b22 100644
--- a/src/main/java/org/byteskript/skript/compiler/DebugSkriptCompiler.java
+++ b/src/main/java/org/byteskript/skript/compiler/DebugSkriptCompiler.java
@@ -41,15 +41,15 @@ public class DebugSkriptCompiler extends SimpleSkriptCompiler {
     public PostCompileClass[] compile(InputStream stream, Type path) {
         this.stream.print(""\n"");
         this.stream.print(""--"" + path.internalName());
-        this.stream.print(""\n"");
+        this.stream.print(""\n\n"");
         return super.compile(stream, path);
     }
     
     @Override
     public PostCompileClass[] compile(String source, Type path) {
-        this.stream.print(""\n\n"");
-        this.stream.print(""--"" + path.internalName());
         this.stream.print(""\n"");
+        this.stream.print(""--"" + path.internalName());
+        this.stream.print(""\n\n"");
         return super.compile(source, path);
     }
     
@@ -59,9 +59,8 @@ public class DebugSkriptCompiler extends SimpleSkriptCompiler {
     }
     
     protected void debug(ElementTree tree, FileContext context) {
-        this.stream.print(""\n"");
         for (int i = 0; i < context.lineIndent; i++) this.stream.print(""\t"");
-        this.stream.print(tree.toString(context));
+        this.stream.println(tree.toString(context));
     }
     
 }
"
netflix-frigga-126b52a55863,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.netflix.frigga.ami.AppVersionTest#should parse appName-0.1-h150.9b3bc237~focal to appName, 0.1, 9b3bc237, 150, null
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException: Cannot get property 'packageName' on null object

Test: com.netflix.frigga.ami.AppVersionTest#should parse appName-0.1-h150.9b3bc237~focal/mybuild/150 to appName, 0.1, 9b3bc237, 150, mybuild
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException: Cannot get property 'packageName' on null object

Test: com.netflix.frigga.ami.AppVersionTest#should parse appName-0.1~dev.1-h150.9b3bc237~focal to appName, 0.1~dev.1, 9b3bc237, 150, null
Type: java.lang.NullPointerException
Message: java.lang.NullPointerException: Cannot get property 'packageName' on null object

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.netflix-frigga-126b52a55863:msbench-0.0.1,"diff --git a/src/main/java/com/netflix/frigga/ami/AppVersion.java b/src/main/java/com/netflix/frigga/ami/AppVersion.java
index c712415..fc82d53 100644
--- a/src/main/java/com/netflix/frigga/ami/AppVersion.java
+++ b/src/main/java/com/netflix/frigga/ami/AppVersion.java
@@ -33,7 +33,7 @@ public class AppVersion implements Comparable<AppVersion> {
      */
     private static final Pattern APP_VERSION_PATTERN = Pattern.compile(
             ""(["" + NameConstants.NAME_HYPHEN_CHARS
-            + ""]+)-([0-9.a-zA-Z~]+)-(\\w+)(?:[.](\\w+))?(?:\\/(["" + NameConstants.NAME_HYPHEN_CHARS + ""]+)\\/([0-9]+))?"");
+            + ""]+)-([0-9.a-zA-Z~]+)-(\\w+)(?:[.](\\w+))?(?:~["" + NameConstants.NAME_HYPHEN_CHARS + ""]+)?(?:\\/(["" + NameConstants.NAME_HYPHEN_CHARS + ""]+)\\/([0-9]+))?"");
 
 
     private String packageName;
"
thealgorithms-java-4f1514980495,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.thealgorithms.maths.FindMinTest#testFindMinThrowsExceptionForEmptyInput
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <java.lang.IllegalArgumentException> but was: <java.lang.ArrayIndexOutOfBoundsException>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.thealgorithms-java-4f1514980495:msbench-0.0.1,"diff --git a/src/main/java/com/thealgorithms/maths/FindMin.java b/src/main/java/com/thealgorithms/maths/FindMin.java
index e3be09e..7764c1c 100644
--- a/src/main/java/com/thealgorithms/maths/FindMin.java
+++ b/src/main/java/com/thealgorithms/maths/FindMin.java
@@ -24,16 +24,20 @@ public class FindMin {
     }
 
     /**
-     * Find the minimum number of an array of numbers.
+     * @brief finds the minimum value stored in the input array
      *
-     * @param array the array contains element
-     * @return min value
+     * @param array the input array
+     * @exception IllegalArgumentException input array is empty
+     * @return the mimum value stored in the input array
      */
     public static int findMin(int[] array) {
-        int min = array[0];
-        for (int i = 1; i < array.length; ++i) {
-            if (array[i] < min) {
-                min = array[i];
+        if (array.length == 0) {
+            throw new IllegalArgumentException(""array must be non-empty."");
+        }
+        int min = Integer.MAX_VALUE;
+        for (final var value : array) {
+            if (value < min) {
+                min = value;
             }
         }
         return min;
"
thealgorithms-java-96c1a96647c9,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.thealgorithms.maths.FindMaxTest#testFindMaxThrowsExceptionForEmptyInput
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <java.lang.IllegalArgumentException> but was: <java.lang.ArrayIndexOutOfBoundsException>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.thealgorithms-java-96c1a96647c9:msbench-0.0.1,"diff --git a/src/main/java/com/thealgorithms/maths/FindMax.java b/src/main/java/com/thealgorithms/maths/FindMax.java
index a7be869..559424f 100644
--- a/src/main/java/com/thealgorithms/maths/FindMax.java
+++ b/src/main/java/com/thealgorithms/maths/FindMax.java
@@ -24,16 +24,20 @@ public class FindMax {
     }
 
     /**
-     * find max of array
+     * @brief finds the maximum value stored in the input array
      *
-     * @param array the array contains element
-     * @return max value of given array
+     * @param array the input array
+     * @exception IllegalArgumentException input array is empty
+     * @return the maximum value stored in the input array
      */
     public static int findMax(int[] array) {
-        int max = array[0];
-        for (int i = 1; i < array.length; ++i) {
-            if (array[i] > max) {
-                max = array[i];
+        if (array.length == 0) {
+            throw new IllegalArgumentException(""array must be non-empty."");
+        }
+        int max = Integer.MIN_VALUE;
+        for (final var value : array) {
+            if (value > max) {
+                max = value;
             }
         }
         return max;
"
thealgorithms-java-e5c7a08874a6,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.thealgorithms.others.StackPostfixNotationTest#testIfEvaluateThrowsExceptionForInputWithTooFewArgsA
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <java.lang.IllegalArgumentException> but was: <java.util.EmptyStackException>

Test: com.thealgorithms.others.StackPostfixNotationTest#testIfEvaluateThrowsExceptionForInputWithTooFewArgsB
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <java.lang.IllegalArgumentException> but was: <java.util.EmptyStackException>

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.thealgorithms-java-e5c7a08874a6:msbench-0.0.1,"diff --git a/src/main/java/com/thealgorithms/others/StackPostfixNotation.java b/src/main/java/com/thealgorithms/others/StackPostfixNotation.java
index c6d395c..f859151 100644
--- a/src/main/java/com/thealgorithms/others/StackPostfixNotation.java
+++ b/src/main/java/com/thealgorithms/others/StackPostfixNotation.java
@@ -16,6 +16,9 @@ public final class StackPostfixNotation {
             if (tokens.hasNextInt()) {
                 s.push(tokens.nextInt()); // If int then push to stack
             } else { // else pop top two values and perform the operation
+                if (s.size() < 2) {
+                    throw new IllegalArgumentException(""exp is not a proper postfix expression (too few arguments)."");
+                }
                 int num2 = s.pop();
                 int num1 = s.pop();
                 String op = tokens.next();
"
thealgorithms-java-a3a2d845d563,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: com.thealgorithms.maths.ArmstrongTest#testIsArmstrong
Type: org.opentest4j.AssertionFailedError
Message: 
Expecting value to be true but was false

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.thealgorithms-java-a3a2d845d563:msbench-0.0.1,"diff --git a/src/main/java/com/thealgorithms/maths/Armstrong.java b/src/main/java/com/thealgorithms/maths/Armstrong.java
index dda8288..526b31c 100644
--- a/src/main/java/com/thealgorithms/maths/Armstrong.java
+++ b/src/main/java/com/thealgorithms/maths/Armstrong.java
@@ -1,29 +1,36 @@
 package com.thealgorithms.maths;
 
 /**
- * An Armstrong number is equal to the sum of the cubes of its digits. For
- * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An
- * Armstrong number is often called Narcissistic number.
+ * This class checks whether a given number is an Armstrong number or not.
+ * An Armstrong number is a number that is equal to the sum of its own digits,
+ * each raised to the power of the number of digits.
  *
- * @author Vivek
+ * For example, 370 is an Armstrong number because 3^3 + 7^3 + 0^3 = 370.
+ * 1634 is an Armstrong number because 1^4 + 6^4 + 3^4 + 4^4 = 1634.
+ * An Armstrong number is often called a Narcissistic number.
+ *
+ * @author satyabarghav
  */
 public class Armstrong {
 
     /**
-     * Checks whether a given number is an armstrong number or not.
+     * Checks whether a given number is an Armstrong number or not.
      *
-     * @param number number to check
-     * @return {@code true} if given number is armstrong number, {@code false}
-     * otherwise
+     * @param number the number to check
+     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise
      */
     public boolean isArmstrong(int number) {
         long sum = 0;
-        long number2 = number;
-        while (number2 > 0) {
-            long mod = number2 % 10;
-            sum += Math.pow(mod, 3);
-            number2 /= 10;
+        String temp = Integer.toString(number); // Convert the given number to a string
+        int power = temp.length(); // Extract the length of the number (number of digits)
+        long originalNumber = number;
+
+        while (originalNumber > 0) {
+            long digit = originalNumber % 10;
+            sum += Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.
+            originalNumber /= 10;
         }
+
         return sum == number;
     }
 }
"
xtremexp-ut4x-converter-e719841eb260,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.xtx.ut4converter.t3d.T3DZoneInfoTest#testZoneInfoConversionUT2004ToUT4
Type: org.opentest4j.AssertionFailedError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.xtremexp-ut4x-converter-e719841eb260:msbench-0.0.1,"diff --git a/src/main/java/org/xtx/ut4converter/t3d/T3DActor.java b/src/main/java/org/xtx/ut4converter/t3d/T3DActor.java
index faed09b..e7fcd71 100644
--- a/src/main/java/org/xtx/ut4converter/t3d/T3DActor.java
+++ b/src/main/java/org/xtx/ut4converter/t3d/T3DActor.java
@@ -779,7 +779,17 @@ public abstract class T3DActor extends T3DObject {
 		this.convert();
 		this.scale(scaleFactor);
 
-		return ""Begin Map\nBegin Level\n"" + toT3d() + ""End Level\nEnd Map"";
+		String convT3d = toT3d();
+
+		if (convT3d == null) {
+			convT3d = """";
+
+			for (T3DActor repActor : this.children) {
+				convT3d += repActor.toT3d();
+			}
+		}
+
+		return ""Begin Map\nBegin Level\n"" + convT3d + ""End Level\nEnd Map"";
 	}
 
 	protected void addComponent(final Component... components){
"
xtremexp-ut4x-converter-e16bad18b562,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: org.xtx.ut4converter.t3d.T3DDispatcherTest#testDispatcherConversionTest
Type: org.opentest4j.AssertionFailedError
Message: None

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.xtremexp-ut4x-converter-e16bad18b562:msbench-0.0.1,"diff --git a/src/main/java/org/xtx/ut4converter/t3d/T3DSimpleProperty.java b/src/main/java/org/xtx/ut4converter/t3d/T3DSimpleProperty.java
index f10bb9c..b87d63b 100644
--- a/src/main/java/org/xtx/ut4converter/t3d/T3DSimpleProperty.java
+++ b/src/main/java/org/xtx/ut4converter/t3d/T3DSimpleProperty.java
@@ -5,8 +5,7 @@ import org.xtx.ut4converter.geom.Rotator;
 import org.xtx.ut4converter.ucore.UPackageRessource;
 
 import javax.vecmath.Vector3d;
-import java.util.LinkedList;
-import java.util.List;
+import java.util.*;
 
 /**
  *
@@ -42,7 +41,8 @@ public class T3DSimpleProperty {
     private boolean scalable;
 
     /**
-     * Value
+     * Value.
+     * Is a map of [Index, Value] if isList is true
      */
     private Object propertyValue;
 
@@ -102,7 +102,7 @@ public class T3DSimpleProperty {
 
         if (this.isList) {
             if (this.propertyValue == null) {
-                this.propertyValue = new LinkedList<>();
+                this.propertyValue = new HashMap<>();
             }
             hasLineProp = line.toLowerCase().startsWith(this.propertyName.toLowerCase() + ""("");
         } else {
@@ -145,9 +145,9 @@ public class T3DSimpleProperty {
         }
 
         if (value != null) {
-            if (this.propertyValue instanceof List) {
-                final List<Object> theList = (List<Object>) this.propertyValue;
-                theList.add(value);
+            if (this.propertyValue instanceof HashMap hashMap) {
+                int index = T3DUtils.parseArrayIndex(line);
+                hashMap.put(index, value);
             } else {
                 this.propertyValue = value;
             }
@@ -161,15 +161,11 @@ public class T3DSimpleProperty {
 
         if (this.propertyValue != null) {
 
-            if (this.propertyValue instanceof List) {
-                final List<Object> values = (List<Object>) this.propertyValue;
+            if (this.propertyValue instanceof HashMap hashMap) {
 
-                int idx = 0;
-
-                for (final Object value : values) {
-                    sbf.append(""\t\t"").append(propertyNameConverted).append(""("").append(idx).append("")="");
-                    writeValueProperty(sbf, value);
-                    idx++;
+                for (Object index : hashMap.keySet()) {
+                    sbf.append(""\t\t"").append(propertyNameConverted).append(""("").append(index).append("")="");
+                    writeValueProperty(sbf, hashMap.get(index));
                 }
             } else {
                 sbf.append(""\t\t"").append(propertyNameConverted).append(""="");
diff --git a/src/main/java/org/xtx/ut4converter/t3d/T3DUtils.java b/src/main/java/org/xtx/ut4converter/t3d/T3DUtils.java
index f5a2685..a6d17ef 100644
--- a/src/main/java/org/xtx/ut4converter/t3d/T3DUtils.java
+++ b/src/main/java/org/xtx/ut4converter/t3d/T3DUtils.java
@@ -435,6 +435,17 @@ public class T3DUtils {
 	}
 
 	/**
+	 * Skins(2)=Texture'Mission_08T.Doors.MetlDoor_U08G394'
+	 * -> returns 2
+	 *
+	 * @param line Line to be parsed
+	 * @return Index
+	 */
+	public static int parseArrayIndex(String line){
+		return Integer.parseInt(line.split(""="")[0].split(""\\("")[1].replaceAll(""\\)"", """"));
+	}
+
+	/**
 	 * E.G: 'Skins(2)=Texture'Mission_08T.Doors.MetlDoor_U08G394')
 	 *
 	 * @param line Line to parse
"
yehiafarghaly-database-engine-8314bfdec0aa,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: app.DBAppTest#testDeleteFromTable_InvalidDataType_ShouldFailDelete
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testUpdateTable_InvalidPrimaryKey_ShouldFailUpdate
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testDeleteFromTable_InvalidColumnName_ShouldFailDelete
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testInsertIntoTable_RepeatedPrimaryKey_ShouldFailInsert
Type: java.lang.AssertionError
Message: Expected DBAppException but no exception was thrown

Test: app.DBAppTest#testUpdateTable_ExtraInput_ShouldFailUpdate
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testInsertIntoTable_InvalidDataType_ShouldFailInsertion
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testInsertIntoTable_InvalidTableName_ShouldFailInsertion
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Test: app.DBAppTest#testUpdateTable_MoreThanMax_ShouldFailUpdate
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.yehiafarghaly-database-engine-8314bfdec0aa:msbench-0.0.1,"diff --git a/src/main/java/app/DBApp.java b/src/main/java/app/DBApp.java
index 61482c9..f42ee64 100644
--- a/src/main/java/app/DBApp.java
+++ b/src/main/java/app/DBApp.java
@@ -72,7 +72,7 @@ public class DBApp implements IDatabase {
 	 * 
 	 * @throws DBAppException If the table name is invalid or if the table already
 	 *                        exists.
-	 * @throws ParseException 
+	 * @throws ParseException
 	 * @throws IOException    If an error occurs while creating the table files.
 	 */
 	@Override
@@ -80,14 +80,13 @@ public class DBApp implements IDatabase {
 			Hashtable<String, String> htblColNameType, Hashtable<String, String> htblColNameMin,
 			Hashtable<String, String> htblColNameMax) throws DBAppException {
 
-			Validator.validateTableCreation(myTables, strTableName,
-		 strClusteringKeyColumn, htblColNameType, htblColNameMin,
-		 htblColNameMax);
+		Validator.validateTableCreation(myTables, strTableName, strClusteringKeyColumn, htblColNameType, htblColNameMin,
+				htblColNameMax);
 
 		Table table = new Table(strTableName, strClusteringKeyColumn, htblColNameType, htblColNameMin, htblColNameMax);
 		myTables.add(strTableName);
 		writer.write(table);
-	
+
 		try {
 			table.createTableFiles();
 			Serializer.serializeTable(table);
@@ -176,22 +175,22 @@ public class DBApp implements IDatabase {
 	private void takeAction(Action action, String strTableName, Hashtable<String, Object> htblColNameValue)
 			throws DBAppException {
 		try {
+			Validator.validateTable(strTableName, myTables);
 			Table table = Serializer.deserializeTable(strTableName);
 			if (action == Action.INSERT) {
-				Validator.validateInsertionInput(table, htblColNameValue, myTables); 
+				Validator.validateInsertionInput(table, htblColNameValue, myTables);
 				table.insertTuple(htblColNameValue);
 			} else if (action == Action.DELETE) {
-				Validator.validateDeletionInput(table, htblColNameValue, myTables); 
+				Validator.validateDeletionInput(table, htblColNameValue, myTables);
 				table.deleteTuples(htblColNameValue);
 			} else {
 				castClusteringKeyType(table);
 				htblColNameValue.put(table.getPKColumn(), clusteringKey);
-				Validator.validateUpdateInput(table, htblColNameValue, myTables); 
+				Validator.validateUpdateInput(table, htblColNameValue, myTables);
 				table.updateRecordsInTaple(clusteringKey, htblColNameValue);
 			}
 			Serializer.serializeTable(table);
-		} catch (Exception e) {
-			e.printStackTrace();
+		} catch (CsvValidationException | ClassNotFoundException | IOException | ParseException e1) {
 		}
 	}
 
@@ -202,4 +201,23 @@ public class DBApp implements IDatabase {
 	public Iterator selectFromTable(SQLTerm[] arrSQLTerms, String[] strarrOperators) throws DBAppException {
 		return new Selector(arrSQLTerms, strarrOperators).getResult();
 	}
+
+	public static void main(String[] args) throws DBAppException {
+		DBApp engine = new DBApp();
+		engine.init();
+		Hashtable<String, String> htblColNameType = new Hashtable<>();
+		htblColNameType.put(""course_id"", ""java.lang.String"");
+		htblColNameType.put(""courseName"", ""java.lang.String"");
+
+		Hashtable<String, String> htblColNameMin = new Hashtable<>();
+		htblColNameMin.put(""course_id"", ""9999"");
+		htblColNameMin.put(""courseName"", ""AAAAA"");
+
+		Hashtable<String, String> htblColNameMax = new Hashtable<>();
+		htblColNameMax.put(""course_id"", ""0000"");
+		htblColNameMax.put(""courseName"", ""zzzz"");
+
+		engine.createTable(""newTable"", ""course_id"", htblColNameType, htblColNameMin, htblColNameMax);
+
+	}
 }
diff --git a/src/main/java/util/validation/Validator.java b/src/main/java/util/validation/Validator.java
index 515a390..f9504eb 100644
--- a/src/main/java/util/validation/Validator.java
+++ b/src/main/java/util/validation/Validator.java
@@ -25,10 +25,10 @@ public class Validator {
 			String strClusteringKeyColumn, Hashtable<String, String> htblColNameType,
 			Hashtable<String, String> htblColNameMin, Hashtable<String, String> htblColNameMax) throws DBAppException {
 
-		if (validTable(strTableName, appTables)) {
+		if (isValidTable(strTableName, appTables)) {
 			throw new DBAppException(Constants.ERROR_MESSAGE_REPEATED_TABLE_NAME);
 
-		} else if (!validClusteringKey(strClusteringKeyColumn, htblColNameMax)) {
+		} else if (!validClusteringKey(strClusteringKeyColumn, htblColNameType)) {
 			throw new DBAppException(Constants.ERROR_MESSAGE_INVALID_CLUSTERINGKEY);
 
 		} else if (!validDataTypes(htblColNameType)) {
@@ -41,6 +41,12 @@ public class Validator {
 		}
 	}
 
+	public static void validateTable(String tableName, HashSet<String> myTables) throws DBAppException {
+		if (!isValidTable(tableName, myTables)) {
+			throw new DBAppException(Constants.ERROR_MESSAGE_TABLE_NAME);
+		}
+	}
+
 	private static boolean validClusteringKey(String strClusteringKeyColumn,
 			Hashtable<String, String> htblColNameType) {
 		if (strClusteringKeyColumn != null && htblColNameType.containsKey(strClusteringKeyColumn)) {
@@ -87,9 +93,6 @@ public class Validator {
 	public static void validateInsertionInput(Table table, Hashtable<String, Object> htblColNameValue,
 			HashSet<String> appTables)
 			throws DBAppException, CsvValidationException, ClassNotFoundException, IOException, ParseException {
-
-		if (!validTable(table.getName(), appTables))
-			throw new DBAppException(Constants.ERROR_MESSAGE_TABLE_NAME);
 		if (!validTuple(table, htblColNameValue))
 			throw new DBAppException(Constants.ERROR_MESSAGE_TUPLE_DATA);
 	}
@@ -97,22 +100,18 @@ public class Validator {
 	public static void validateDeletionInput(Table table, Hashtable<String, Object> htblColNameValue,
 			HashSet<String> appTables) throws DBAppException {
 		getTableInfo(table);
-		if (!validTable(table.getName(), appTables))
-			throw new DBAppException(Constants.ERROR_MESSAGE_TABLE_NAME);
-		else if (!validTupleDelete(htblColNameValue))
+		if (!validTupleDelete(htblColNameValue))
 			throw new DBAppException(Constants.ERROR_MESSAGE_TUPLE_DATA);
 	}
 
 	public static void validateUpdateInput(Table table, Hashtable<String, Object> htblColNameValue,
 			HashSet<String> appTables)
 			throws DBAppException, CsvValidationException, ClassNotFoundException, IOException, ParseException {
-		if (!validTable(table.getName(), appTables))
-			throw new DBAppException(Constants.ERROR_MESSAGE_TABLE_NAME);
 		if (!validTupleUpdate(table, htblColNameValue))
 			throw new DBAppException(Constants.ERROR_MESSAGE_TUPLE_DATA);
 	}
 
-	private static boolean validTable(String tableName, HashSet<String> myTables) {
+	private static boolean isValidTable(String tableName, HashSet<String> myTables) {
 		return myTables.contains(tableName);
 	}
 
@@ -210,16 +209,15 @@ public class Validator {
 	private static boolean isTheSameDataType(Hashtable<String, Object> tuple) {
 		for (int i = 0; i < columns.length; i++) {
 			if (!sameSuffix(tuple, columns[i], i))
-				
+
 				return false;
 		}
 		return true;
 	}
-	
+
 	private static boolean validTupleDelete(Hashtable<String, Object> htblColNameValue) {
-		if (!isTheSameDataTypeMissingCol(htblColNameValue) ||
-			!checkTupleSize(htblColNameValue) ||
-		    !containsAllColumns(htblColNameValue))
+		if (!isTheSameDataTypeMissingCol(htblColNameValue) || !checkTupleSize(htblColNameValue)
+				|| !containsAllColumns(htblColNameValue))
 			return false;
 		return true;
 	}
@@ -227,7 +225,7 @@ public class Validator {
 	private static boolean checkTupleSize(Hashtable<String, Object> tuple) {
 		return tuple.size() <= columns.length;
 	}
-	
+
 	private static boolean isTheSameDataTypeMissingCol(Hashtable<String, Object> tuple) {
 		int index = 0;
 		for (String column : columns) {
@@ -262,7 +260,7 @@ public class Validator {
 		int index = 0;
 		for (String s : columns) {
 			if (tuple.containsKey(s)) {
-				parseMinMax(tuple, s, index);
+				return parseMinMax(tuple, s, index);
 			}
 			index++;
 		}
"
yehiafarghaly-database-engine-c5f961f27373,"The test suite has uncovered a bug in the code. Below are the failing tests that pinpoint the incorrect behavior. Each test failure provides clues about what's wrong and how the code should behave.

Current test failures:

Test: app.DBAppTest#testCreateTable_InconsistentColumns_ShouldFailCreation
Type: org.opentest4j.AssertionFailedError
Message: Unexpected exception type thrown, expected: <exceptions.DBAppException> but was: <java.lang.NullPointerException>

Test: app.DBAppTest#testUpdateTable_PrimaryKeyUpdate_ShouldFailUpdate
Type: org.opentest4j.AssertionFailedError
Message: Expected exceptions.DBAppException to be thrown, but nothing was thrown.

Fix the bug in the code to make the failing tests pass. The tests act as both a bug report and a verification tool.",gitbugjava.eval.x86_64.yehiafarghaly-database-engine-c5f961f27373:msbench-0.0.1,"diff --git a/src/main/java/app/DBApp.java b/src/main/java/app/DBApp.java
index 9094d5e..96beffc 100644
--- a/src/main/java/app/DBApp.java
+++ b/src/main/java/app/DBApp.java
@@ -178,22 +178,39 @@ public class DBApp implements IDatabase {
 			Validator.validateTable(strTableName, myTables);
 			Table table = Serializer.deserializeTable(strTableName);
 			if (action == Action.INSERT) {
-				Validator.validateInsertionInput(table, htblColNameValue, myTables);
-				table.insertTuple(htblColNameValue);
+				takeInsertAction(table, htblColNameValue);
 			} else if (action == Action.DELETE) {
-				Validator.validateDeletionInput(table, htblColNameValue, myTables);
-				table.deleteTuples(htblColNameValue);
+				takeDeleteAction(table, htblColNameValue);
 			} else {
-				castClusteringKeyType(table);
-				htblColNameValue.put(table.getPKColumn(), clusteringKey);
-				Validator.validateUpdateInput(table, htblColNameValue, myTables);
-				table.updateRecordsInTaple(clusteringKey, htblColNameValue);
+				takeUpdateAction(table, htblColNameValue);
 			}
 			Serializer.serializeTable(table);
 		} catch (CsvValidationException | ClassNotFoundException | IOException | ParseException e1) {
+			throw new DBAppException();
 		}
 	}
 
+	private void takeInsertAction(Table table, Hashtable<String, Object> htblColNameValue)
+			throws ClassNotFoundException, DBAppException, IOException, ParseException, CsvValidationException {
+		Validator.validateInsertionInput(table, htblColNameValue, myTables);
+		table.insertTuple(htblColNameValue);
+	}
+
+	private void takeDeleteAction(Table table, Hashtable<String, Object> htblColNameValue)
+			throws ClassNotFoundException, DBAppException, IOException, ParseException, CsvValidationException {
+		Validator.validateDeletionInput(table, htblColNameValue, myTables);
+		table.deleteTuples(htblColNameValue);
+	}
+
+	private void takeUpdateAction(Table table, Hashtable<String, Object> htblColNameValue)
+			throws DBAppException, CsvValidationException, ClassNotFoundException, IOException, ParseException {
+		castClusteringKeyType(table);
+		Validator.checkNoClusteringKey(htblColNameValue, table);
+		htblColNameValue.put(table.getPKColumn(), clusteringKey);
+		Validator.validateUpdateInput(table, htblColNameValue, myTables);
+		table.updateRecordsInTaple(clusteringKey, htblColNameValue);
+	}
+
 	private void castClusteringKeyType(Table table) {
 		clusteringKey = TypeCaster.castClusteringKey(table, clusteringKeyValue);
 	}
diff --git a/src/main/java/util/validation/Validator.java b/src/main/java/util/validation/Validator.java
index 2330f9f..450343c 100644
--- a/src/main/java/util/validation/Validator.java
+++ b/src/main/java/util/validation/Validator.java
@@ -34,8 +34,8 @@ public class Validator {
 		} else if (!validDataTypes(htblColNameType)) {
 			throw new DBAppException(Constants.ERROR_MESSAGE_DATATYPE);
 
-		} else if (!validMinAndMax(htblColNameType, htblColNameMin, htblColNameMax)
-				|| !sameColMinMax(htblColNameMin, htblColNameMax)) {
+		} else if (!sameCol(htblColNameMin, htblColNameMax, htblColNameType)
+				|| !validMinAndMax(htblColNameType, htblColNameMin, htblColNameMax)) {
 			throw new DBAppException(Constants.ERROR_MESSAGE_MIN_OR_MAX_NOT_VALID);
 
 		}
@@ -86,9 +86,10 @@ public class Validator {
 		return true;
 	}
 
-	private static boolean sameColMinMax(Hashtable<String, String> htblColNameMin,
-			Hashtable<String, String> htblColNameMax) {
-		return htblColNameMin.keySet().equals(htblColNameMax.keySet());
+	private static boolean sameCol(Hashtable<String, String> htblColNameMin, Hashtable<String, String> htblColNameMax,
+			Hashtable<String, String> htblColNameType) {
+		return htblColNameMin.keySet().equals(htblColNameMax.keySet())
+				&& htblColNameMin.keySet().equals(htblColNameType.keySet());
 
 	}
 
@@ -113,6 +114,13 @@ public class Validator {
 			throw new DBAppException(Constants.ERROR_MESSAGE_TUPLE_DATA);
 	}
 
+	public static void checkNoClusteringKey(Hashtable<String, Object> htblColNameValue, Table table)
+			throws DBAppException {
+		if (htblColNameValue.containsKey(table.getPKColumn()))
+			throw new DBAppException(Constants.ERROR_MESSAGE_TUPLE_DATA);
+
+	}
+
 	private static boolean isValidTable(String tableName, HashSet<String> myTables) {
 		return myTables.contains(tableName);
 	}
@@ -292,5 +300,4 @@ public class Validator {
 	private static boolean isFirstGreaterThanSecond(Object comp1, Object comp2) {
 		return Compare.compare(comp1, comp2) > 0;
 	}
-
 }
\ No newline at end of file
"
